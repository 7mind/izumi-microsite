<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="izumi-r2">
<meta name="generator" content="Paradox, paradox-material-theme=0.5.1, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="izumi-r2">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>distage Staged Dependency Injection ? Izumi Toolkit</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Izumi Toolkit" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Izumi Toolkit
</span>
<span class="md-header-nav__topic">
distage Staged Dependency Injection
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Izumi Toolkit" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="../index.html" title="Izumi Toolkit">
Izumi Toolkit
</a>
</label>
<ul>
  <li><a href="../idealingua/index.html" class="page">IdeaLingua RPC &amp; Domain Modeling Language</a>
  <ul>
    <li><a href="../idealingua/language-reference.html" class="page">Idealingua Language Reference</a></li>
    <li><a href="../idealingua/json.html" class="page">JSON Wire Format</a></li>
    <li><a href="../idealingua/cogen.html" class="page">Code generator reference</a></li>
    <li><a href="../idealingua/cogen-circe.html" class="page">Circe serialization reference</a></li>
  </ul></li>
  <li><a href="../distage/index.html" class="active page">distage Staged Dependency Injection</a></li>
  <li><a href="../logstage/index.html" class="page">LogStage</a>
  <ul>
    <li><a href="../logstage/policy.html" class="page">Rendering policy</a></li>
    <li><a href="../logstage/config.html" class="page">Logstage Config</a></li>
    <li><a href="../logstage/custom_ctx.html" class="page">Custom Context</a></li>
  </ul></li>
  <li><a href="../sbt/index.html" class="page">SBT Toolkit</a></li>
  <li><a href="../manifesto/index.html" class="page">Productivity and challenges</a></li>
  <li><a href="../pper/index.html" class="page">PPER Pattern</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../distage/index.html#distage-staged-dependency-injection" class="header">distage Staged Dependency Injection</a>
  <ul>
    <li><a href="../distage/index.html#hello-world" class="header">Hello World</a></li>
    <li><a href="../distage/index.html#multibindings-set-bindings" class="header">Multibindings / Set Bindings</a></li>
    <li><a href="../distage/index.html#provider-bindings" class="header">Provider Bindings</a></li>
    <li><a href="../distage/index.html#tagless-final-style-with-distage" class="header">Tagless Final Style with distage</a></li>
    <li><a href="../distage/index.html#config-files" class="header">Config files</a></li>
    <li><a href="../distage/index.html#effectful-instantiation" class="header">Effectful instantiation</a></li>
    <li><a href="../distage/index.html#inner-classes-and-path-dependent-types" class="header">Inner Classes and Path-Dependent Types</a></li>
    <li><a href="../distage/index.html#implicits-injection" class="header">Implicits Injection</a></li>
    <li><a href="../distage/index.html#auto-traits-auto-factories" class="header">Auto-Traits &amp; Auto-Factories</a></li>
    <li><a href="../distage/index.html#patterns" class="header">Patterns</a></li>
    <li><a href="../distage/index.html#import-materialization" class="header">Import Materialization</a></li>
    <li><a href="../distage/index.html#depending-on-locator" class="header">Depending on Locator</a></li>
    <li><a href="../distage/index.html#ensuring-service-boundaries-using-api-modules" class="header">Ensuring service boundaries using API modules</a></li>
    <li><a href="../distage/index.html#plugins" class="header">Plugins</a></li>
    <li><a href="../distage/index.html#roles" class="header">Roles</a></li>
    <li><a href="../distage/index.html#test-kit" class="header">Test Kit</a></li>
    <li><a href="../distage/index.html#static-configurations" class="header">Static Configurations</a></li>
    <li><a href="../distage/index.html#using-garbage-collector" class="header">Using Garbage Collector</a></li>
    <li><a href="../distage/index.html#compile-time-checks" class="header">Compile-Time Checks</a></li>
    <li><a href="../distage/index.html#circular-dependencies-support" class="header">Circular Dependencies support</a></li>
    <li><a href="../distage/index.html#auto-sets-collecting-bindings-by-predicate" class="header">Auto-Sets: Collecting Bindings By Predicate</a></li>
    <li><a href="../distage/index.html#debugging-introspection-diagnostics-and-hooks" class="header">Debugging, Introspection, Diagnostics and Hooks</a></li>
    <li><a href="../distage/index.html#extensions-and-plan-rewriting-writing-a-distage-extension" class="header">Extensions and Plan Rewriting - writing a distage extension</a></li>
    <li><a href="../distage/index.html#migrating-from-guice" class="header">Migrating from Guice</a></li>
    <li><a href="../distage/index.html#migrating-from-macwire" class="header">Migrating from MacWire</a></li>
    <li><a href="../distage/index.html#integrations" class="header">Integrations</a></li>
    <li><a href="../distage/index.html#cats" class="header">Cats</a></li>
    <li><a href="../distage/index.html#scalaz" class="header">Scalaz</a></li>
    <li><a href="../distage/index.html#zio" class="header">ZIO</a></li>
    <li><a href="../distage/index.html#freestyle" class="header">Freestyle</a></li>
    <li><a href="../distage/index.html#eff" class="header">Eff</a></li>
    <li><a href="../distage/index.html#pper" class="header">PPER</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.5.75
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../distage/index.html#distage-staged-dependency-injection" class="header">distage Staged Dependency Injection</a>
  <ul>
    <li><a href="../distage/index.html#hello-world" class="header">Hello World</a></li>
    <li><a href="../distage/index.html#multibindings-set-bindings" class="header">Multibindings / Set Bindings</a></li>
    <li><a href="../distage/index.html#provider-bindings" class="header">Provider Bindings</a></li>
    <li><a href="../distage/index.html#tagless-final-style-with-distage" class="header">Tagless Final Style with distage</a></li>
    <li><a href="../distage/index.html#config-files" class="header">Config files</a></li>
    <li><a href="../distage/index.html#effectful-instantiation" class="header">Effectful instantiation</a></li>
    <li><a href="../distage/index.html#inner-classes-and-path-dependent-types" class="header">Inner Classes and Path-Dependent Types</a></li>
    <li><a href="../distage/index.html#implicits-injection" class="header">Implicits Injection</a></li>
    <li><a href="../distage/index.html#auto-traits-auto-factories" class="header">Auto-Traits &amp; Auto-Factories</a></li>
    <li><a href="../distage/index.html#patterns" class="header">Patterns</a></li>
    <li><a href="../distage/index.html#import-materialization" class="header">Import Materialization</a></li>
    <li><a href="../distage/index.html#depending-on-locator" class="header">Depending on Locator</a></li>
    <li><a href="../distage/index.html#ensuring-service-boundaries-using-api-modules" class="header">Ensuring service boundaries using API modules</a></li>
    <li><a href="../distage/index.html#plugins" class="header">Plugins</a></li>
    <li><a href="../distage/index.html#roles" class="header">Roles</a></li>
    <li><a href="../distage/index.html#test-kit" class="header">Test Kit</a></li>
    <li><a href="../distage/index.html#static-configurations" class="header">Static Configurations</a></li>
    <li><a href="../distage/index.html#using-garbage-collector" class="header">Using Garbage Collector</a></li>
    <li><a href="../distage/index.html#compile-time-checks" class="header">Compile-Time Checks</a></li>
    <li><a href="../distage/index.html#circular-dependencies-support" class="header">Circular Dependencies support</a></li>
    <li><a href="../distage/index.html#auto-sets-collecting-bindings-by-predicate" class="header">Auto-Sets: Collecting Bindings By Predicate</a></li>
    <li><a href="../distage/index.html#debugging-introspection-diagnostics-and-hooks" class="header">Debugging, Introspection, Diagnostics and Hooks</a></li>
    <li><a href="../distage/index.html#extensions-and-plan-rewriting-writing-a-distage-extension" class="header">Extensions and Plan Rewriting - writing a distage extension</a></li>
    <li><a href="../distage/index.html#migrating-from-guice" class="header">Migrating from Guice</a></li>
    <li><a href="../distage/index.html#migrating-from-macwire" class="header">Migrating from MacWire</a></li>
    <li><a href="../distage/index.html#integrations" class="header">Integrations</a></li>
    <li><a href="../distage/index.html#cats" class="header">Cats</a></li>
    <li><a href="../distage/index.html#scalaz" class="header">Scalaz</a></li>
    <li><a href="../distage/index.html#zio" class="header">ZIO</a></li>
    <li><a href="../distage/index.html#freestyle" class="header">Freestyle</a></li>
    <li><a href="../distage/index.html#eff" class="header">Eff</a></li>
    <li><a href="../distage/index.html#pper" class="header">PPER</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#distage-staged-dependency-injection" name="distage-staged-dependency-injection" class="anchor"><span class="anchor-link"></span></a>distage Staged Dependency Injection</h1>
<p><code>distage</code> is a pragmatic module system for Scala that combines safety and reliability of pure FP with late binding and flexibility of runtime dependency injection frameworks such as Guice.</p>
<h3><a href="#hello-world" name="hello-world" class="anchor"><span class="anchor-link"></span></a>Hello World</h3>
<p>Let&rsquo;s start with a simple Hello app:</p>
<pre class="prettyprint"><code class="language-scala">import distage._

class Hello {
  def hello(name: String) = println(s&quot;Hello $name!&quot;)
}

object HelloModule extends ModuleDef {
  make[Hello]
}

object Main extends App {
  val injector: Injector = Injector()
  val plan: OrderedPlan  = injector.plan(HelloModule)
  val classes: Locator   = injector.produce(plan)

  println(&quot;What&#39;s your name?&quot;)
  val name = readLine()
  
  classes.get[Hello].hello(name)
}
</code></pre>
<p>We&rsquo;ll break it down line-by-line:</p>
<pre class="prettyprint"><code class="language-scala">object HelloModule extends ModuleDef {
  make[Hello]
}
</code></pre>
<p>Here we define a <em>Module</em> for our application. A module specifies <em>what</em> classes to instantiate and <em>how</em> to instantiate them.</p>
<p>By default, <code>distage</code> will just call the constructor.</p>
<p>If a class&rsquo;s constructor requires arguments, distage will first instantiate the arguments, then call the constructor with its dependencies fulfilled. All classes in distage are instantiated exactly once, even if multiple different classes depend on them, i.e. they&rsquo;re <code>Singletons</code>.</p>
<p>A module can be combined with another to produce a larger module via <code>++</code> and <code>overridenBy</code> operators. We can create a <code>ByeModule</code> and join it with our <code>HelloModule</code>:</p>
<pre class="prettyprint"><code class="language-scala">object ByeModule extends ModuleDef {
  make[Bye]
}

class Bye {
  def bye(name: String) = println(s&quot;Bye $name!&quot;)
}

val helloBye: Module = HelloModule ++ ByeModule
</code></pre>
<p>We can override the implementation of <code>Hello</code> class by overriding our <code>HelloModule</code> with an alternative implementation:</p>
<pre class="prettyprint"><code class="language-scala">val uppercaseHello: Hello = 
  new Hello { 
    def hello(name: String) = s&quot;HELLO ${name.toUpperCase}&quot;
  }

object UppercaseHelloModule extends ModuleDef {
  make[Hello].from(uppercaseHello)  
}

val uppercaseHelloBye: Module = helloBye overridenBy uppercaseHello 
</code></pre>
<p>Combining modules with <code>++</code> is the main way to assemble your app together. For scenarios requiring extreme late-binding across multiple modules, you can use the <a href="#plugins">Plugins</a> mechanism to automatically discover modules from the classpath.</p>
<p>Whether you combine modules explicitly or through [Plugins], distage can check at compile-time if your app is wired correctly. If the modules typecheck, the app is guaranteed to start. See <a href="#static-configurations">Static Configurations</a> for more details.</p>
<p>Let&rsquo;s go back to the code:</p>
<pre class="prettyprint"><code class="language-scala">object Main extends App {
  val injector: Injector = Injector()
  val plan: OrderedPlan  = injector.plan(HelloModule)
</code></pre>
<p>Here we create an instantation <code>plan</code> from the module definition. distage is <em>staged</em>, so instead of instantiating our definitions right away, distage first builds a pure representation of all the operations it will do and returns it back to us.</p>
<p>This allows us to easily implement additional functionality on top of distage without modifying the library. Features such as <a href="#plugins">Plugins</a> and <a href="#config-files">Configurations</a> are separate libraries, built on <a href="#import-materialization">transforming modules and plans</a></p>
<pre class="prettyprint"><code class="language-scala">  val classes: Locator   = injector.produce(plan)

  println(&quot;What&#39;s your name?&quot;)
  val name = readLine()
  
  classes.get[Hello].hello(name)
</code></pre>
<p>Executing the plan yields us a <code>Locator</code>, that holds all the instantiated classes. This is where <code>distage</code> ends, and app&rsquo;s main logic begins.</p>
<p>Given a <code>Locator</code> we can retrieve instances by type, call methods on them or summon them with a function:</p>
<pre class="prettyprint"><code class="language-scala">import scala.util.Random

classes.run {
  (hello: Hello, bye: Bye) =&gt;
    val names = Array(&quot;Snow&quot;, &quot;Marisa&quot;, &quot;Shelby&quot;)
    val rnd = Random.nextInt(3)
    hello(names(rnd))
    bye(names(rnd))
}
</code></pre>
<pre class="prettyprint"><code class="language-scala">classes.runOption {
  i: Int =&gt; i + 10
}.fold(println(&quot;I thought I had Int!&quot;))(println(_))
</code></pre>
<h3><a href="#multibindings-set-bindings" name="multibindings-set-bindings" class="anchor"><span class="anchor-link"></span></a>Multibindings / Set Bindings</h3>
<p>Multibindings are useful for implementing event listeners, plugins, hooks, http routes, etc.</p>
<p>To define a multibinding use <code>.many</code> and <code>.add</code> methods in <a href="/latest/release/api/com/github/pshirshov/izumi/distage/model/definition/ModuleDef.html">ModuleDef</a> DSL:</p>
<pre class="prettyprint"><code class="language-scala">import cats.effect._, org.http4s._, org.http4s.dsl.io._
import scala.concurrent.ExecutionContext.Implicits.global
import distage._

object HomeRouteModule extends ModuleDef {
  many[HttpRoutes[IO]].add {
    HttpRoutes.of[IO] { 
      case GET -&gt; Root / &quot;home&quot; =&gt; Ok(s&quot;Home page!&quot;) 
    }
  }
}
</code></pre>
<p>Multibindings defined in different modules will be merged together into a single Set. You can summon a multibinding by type <code>Set[_]</code>:</p>
<pre class="prettyprint"><code class="language-scala">import cats.implicits._, import org.http4s.server.blaze._, import org.http4s.implicits._

object BlogRouteModule extends ModuleDef {
  many[HttpRoutes[IO]].add {
    HttpRoutes.of[IO] { 
      case GET -&gt; Root / &quot;blog&quot; / post =&gt; Ok(&quot;Blog post ``$post&#39;&#39;!&quot;) 
    }
  }
}

class HttpServer(routes: Set[HttpRoutes[IO]]) {
  val router = routes.foldK

  def serve = BlazeBuilder[IO]
    .bindHttp(8080, &quot;localhost&quot;)
    .mountService(router, &quot;/&quot;)
    .start
}

val context = Injector().produce(HomeRouteModule ++ BlogRouteModule)
val server = context.get[HttpServer]

val testRouter = server.router.orNotFound

testRouter.run(Request[IO](uri = uri(&quot;/home&quot;))).flatMap(_.as[String]).unsafeRunSync
// Home page!

testRouter.run(Request[IO](uri = uri(&quot;/blog/1&quot;))).flatMap(_.as[String]).unsafeRunSync
// Blog post ``1&#39;&#39;!
</code></pre>
<p>For further detail see <a href="https://github.com/google/guice/wiki/Multibindings">Guice wiki on Multibindings</a>.</p>
<h3><a href="#provider-bindings" name="provider-bindings" class="anchor"><span class="anchor-link"></span></a>Provider Bindings</h3>
<p>To bind a function instead of constructor use <code>.from</code> method in <a href="/latest/release/api/com/github/pshirshov/izumi/distage/model/definition/ModuleDef.html">ModuleDef</a> DSL:</p>
<pre class="prettyprint"><code class="language-scala">case class HostPort(host: String, port: Int)

class HttpServer(hostPort: HostPort)

trait HttpServerModule extends ModuleDef {
  make[HttpServer].from {
    hostPort: HostPort =&gt;
      val modifiedPort = hostPort.port + 1000
      new HttpServer(hostPort.host, modifiedPort)
  }
}
</code></pre>
<p>To inject named instances or config values, add annotations to lambda arguments&rsquo; types:</p>
<pre class="prettyprint"><code class="language-scala">trait HostPortModule extends ModuleDef {
  make[HostPort].from {
    (configHost: String @ConfPath(&quot;http.host&quot;), configPort: Int @ConfPath(&quot;http.port&quot;)) =&gt;
      HostPort(configHost, configPort)
  }
}
</code></pre>
<p>For further details, see scaladoc for <a href="/latest/release/api/com/github/pshirshov/izumi/distage/model/providers/ProviderMagnet.html">ProviderMagnet</a></p>
<h3><a href="#tagless-final-style-with-distage" name="tagless-final-style-with-distage" class="anchor"><span class="anchor-link"></span></a>Tagless Final Style with distage</h3>
<p>distage works well with tagless final style. As an example, let&rsquo;s take <a href="http://frees.io/docs/core/handlers/#tagless-interpretation">freestyle&rsquo;s tagless example</a> and make it safer and more flexible by replacing fragile wiring <code>import ._</code>&rsquo;s with explicit modules.</p>
<p>First, the program we want to write:</p>
<pre class="prettyprint"><code class="language-scala">import cats.Monad
import scala.util.Try

import distage._

class Program[F[_]: TagK: Monad] extends ModuleDef {
  make[TaglessProgram[F]]

  addImplicit[Monad[F]]
}

class TaglessProgram[F[_]: Monad](validation: Validation[F], interaction: Interaction[F]) {
  def program = for {
      userInput &lt;- interaction.ask(&quot;Give me something with at least 3 chars and a number on it&quot;)
      valid     &lt;- (validation.minSize(userInput, 3), validation.hasNumber(userInput)).mapN(_ &amp;&amp; _)
      _         &lt;- if (valid) interaction.tell(&quot;awesomesauce!&quot;) else interaction.tell(s&quot;$userInput is not valid&quot;)
  } yield ()
}
</code></pre>
<p><a href="/latest/release/api/com/github/pshirshov/izumi/fundamentals/reflection/WithTags.html#TagK">TagK</a> is distage&rsquo;s analogue of <code>TypeTag</code> for higher-kinded types such as <code>F[_]</code>, it allows preserving type-information at runtime for types that aren&rsquo;t yet known at definition. You&rsquo;ll need to add a <a href="/latest/release/api/com/github/pshirshov/izumi/fundamentals/reflection/WithTags.html#TagK">TagK</a> context bound to create a module parameterized by an abstract <code>F[_]</code>. Use <a href="/latest/release/api/com/github/pshirshov/izumi/fundamentals/reflection/WithTags.html#Tag">Tag</a> to create modules parameterized by non-higher-kineded types.</p>
<p>Interpreters:</p>
<pre class="prettyprint"><code class="language-scala">object TryInterpreters extends ModuleDef {
  make[Validation.Handler[Try]].from(tryValidationHandler)
  make[Interaction.Handler[Try]].from(tryInteractionHandler)
  
  def tryValidationHandler = new Validation.Handler[Try] {
    override def minSize(s: String, n: Int): Try[Boolean] = Try(s.size &gt;= n)
    override def hasNumber(s: String): Try[Boolean] = Try(s.exists(c =&gt; &quot;0123456789&quot;.contains(c)))
  }
  
  def tryInteractionHandler = new Interaction.Handler[Try] {
    override def tell(s: String): Try[Unit] = Try(println(s))
    override def ask(s: String): Try[String] = Try(&quot;This could have been user input 1&quot;)
  }
}

object App extends App {
  import cats.instances.try_._
  // Combine modules into a full program
  val TryProgram: Module = new Program[Try] ++ TryInterpreters
  // run
  Injector().produce(TryProgram).get[TaglessProgram[Try]]
    .program
}
</code></pre>
<p>The program module is polymorphic and abstracted from its eventual monad, we can easily parameterize it with a different monad:</p>
<pre class="prettyprint"><code class="language-scala">import cats.effect.IO

def IOInterpreters = ???
val IOProgram = new Program[IO] ++ IOInterpreters
</code></pre>
<p>We can leave it polymorphic as well: </p>
<pre class="prettyprint"><code class="language-scala">import cats.effect.Sync

def SyncInterpreters[F[_]: Sync] = ???
def SyncProgram[F[_]: Sync] = new Program[F] ++ SyncInterpreters[F]
</code></pre>
<p>Or choose different interpreters at runtime:</p>
<pre class="prettyprint"><code class="language-scala">def chooseInterpreters(default: Boolean) = new Program[Try] ++ (if (default) TryInterpreters else DifferentTryInterpreters)
</code></pre>
<p>Modules can abstract over arbitrary kinds - use <code>TagKK</code> to abstract over bifunctors:</p>
<pre class="prettyprint"><code class="language-scala">class BIOModule[F[_, _]: TagKK] extends ModuleDef 
</code></pre>
<p><code>TagTK</code> over monad transformers:</p>
<pre class="prettyprint"><code class="language-scala">class TransModule[F[_[_], _]: TagTK] extends ModuleDef
</code></pre>
<p>Adding a <code>Tag</code> for more exotic type shapes is as easy as defining a type synonym, consult <a href="/latest/release/api/com/github/pshirshov/izumi/fundamentals/reflection/WithTags/HKTag.html">HKTag</a> docs for description</p>
<h3><a href="#config-files" name="config-files" class="anchor"><span class="anchor-link"></span></a>Config files</h3>
<p><code>distage-config</code> library parses <code>typesafe-config</code> into arbitrary case classes or sealed traits and makes them available for summoning as a class dependency.</p>
<p>To use it, add <code>distage-config</code> library:</p>
<pre class="prettyprint"><code class="language-scala">libraryDependencies += Izumi.R.distage_config
</code></pre>
<p>or</p>
<pre class="prettyprint"><code class="language-scala">libraryDependencies += &quot;com.github.pshirshov.izumi.r2&quot; %% &quot;distage-config&quot; % &quot;0.5.75&quot;
</code></pre>
<p>If you&rsquo;re not using <a href="../sbt/index.html#bills-of-materials">sbt-izumi-deps</a> plugin.</p>
<p>Write a config in HOCON format:</p>
<pre class="prettyprint"><code class="language-hocon"># resources/application.conf
program {
    config {
        different = true
    }
}
</code></pre>
<p>Add <code>ConfigModule</code> into your injector:</p>
<pre class="prettyprint"><code class="language-scala">import distage.config._
import com.typesafe.config.ConfigFactory

val config = ConfigFactory.load()

val injector = Injector(new ConfigModule(AppConfig(config)))
</code></pre>
<p>Now you can automatically parse config entries into case classes and can summon them from any class:</p>
<pre class="prettyprint"><code class="language-scala">final case class Config(different: Boolean)

class ConfiguredTaglessProgram[F](
  @ConfPath(&quot;program.config&quot;) config: Config,
  @Id(&quot;primary&quot;) primaryProgram: TaglessProgram[F],
  @Id(&quot;different&quot;) differentProgram: TaglessProgram[F]) {

    val program = if (config.different) differentProgram else primaryProgram
}

class ConfiguredTryProgram[F[_]: TagK: Monad] extends ModuleDef {
  make[ConfiguredProgram[F]]
  make[TaglessProgram[F]].named(&quot;primary&quot;)
  make[TaglessProgram[F]].named(&quot;different&quot;)
}
</code></pre>
<h3><a href="#effectful-instantiation" name="effectful-instantiation" class="anchor"><span class="anchor-link"></span></a>Effectful instantiation</h3><div class="callout warning "><div class="callout-title">TODO</div>
<p>Sorry, this page is not ready yet</p></div>
<p>Example of explicitly splitting effectful and pure instantiations:</p>
<pre class="prettyprint"><code class="language-scala">import distage._
import distage.config._
import com.typesafe.config.ConfigFactory

import scala.concurrent.{Await, Future}
import scala.concurrent.duration.Duration
import scala.concurrent.ExecutionContext.global

case class DbConf()
case class MsgQueueConf()
case class RegistryConf()

class DBService[F[_]]
class MsgQueueService[F[_]]
class RegistryService[F[_]]

class DomainService[F[_]]
( dbService: DBService[F]
, msgQueueService: MsgQueueService[F]
, registryService: RegistryService[F]
) {
  def run: F[Unit] = ???
}

class ExternalInitializers[F[_]: TagK] extends ModuleDef {
  make[F[DBService[F]]].from { dbConf: DbConf @ConfPath(&quot;network-service.db&quot;) =&gt; ??? }
  make[F[MsgQueueService[F]]].from { msgQueueConf: MsgQueueConf @ConfPath(&quot;network-service.msg-queue&quot;) =&gt; ??? }
  make[F[RegistryService[F]]].from { registryConf: RegistryConf @ConfPath(&quot;network-service.registry&quot;) =&gt; ??? }
}

val injector = Injector(new ConfigModule(AppConfig(ConfigFactory.load())))
val initializers = injector.produce(new ExternalInitializers[Future])

class DomainServices[F[_]: TagK] extends ModuleDef {
  make[DomainService[F]]
}

val main: Future[Unit] = initializers.run {
  ( dbF: Future[DBService[Future]]
  , msgF: Future[MsgQueueService[Future]]
  , regF: Future[RegistryService[Future]]
  ) =&gt; for {
    db &lt;- dbF
    msg &lt;- msgF
    reg &lt;- regF

    externalServicesModule = new ModuleDef {
      make[DBService[Future]].from(db)
      make[MsgQueueService[Future]].from(msg)
      make[RegistryService[Future]].from(reg)
    }

    allServices = injector.produce(externalServicesModule ++ new DomainServices[Future])

    _ &lt;- allServices.get[DomainService[Future]].run
  } yield ()
}

Await.result(main, Duration.Inf)
</code></pre>
<p>Effectful instantiation is not recommended in general ? ideally, resources ought to be managed outside of <code>distage</code>. A rule of thumb is: if a class and its dependencies are stateless, and can be replaced by a global <code>object</code>, it&rsquo;s ok to inject them with <code>distage</code>.</p>
<p>See also: <a href="#auto-sets-collecting-bindings-by-predicate">Auto-Sets, closing all AutoCloseables</a></p>
<p>You can participate in the ticket at <a href="https://github.com/pshirshov/izumi-r2/issues/331">https://github.com/pshirshov/izumi-r2/issues/331</a></p>
<h3><a href="#inner-classes-and-path-dependent-types" name="inner-classes-and-path-dependent-types" class="anchor"><span class="anchor-link"></span></a>Inner Classes and Path-Dependent Types</h3><div class="callout warning "><div class="callout-title">TODO</div>
<p>Sorry, this page is not ready yet</p></div>
<p>You can participate in the ticket at <a href="https://github.com/pshirshov/izumi-r2/issues/221">https://github.com/pshirshov/izumi-r2/issues/221</a></p>
<h3><a href="#implicits-injection" name="implicits-injection" class="anchor"><span class="anchor-link"></span></a>Implicits Injection</h3><div class="callout warning "><div class="callout-title">TODO</div>
<p>Sorry, this page is not ready yet</p></div>
<p>Implicits are managed like any other class, declare them in a module to make them available for summoning:</p>
<pre class="prettyprint"><code class="language-scala">import cats.Monad
import distage._
import scalaz.zio.IO
import scalaz.zio.interop.catz._

object IOMonad extends ModuleDef {
  addImplicit[Monad[IO[Throwable, ?]]]
}
</code></pre>
<p>Implicits for wired classes are injected from DI context, not from surrounding lexical scope. If they were captured from lexical scope when the module is defined, then any binding of a class that depends on an implicit, would have to import an <em>implementation</em> of that implicit. Depending on implementations is unmodular and directly contradicts the idea of using a dedicated module system in the first place:</p>
<pre class="prettyprint"><code class="language-scala">import cats._
import distage._

class KVStore[F[_]: Monad, V] {
  def fetch(key: String): F[V]
}

val kvstoreModule = new ModuleDef {
  // We DON&#39;T want this import to be necessary
  // import cats.instances.either._

  make[KVStore[Either[Error, ?]].from[KVStoreEitherImpl]
}

// Instead, specify implicits explicitly
val eitherMonadModule = new ModuleDef {
  // Ok to import here
  import cats.instances.either._
  
  addImplicit[Monad[Either[Error, ?]]]
}

val all = kvstoreMOdule ++ eitherMonadModule
</code></pre>
<p>Implicits obey the usual lexical scope outside of modules managed by <code>distage</code>.</p>
<p>You can participate in the ticket at <a href="https://github.com/pshirshov/izumi-r2/issues/230">https://github.com/pshirshov/izumi-r2/issues/230</a></p>
<h3><a href="#auto-traits-auto-factories" name="auto-traits-auto-factories" class="anchor"><span class="anchor-link"></span></a>Auto-Traits &amp; Auto-Factories</h3><div class="callout warning "><div class="callout-title">TODO</div>
<p>Sorry, this page is not ready yet</p></div>
<p>&hellip;</p>
<h3><a href="#patterns" name="patterns" class="anchor"><span class="anchor-link"></span></a>Patterns</h3>
<h3><a href="#import-materialization" name="import-materialization" class="anchor"><span class="anchor-link"></span></a>Import Materialization</h3><div class="callout warning "><div class="callout-title">TODO</div>
<p>Sorry, this page is not ready yet</p></div>
<p>&hellip;</p>
<h3><a href="#depending-on-locator" name="depending-on-locator" class="anchor"><span class="anchor-link"></span></a>Depending on Locator</h3>
<p>Classes can depend on the Locator:</p>
<pre class="prettyprint"><code class="language-scala">import distage._

class A(all: LocatorRef) {
  def c = all.get.get[C]
}
class B
class C

val module = new ModuleDef {
  make[A]
  make[B]
  make[C]
}

val locator = Injector().produce(module)

assert(locator.get[A].c eq locator.get[C]) 
</code></pre>
<p>It&rsquo;s recommended to avoid this if possible, doing so is often a sign of broken application design.</p>
<h3><a href="#ensuring-service-boundaries-using-api-modules" name="ensuring-service-boundaries-using-api-modules" class="anchor"><span class="anchor-link"></span></a>Ensuring service boundaries using API modules</h3>
<p>&hellip;</p>
<h3><a href="#plugins" name="plugins" class="anchor"><span class="anchor-link"></span></a>Plugins</h3>
<p>When rapidly prototyping, the friction of adding new modules can become a burden. distage plugin extension can alleviate that by automatically picking up all the <code>Plugin</code> modules defined in the program.</p>
<p>Note that auto plugins are incompatible with distage <a href="#static-configurations">static checks</a>. Our recommended workflow is to start with plugins, then switch to static configurations after the program has been stabilized.</p>
<p>To define a plugin, first add distage-plugins library:</p>
<pre class="prettyprint"><code class="language-scala">libraryDependencies += Izumi.R.distage_plugins
</code></pre>
<p>or</p>
<pre class="prettyprint"><code class="language-scala">libraryDependencies += &quot;com.github.pshirshov.izumi.r2&quot; %% &quot;distage-plugins&quot; % &quot;0.5.75&quot;
</code></pre>
<p>If you&rsquo;re not using <a href="../sbt/index.html#bills-of-materials">sbt-izumi-deps</a> plugin.</p>
<p>Create a module extending the <code>PluginDef</code> trait instead of <code>ModuleDef</code>:</p>
<pre class="prettyprint"><code class="language-scala">package com.example.petstore

import distage._
import distage.plugins._

trait PetStorePlugin extends PluginDef {
  make[PetRepository]
  make[PetStoreService]
  make[PetStoreController]
}
</code></pre>
<p>At your app entry point use a plugin loader to discover all <code>PluginDefs</code>:</p>
<pre class="prettyprint"><code class="language-scala">val pluginLoader = new PluginLoaderDefaultImpl(
  PluginConfig(
    debug = true
    , packagesEnabled = Seq(&quot;com.example.petstore&quot;) // packages to scan
    , packagesDisabled = Seq.empty         // packages to ignore
  )
)

val appModules: Seq[PluginBase] = pluginLoader.load()
val app: ModuleBase = appModules.merge
</code></pre>
<p>Launch as normal with the loaded modules:</p>
<pre class="prettyprint"><code class="language-scala">Injector().produce(app).get[PetStoreController].run
</code></pre>
<p>Plugins also allow a program to dynamically extend itself by adding new Plugin classes on the classpath at launch time via <code>java -cp</code></p>
<h3><a href="#roles" name="roles" class="anchor"><span class="anchor-link"></span></a>Roles</h3><div class="callout warning "><div class="callout-title">TODO</div>
<p>Sorry, this page is not ready yet</p></div>
<p>&ldquo;Roles&rdquo; are a pattern of multi-tenant applications, in which multiple separate microservices all reside within a single <code>.jar</code>. This strategy helps cut down development, maintenance and operations costs associated with maintaining fully separate code bases and binaries. The apps that should be launched are chosen by command-line parameters: <code>./launcher app1 app2 app3</code>. When launching less apps than are available in the launcher - <code>./launcher app1</code>, redundant components will be collected by the <a href="#using-garbage-collector">garbage collector</a> and won&rsquo;t be started.</p>
<p>Roles: a viable alternative to Microservices:</p>
<p><a href="https://github.com/7mind/slides/blob/master/02-roles/target/roles.pdf">https://github.com/7mind/slides/blob/master/02-roles/target/roles.pdf</a></p>
<h3><a href="#test-kit" name="test-kit" class="anchor"><span class="anchor-link"></span></a>Test Kit</h3>
<p><code>distage-testkit</code> module provides integration with <code>scalatest</code>:</p>
<pre class="prettyprint"><code class="language-scala">libraryDependencies += Izumi.R.distage_testkit
</code></pre>
<p>or</p>
<pre class="prettyprint"><code class="language-scala">libraryDependencies += &quot;com.github.pshirshov.izumi.r2&quot; %% &quot;distage-plugins&quot; % &quot;0.5.75&quot;
</code></pre>
<p>If you&rsquo;re not using <a href="../sbt/index.html#bills-of-materials">sbt-izumi-deps</a> plugin.</p>
<p>Example usage:</p>
<pre class="prettyprint"><code class="language-scala">import distage._
import com.github.pshirshov.izumi.distage.testkit.DistageSpec

class TestClass {
  def hello: String = &quot;Hello World!&quot;
}

class Test extends DistageSpec {
  override protected def makeBindings: ModuleBase = new ModuleDef {
    make[TestClass]
  }

  &quot;TestClass&quot; should {

    &quot;Say hello&quot; in di {
      testClass: TestClass =&gt;
        assert(testClass.hello == &quot;Hello World!&quot;)
    }

  }
}
</code></pre>
<h3><a href="#static-configurations" name="static-configurations" class="anchor"><span class="anchor-link"></span></a>Static Configurations</h3><div class="callout warning "><div class="callout-title">TODO</div>
<p>Sorry, this page is not ready yet</p></div>
<p>&hellip;</p>
<h3><a href="#using-garbage-collector" name="using-garbage-collector" class="anchor"><span class="anchor-link"></span></a>Using Garbage Collector</h3>
<p>A garbage collector is included in <code>distage</code>, but has to be enabled explicitly:</p>
<pre class="prettyprint"><code class="language-scala">import distage._

class Main

// Designate `Main` class as the garbage collection root
val roots = Seq(DIKey.get[Main])

// Enable GC
val gcModule = new TracingGCModule(roots)
val injector = Injector(gcModule)
</code></pre>
<p>GC will remove all bindings that aren&rsquo;t transitive dependencies of the chosen <code>GC root</code> keys from the plan - they will never be instantiated.</p>
<p>In the following example:</p>
<pre class="prettyprint"><code class="language-scala">import distage._

case class A(b: B)
case class B()
case class C() {
  println(&quot;C!&quot;)
}

val module = new ModuleDef {
  make[A]
  make[B]
  make[C]
}

val roots = Seq(DIKey.get[A])

val locator = Injector(new TracingGCModule(roots)).produce(module)

locator.find[A]
// res0: Option[A] = Some(A(B()))
locator.find[B]
// res1: Option[B] = Some(B())
locator.find[C]
// res2: Option[C] = None
</code></pre>
<p>Class <code>C</code> is removed because it wasn&rsquo;t dependent on by classes <code>B</code> or <code>A</code>. It&rsquo;s not present in the <code>Locator</code> and the <code>&quot;C!&quot;</code> message was never printed. If class <code>B</code> were to depend on <code>C</code> as in <code>case class B(c: C)</code>, it would&rsquo;ve been retained, because <code>A</code> which is the GC root, would&rsquo;ve depended on <code>B</code> which in turns depends on <code>C</code>.</p>
<p>GC serves two important purposes: * it enables faster <a href="#test-kit">tests</a> by omitting unneeded instantiations, * and it enables multiple separate applications, &ldquo;<a href="#roles">Roles</a>&rdquo; to be hosted within a single <code>.jar</code>.</p>
<h3><a href="#compile-time-checks" name="compile-time-checks" class="anchor"><span class="anchor-link"></span></a>Compile-Time Checks</h3><div class="callout warning "><div class="callout-title">TODO</div>
<p>Sorry, this page is not ready yet</p></div>
<p>&hellip;</p>
<h3><a href="#circular-dependencies-support" name="circular-dependencies-support" class="anchor"><span class="anchor-link"></span></a>Circular Dependencies support</h3>
<p><code>distage</code> automatically resolves circular dependencies, including self-reference:</p>
<pre class="prettyprint"><code class="language-scala">import distage._

case class A(b: B)
case class B(a: A) 
case class C(c: C)

val locator = Injector().produce(new ModuleDef {
  make[A]
  make[B]
  make[C]
})

locator.get[A] eq locator.get[B].a
// res0: Boolean = true
locator.get[B] eq locator.get[A].b
// res1: Boolean = true
locator.get[C] eq locator.get[C].c
// res2: Boolean = true
</code></pre>
<h4><a href="#automatic-resolution-with-generated-proxies" name="automatic-resolution-with-generated-proxies" class="anchor"><span class="anchor-link"></span></a>Automatic Resolution with generated proxies</h4>
<p>The above strategy depends on <code>distage-proxy-cglib</code> module which is brought in by default with <code>distage-core</code>.</p>
<p>It&rsquo;s enabled by default. If you want to disable it, use <code>noCogen</code> bootstrap environment:</p>
<pre class="prettyprint"><code class="language-scala">import com.github.pshirshov.izumi.distage.bootstrap.DefaultBootstrapContext
import distage._

Injector(DefaultBootstrapContext.noCogen)
</code></pre>
<h4><a href="#manual-resolution-with-by-name-parameters" name="manual-resolution-with-by-name-parameters" class="anchor"><span class="anchor-link"></span></a>Manual Resolution with by-name parameters</h4>
<p>Most cycles can also be resolved manually when identified, using <code>by-name</code> parameters.</p>
<p>Circular dependencies in the following example are all resolved via Scala&rsquo;s native <code>by-name</code>&rsquo;s, without any proxy generation:</p>
<pre class="prettyprint"><code class="language-scala">import com.github.pshirshov.izumi.distage.bootstrap.DefaultBootstrapContext.noCogen
import distage._

class A(b0: =&gt; B) {
  def b: B = b0
}

class B(a0: =&gt; A) {
  def a: A = a0
}

class C(self: =&gt; C) {
  def c: C = self
}

val module = new ModuleDef {
  make[A]
  make[B]
  make[C]
}

val locator = Injector(noCogen).produce(module)

assert(locator.get[A].b eq locator.get[B])
assert(locator.get[B].a eq locator.get[A])
assert(locator.get[C].c eq locator.get[C])
</code></pre>
<p>The proxy generation via <code>cglib</code> is still enabled by default, because in scenarios with <a href="#roles">extreme late-binding</a>, cycles can emerge unexpectedly, outside of control of the origin module. </p>
<h3><a href="#auto-sets-collecting-bindings-by-predicate" name="auto-sets-collecting-bindings-by-predicate" class="anchor"><span class="anchor-link"></span></a>Auto-Sets: Collecting Bindings By Predicate</h3>
<p>AutoSet <a href="/latest/release/api/com/github/pshirshov/izumi/distage/model/Planner.html">Planner</a> Hooks traverse the class graph and collect all classes matching a predicate.</p>
<p>Using Auto-Sets, one can, for example, collect all <code>AutoCloseable</code> classes and <code>.close()</code> them after the application has finished work.</p>
<p>Note: it&rsquo;s not generally recommended to construct stateful, effectful or resource-allocating classes with <code>distage</code>, a general rule of thumb is: if a class and its dependencies are stateless and can be replaced by a global <code>object</code>, it&rsquo;s ok to inject them with <code>distage</code>. However, an example is given anyway, as a lot of real applications depend on global resources, such as JDBC connections, <code>ExecutionContext</code> thread pools, Akka Systems, etc. that should be closed properly at exit.</p>
<pre class="prettyprint"><code class="language-scala">import java.util.concurrent.{ExecutorService, Executors}

import com.github.pshirshov.izumi.distage.model.planning.PlanningHook
import com.github.pshirshov.izumi.distage.planning.AssignableFromAutoSetHook
import distage._

val threadPoolModule = new ModuleDef {
  make[ExecutorService].from(Executors.newWorkStealingPool())
  make[ExecutionContext].from {
    es: ExecutorService =&gt;
      ExecutionContext.fromExecutorService(es)
  }
}

// A hook that collects every instance of a subtype of a given type
val collectAllExecutorServicesHook = new AssignableFromAutoSetHook[ExecutorService]

val bootstrapModule = new BootstrapModuleDef {
  many[PlanningHook]
    .add(collectAllExecutorServicesHook)
}

val injector = Injector(bootstrapModule)

val locator = injector.produce(threadPoolModule)

try {
  // run the app
  ???
} finally {
  // when done, close thread pools
  val allExecutors = locator.get[Set[ExecutorService]]
  allExecutors.foreach(_.shutdownNow())
}
</code></pre>
<h4><a href="#weak-sets" name="weak-sets" class="anchor"><span class="anchor-link"></span></a>Weak Sets</h4>
<p>Sets (aka <a href="#multibindings--set-bindings">Multibindings</a>) can contain <em>weak</em> references. Elements designated as weak will not be retained by the <a href="#using-garbage-collector">Garbage Collector</a> if they are not referenced outside of the set.</p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import distage._

sealed trait SetElem

final class Strong extends SetElem {
  println(&quot;Strong constructed&quot;)
}

final class Weak extends SetElem {
  println(&quot;Weak constructed&quot;)
}

val module = new ModuleDef {
  make[Strong]
  make[Weak]
  
  many[SetElem]
    .ref[Strong]
    .weak[Weak]
}

// Designate Set[SetElem] as the garbage collection root,
// everything that Set[SetElem] does not strongly depend on will be garbage collected
// and will not be constructed. 
val roots = Seq(DIKey.get[Set[SetElem]])

// Enable GC
val gcModule = new TracingGCModule(roots)
val injector = Injector(gcModule)

val locator = injector.produce(roots)
// Strong constructed!

assert(locator.get[Set[SetElem]].size == 1) 
</code></pre>
<p>The <code>Weak</code> class was not required in any dependency of <code>Set[SetElem]</code>, so it was pruned. The <code>Strong</code> class remained, because the reference to it was <strong>strong</strong>, therefore it was counted as a dependency of <code>Set[SetElem]</code></p>
<p>Had we changed <code>Strong</code> to depend on the <code>Weak</code>, the <code>Weak</code> would be retained:</p>
<pre class="prettyprint"><code class="language-scala">final class Strong(weak: Weak) {
  println(&quot;Strong constructed&quot;)
}

assert(locator.get[Set[SetElem]].size == 2)
</code></pre>
<h3><a href="#debugging-introspection-diagnostics-and-hooks" name="debugging-introspection-diagnostics-and-hooks" class="anchor"><span class="anchor-link"></span></a>Debugging, Introspection, Diagnostics and Hooks</h3>
<p>You can print a <code>plan</code> to get detailed info on what will happen during instantiation. The printout includes file:line info so your IDE can show you where the binding was defined! </p>
<pre class="prettyprint"><code class="language-scala">System.err.println(plan: OrderedPlan)
</code></pre>
<p><img src="media/print-test-plan.png" alt="print-test-plan" /></p>
<p>You can also query a plan to see the dependencies and reverse dependencies of a class and their instantiation:</p>
<pre class="prettyprint"><code class="language-scala">// Print dependencies
System.err.println(plan.topology.dependencies.tree(DIKey.get[Circular1]))
// Print reverse dependencies
System.err.println(plan.topology.dependees.tree(DIKey.get[Circular1]))
</code></pre>
<p><img src="media/print-dependencies.png" alt="print-dependencies" /></p>
<p>The printer highlights circular dependencies.</p>
<p>Distage also uses some macros, macros are currently used to create <code>TagK</code>s and <a href="#provider-bindings">provider bindings</a>. If you think they&rsquo;ve gone awry, you can turn macro debug output during compilation by setting <code>-Dizumi.distage.debug.macro=true</code> java property:</p>
<pre class="prettyprint"><code class="language-bash">sbt -Dizumi.distage.debug.macro=true compile
</code></pre>
<p>Macros power <code>distage-static</code> module, an alternative backend that does not use JVM runtime reflection to instantiate classes and auto-traits.</p>
<h3><a href="#extensions-and-plan-rewriting-writing-a-distage-extension" name="extensions-and-plan-rewriting-writing-a-distage-extension" class="anchor"><span class="anchor-link"></span></a>Extensions and Plan Rewriting - writing a distage extension</h3>
<p>&hellip;</p>
<h3><a href="#migrating-from-guice" name="migrating-from-guice" class="anchor"><span class="anchor-link"></span></a>Migrating from Guice</h3>
<p>&hellip;</p>
<h3><a href="#migrating-from-macwire" name="migrating-from-macwire" class="anchor"><span class="anchor-link"></span></a>Migrating from MacWire</h3>
<p>&hellip;</p>
<h3><a href="#integrations" name="integrations" class="anchor"><span class="anchor-link"></span></a>Integrations</h3>
<p>&hellip;</p>
<h3><a href="#cats" name="cats" class="anchor"><span class="anchor-link"></span></a>Cats</h3>
<p>To import cats integration add distage-cats library:</p>
<pre class="prettyprint"><code class="language-scala">libraryDependencies += Izumi.R.distage_cats
</code></pre>
<p>or</p>
<pre class="prettyprint"><code class="language-scala">libraryDependencies += &quot;com.github.pshirshov.izumi.r2&quot; %% &quot;distage-cats&quot; % &quot;0.5.75&quot;
</code></pre>
<p>If you&rsquo;re not using <a href="../sbt/index.html#bills-of-materials">sbt-izumi-deps</a> plugin.</p>
<p>Usage:</p>
<pre class="prettyprint"><code class="language-scala">import cats.implicits._
import cats.effect._
import distage._
import distage.interop.cats._
import com.example.{DBConnection, AppEntrypoint}

object Main extends IOApp {
  def run(args: List[String]): IO[Unit] = {
    val myModules = module1 |+| module2 // Monoid instance for ModuleDef is available now
    
    for {
      plan &lt;- myModules.resolveImportsF[IO] { // resolveImportsF is now available
        case i if i.target == DIKey.get[DBConnection] =&gt;
           DBConnection.create[IO]
      } 
      classes &lt;- Injector().produceIO[IO](plan) // produceIO is now available
      _ &lt;- classes.get[AppEntrypoint].run
    } yield ()
  }
}
</code></pre>
<h3><a href="#scalaz" name="scalaz" class="anchor"><span class="anchor-link"></span></a>Scalaz</h3>
<h3><a href="#zio" name="zio" class="anchor"><span class="anchor-link"></span></a>ZIO</h3>
<h3><a href="#freestyle" name="freestyle" class="anchor"><span class="anchor-link"></span></a>Freestyle</h3>
<h3><a href="#eff" name="eff" class="anchor"><span class="anchor-link"></span></a>Eff</h3>
<h2><a href="#pper" name="pper" class="anchor"><span class="anchor-link"></span></a>PPER</h2>
<p>See <a href="../pper/index.html">PPER Overview</a></p>
</div>
<div>
<a href="https://github.com/pshirshov/izumi-r2/tree/master/doc/paradox/distage/00_distage.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.5.75
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../idealingua/cogen-circe.html" title="Circe serialization reference" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Circe serialization reference
</span>
</div>
</a>
<a href="../logstage/index.html" title="LogStage" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
LogStage
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
