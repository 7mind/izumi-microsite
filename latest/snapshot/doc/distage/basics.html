<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="microsite">
<meta name="generator" content="Paradox, paradox-material-theme=0.10.8-SNAPSHOT, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="microsite">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>Basics Â· Izumi Project</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Izumi Project" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Izumi Project
</span>
<span class="md-header-nav__topic">
Basics
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/7mind/izumi"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
7mind/izumi
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Izumi Project" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="../index.html" title="Izumi Project">
Izumi Project
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/7mind/izumi"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
7mind/izumi
</div>
</a>

</div>
<ul>
  <li><a href="../distage/index.html" class="page">distage: Staged Dependency Injection</a>
  <ul>
    <li><a href="../distage/basics.html" class="active page">Basics</a></li>
    <li><a href="../distage/advanced-features.html" class="page">Advanced Features</a></li>
    <li><a href="../distage/debugging.html" class="page">Debugging</a></li>
    <li><a href="../distage/distage-framework.html" class="page">distage-framework</a></li>
    <li><a href="../distage/distage-framework-docker.html" class="page">distage-framework-docker</a></li>
    <li><a href="../distage/distage-testkit.html" class="page">distage-testkit</a></li>
    <li><a href="../distage/reference.html" class="page">Syntax Summary</a></li>
  </ul></li>
  <li><a href="../logstage/index.html" class="page">LogStage</a></li>
  <li><a href="../bio/index.html" class="page">BIO</a></li>
  <li><a href="../idealingua/index.html" class="page">IdeaLingua RPC/DML</a>
  <ul>
    <li><a href="../idealingua/language-reference.html" class="page">Idealingua Language Reference</a></li>
    <li><a href="../idealingua/json.html" class="page">JSON Wire Format</a></li>
    <li><a href="../idealingua/cogen.html" class="page">Code generator reference</a></li>
    <li><a href="../idealingua/cogen-circe.html" class="page">Circe serialization reference</a></li>
  </ul></li>
  <li><a href="../sbt/index.html" class="page">SBT Toolkit</a></li>
  <li><a href="../manifesto/index.html" class="page">Productivity and challenges</a></li>
  <li><a href="../pper/index.html" class="page">PPER Pattern</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../distage/basics.html#basics" class="header">Basics</a>
  <ul>
    <li><a href="../distage/basics.html#quick-start" class="header">Quick Start</a></li>
    <li><a href="../distage/basics.html#activation-axis" class="header">Activation Axis</a></li>
    <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings, Lifecycle</a></li>
    <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
    <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
    <li><a href="../distage/basics.html#zio-has-bindings" class="header">ZIO Has Bindings</a></li>
    <li><a href="../distage/basics.html#auto-traits" class="header">Auto-Traits</a></li>
    <li><a href="../distage/basics.html#auto-factories" class="header">Auto-Factories</a></li>
    <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a></li>
    <li><a href="../distage/basics.html#cats-zio-integration" class="header">Cats &amp; ZIO Integration</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.10.8*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../distage/basics.html#basics" class="header">Basics</a>
  <ul>
    <li><a href="../distage/basics.html#quick-start" class="header">Quick Start</a></li>
    <li><a href="../distage/basics.html#activation-axis" class="header">Activation Axis</a></li>
    <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings, Lifecycle</a></li>
    <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
    <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
    <li><a href="../distage/basics.html#zio-has-bindings" class="header">ZIO Has Bindings</a></li>
    <li><a href="../distage/basics.html#auto-traits" class="header">Auto-Traits</a></li>
    <li><a href="../distage/basics.html#auto-factories" class="header">Auto-Factories</a></li>
    <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a></li>
    <li><a href="../distage/basics.html#cats-zio-integration" class="header">Cats &amp; ZIO Integration</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#basics" name="basics" class="anchor"><span class="anchor-link"></span></a>Basics</h1>
<div class="toc ">
<ul>
  <li><a href="../distage/basics.html#quick-start" class="header">Quick Start</a></li>
  <li><a href="../distage/basics.html#activation-axis" class="header">Activation Axis</a></li>
  <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings, Lifecycle</a></li>
  <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
  <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
  <li><a href="../distage/basics.html#zio-has-bindings" class="header">ZIO Has Bindings</a></li>
  <li><a href="../distage/basics.html#auto-traits" class="header">Auto-Traits</a></li>
  <li><a href="../distage/basics.html#auto-factories" class="header">Auto-Factories</a></li>
  <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a></li>
  <li><a href="../distage/basics.html#cats-zio-integration" class="header">Cats &amp; ZIO Integration</a></li>
</ul>
</div>
<h3><a href="#quick-start" name="quick-start" class="anchor"><span class="anchor-link"></span></a>Quick Start</h3>
<p>Suppose we have an abstract <code>Greeter</code> component and some other components that depend on it:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{ModuleDef, Injector, GCMode}

trait Greeter {
  def hello(name: String): Unit
}

final class PrintGreeter extends Greeter {
  override def hello(name: String) = println(s&quot;Hello $name!&quot;) 
}

trait Byer {
  def bye(name: String): Unit
}

final class PrintByer extends Byer {  
  override def bye(name: String) = println(s&quot;Bye $name!&quot;)
}

final class HelloByeApp(greeter: Greeter, byer: Byer) {
  def run(): Unit = {
    println(&quot;What&#39;s your name?&quot;)
    val name = readLine()
    
    greeter.hello(name)
    byer.bye(name)
  }
}
</code></pre>
<p>To actually run the <code>HelloByeApp</code>, we have to wire implementations of <code>Greeter</code> and <code>Byer</code> into it. We will not do it directly. First we&rsquo;ll only declare the component interfaces we have and the implementations we want for them:</p>
<pre class="prettyprint"><code class="language-scala">val HelloByeModule = new ModuleDef {
  make[Greeter].from[PrintGreeter]
  make[Byer].from[PrintByer]
  make[HelloByeApp] // `.from` is not required for concrete classes 
}
// HelloByeModule: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Byer}].from(call(Class(): repl.Session::repl.Session.App0::repl.Session.App0.PrintByer)) ((basics.md:67)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.HelloByeApp}].from(call(Class(repl.Session::repl.Session.App0::repl.Session.App0.Greeter, repl.Session::repl.Session.App0::repl.Session.App0.Byer): repl.Session::repl.Session.App0::repl.Session.App0.HelloByeApp)) ((basics.md:68)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Greeter}].from(call(Class(): repl.Session::repl.Session.App0::repl.Session.App0.PrintGreeter)) ((basics.md:66)))
</code></pre>
<p><code>ModuleDef</code> merely contains a description of the desired object graph, let&rsquo;s transform that high-level description into an actionable series of steps - an <a href="/latest/snapshot/api/izumi/distage/model/plan/OrderedPlan.html">OrderedPlan</a>, a datatype we can <a href="debugging.html#pretty-printing-plans">inspect</a>, <a href="debugging.html#testing-plans">test</a> or <a href="distage-framework.html#compile-time-checks">verify at compile-time</a> â without actually creating any objects or executing any effects.</p>
<pre class="prettyprint"><code class="language-scala">val plan = Injector().plan(HelloByeModule, GCMode.NoGC)
// plan: izumi.distage.model.plan.OrderedPlan = {type.Session::App0::Greeter} (basics.md:66) := call(Class(): Session::App0::PrintGreeter) {}
// {type.Activation} (InjectorDefaultImpl.scala:67) := value izumi.distage.model.definition.Activation#-1609326920
// {type.PlannerInput} (InjectorDefaultImpl.scala:64) := value izumi.distage.model.PlannerInput#-765236905
// {type.InjectorFactory} (InjectorDefaultImpl.scala:65) := value distage.Injector$#1765693337
// {type.BootstrapModule} (InjectorDefaultImpl.scala:66) := value izumi.distage.model.definition.BootstrapModule$$anon$1#357741729
// {type.Session::App0::Byer} (basics.md:67) := call(Class(): Session::App0::PrintByer) {}
// {type.Bootloader} (InjectorDefaultImpl.scala:68) := call(Class(BootstrapModule, Activation, PlannerInput, InjectorFactory): Bootloader) {
//   arg bootstrapModule: BootstrapModule = lookup({type.BootstrapModule})
//   arg activation: Activation = lookup({type.Activation})
//   arg input: PlannerInput = lookup({type.PlannerInput})
//   arg injectorFactory: InjectorFactory = lookup({type.InjectorFactory})
// }
// {type.Session::App0::HelloByeApp} (basics.md:68) := call(Class(Session::App0::Greeter, Session::App0::Byer): Session::App0::HelloByeApp) {
//   arg greeter: Session::App0::Greeter = lookup({type.Session::App0::Greeter})
//   arg byer: Session::App0::Byer = lookup({type.Session::App0::Byer})
// }
</code></pre>
<p>The series of steps must be executed to produce the object graph. <code>Injector.produce</code> will interpret the steps into a <a href="basics.html#resource-bindings-lifecycle">Resource</a> value, that holds the lifecycle of the object graph:</p>
<pre class="prettyprint"><code class="language-scala">// Interpret into DIResource

val resource = Injector().produce(plan)
// resource: izumi.distage.model.definition.DIResource.DIResourceBase[izumi.fundamentals.platform.functional.package.Identity, izumi.distage.model.Locator] = izumi.distage.model.definition.DIResource$$anon$11@1abb62c9

// Use the object graph:
// After `.use` exits, all objects will be deallocated,
// and all allocated resources will be freed.

resource.use {
  objects =&gt;
    objects.get[HelloByeApp].run()
}
// What&#39;s your name?
// &gt; izumi
// Hello izumi!
// Bye izumi!
// res1: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()
</code></pre>
<p><code>distage</code> always creates components exactly once, even if multiple other objects depend on them. There is only a &ldquo;Singleton&rdquo; scope. It&rsquo;s impossible to create non-singletons in <code>distage</code>. If you need multiple singleton instances of the same type, you can create <code>named</code> instances and disambiguate between them using <code>@Id</code> annotation. </p>
<pre class="prettyprint"><code class="language-scala">import distage.Id

new ModuleDef {
  make[Byer].named(&quot;byer-1&quot;).from[PrintByer]
  make[Byer].named(&quot;byer-2&quot;).from {
    otherByer: Byer @Id(&quot;byer-1&quot;) =&gt;
      new Byer {
        def bye(name: String) = otherByer.bye(s&quot;NOT-$name&quot;)
      }
  }
}
// res2: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Byer@byer-1}].from(call(Class(): repl.Session::repl.Session.App0::repl.Session.App0.PrintByer)) ((basics.md:97)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Byer@byer-2}].from(call(&lt;function1&gt;(repl.Session::repl.Session.App0::repl.Session.App0.Byer): repl.Session::repl.Session.App0::repl.Session.App0.Byer)) ((basics.md:98)))
</code></pre>
<p>You can abstract over annotations with type aliases or with string constants:</p>
<pre class="prettyprint"><code class="language-scala">object Ids {
  final val byer1Id = &quot;byer-1&quot;
  type Byer1 = Byer @Id(byer1Id)
}
</code></pre>
<p>For true non-singleton semantics, you must create explicit factory classes, or generate them (see <a href="basics.html#auto-factories">Auto-Factories</a>)</p>
<h3><a href="#activation-axis" name="activation-axis" class="anchor"><span class="anchor-link"></span></a>Activation Axis</h3>
<p>You can choose between different implementations of a component using <code>Axis</code> tags:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Axis, Activation, ModuleDef, Injector, GCMode}

class AllCapsGreeter extends Greeter {
  def hello(name: String) = println(s&quot;HELLO ${name.toUpperCase}&quot;)
}

// declare the configuration axis for our components

object Style extends Axis {
  case object AllCaps extends AxisValueDef
  case object Normal extends AxisValueDef
}

// Declare a module with several implementations of Greeter
// but in different environments

val TwoImplsModule = new ModuleDef {
  make[Greeter].tagged(Style.Normal)
    .from[PrintGreeter]
  
  make[Greeter].tagged(Style.AllCaps)
    .from[AllCapsGreeter]
}
// TwoImplsModule: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Greeter}].from(call(Class(): repl.Session::repl.Session.App0::repl.Session.App0.AllCapsGreeter)).tagged(Set(AxisTag(style:allcaps))) ((basics.md:137)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Greeter}].from(call(Class(): repl.Session::repl.Session.App0::repl.Session.App0.PrintGreeter)).tagged(Set(AxisTag(style:normal))) ((basics.md:134)))

// Combine previous `HelloByeModule` with our new module
// While overriding `make[Greeter]` bindings from the first module 

val CombinedModule = HelloByeModule overridenBy TwoImplsModule
// CombinedModule: izumi.distage.model.definition.Module = Module(make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Byer}].from(call(Class(): repl.Session::repl.Session.App0::repl.Session.App0.PrintByer)) ((basics.md:67)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.HelloByeApp}].from(call(Class(repl.Session::repl.Session.App0::repl.Session.App0.Greeter, repl.Session::repl.Session.App0::repl.Session.App0.Byer): repl.Session::repl.Session.App0::repl.Session.App0.HelloByeApp)) ((basics.md:68)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Greeter}].from(call(Class(): repl.Session::repl.Session.App0::repl.Session.App0.AllCapsGreeter)).tagged(Set(AxisTag(style:allcaps))) ((basics.md:137)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Greeter}].from(call(Class(): repl.Session::repl.Session.App0::repl.Session.App0.PrintGreeter)).tagged(Set(AxisTag(style:normal))) ((basics.md:134)))

// Choose component configuration when making an Injector:

val capsInjector = Injector(Activation(Style -&gt; Style.AllCaps))
// capsInjector: Injector = izumi.distage.InjectorDefaultImpl@6241753e

// Check the result:

capsInjector
  .produceGet[HelloByeApp](CombinedModule)
  .use(_.run())
// What&#39;s your name?
// &gt; kai
// HELLO KAI
// Bye kai!
// res3: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()

// Check that result changes with a different configuration:

Injector(Activation(Style -&gt; Style.Normal))
  .produceGet[HelloByeApp](CombinedModule)
  .use(_.run())
// What&#39;s your name?
// &gt; Pavel
// Hello Pavel!
// Bye Pavel!
// res4: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()
</code></pre>
<p><a href="/latest/snapshot/api/izumi/distage/model/definition/StandardAxis.html">distage.StandardAxis</a> contains some bundled Axis for back-end development: <code>Repo.Prod/Dummy</code>, <code>Env.Prod/Test</code> &amp; <code>ExternalApi.Prod/Mock</code> </p>
<p>In <code>distage-framework</code>&rsquo;s <a href="/latest/snapshot/api/izumi/distage/roles/RoleAppLauncher.html">RoleAppLauncher</a>, you can choose axes using the <code>-u</code> command-line parameter:</p>
<pre><code>./launcher -u repo:dummy app1
</code></pre>
<p>In <code>distage-testkit</code>, specify axes via <a href="/latest/snapshot/api/izumi/distage/testkit/TestConfig.html">TestConfig</a>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.StandardAxis.Repo
import izumi.distage.testkit.TestConfig
import izumi.distage.testkit.scalatest.DistageBIOSpecScalatest

class AxisTest extends DistageBIOSpecScalatest[zio.IO] {
  override protected def config: TestConfig = super.config.copy(
    // choose implementations tagged `Repo.Dummy` when multiple implementations with `Repo.*` tags are available
    activation = Activation(Repo -&gt; Repo.Dummy)
  )
}
</code></pre>
<h3><a href="#resource-bindings-lifecycle" name="resource-bindings-lifecycle" class="anchor"><span class="anchor-link"></span></a>Resource Bindings, Lifecycle</h3>
<p>You can specify object lifecycle by injecting <a href="https://typelevel.org/cats-effect/datatypes/resource.html">cats.effect.Resource</a>, <a href="https://zio.dev/docs/datatypes/datatypes_managed">zio.ZManaged</a> or <a href="/latest/snapshot/api/izumi/distage/model/definition/DIResource.html">distage.DIResource</a> values that specify the allocation and finalization actions for an object.</p>
<p>Injector itself only returns a DIResource value that can be used to create and finalize the object graph, this value is pure and can be reused multiple times. A DIResource is consumed using its <code>.use</code> method, the function passed to <code>use</code> will receive an allocated resource and when the function exits the resource will be deallocated. </p>
<p>Example with <code>cats.effect.Resource</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{GCMode, ModuleDef, Injector}
import cats.effect.{Bracket, Resource, IO}

class DBConnection
class MessageQueueConnection

val dbResource = Resource.make(
  acquire = IO { 
    println(&quot;Connecting to DB!&quot;)
    new DBConnection 
})(release = _ =&gt; IO(println(&quot;Disconnecting DB&quot;)))
// dbResource: Resource[IO, DBConnection] = Allocate(&lt;function1&gt;)

val mqResource = Resource.make(
  acquire = IO {
   println(&quot;Connecting to Message Queue!&quot;)
   new MessageQueueConnection 
})(release = _ =&gt; IO(println(&quot;Disconnecting Message Queue&quot;)))
// mqResource: Resource[IO, MessageQueueConnection] = Allocate(&lt;function1&gt;)

class MyApp(db: DBConnection, mq: MessageQueueConnection) {
  val run = IO(println(&quot;Hello World!&quot;))
}

val module = new ModuleDef {
  make[DBConnection].fromResource(dbResource)
  make[MessageQueueConnection].fromResource(mqResource)
  addImplicit[Bracket[IO, Throwable]]
  make[MyApp]
}
// module: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App5::repl.Session.App5.MyApp}].from(call(Class(repl.Session::repl.Session.App5::repl.Session.App5.DBConnection, repl.Session::repl.Session.App5::repl.Session.App5.MessageQueueConnection): repl.Session::repl.Session.App5::repl.Session.App5.MyApp)) ((basics.md:219)), make[{type.cats.effect.Bracket[=Î» %1:0 â IO[+1:0],=Throwable]}].from(value(cats.effect.IOLowPriorityInstances$IOEffect@1d6d0f0e: cats.effect.Bracket[=Î» %1:0 â IO[+1:0],=Throwable])) ((basics.md:218)), make[{type.repl.Session::repl.Session.App5::repl.Session.App5.DBConnection}].from(allocate[Î» %0 â cats.effect.IO[+0]](call(izumi.distage.model.reflection.Provider$ProviderImpl$$Lambda$20240/0x0000000844d32040@3fd6cea3(cats.effect.Bracket[=Î» %0 â IO[+0],=Throwable]): izumi.distage.model.definition.DIResource::izumi.distage.model.definition.DIResource.FromCats[=Î» %1:0 â IO[+1:0],=Session::App5::DBConnection]))) ((basics.md:216)), make[{type.repl.Session::repl.Session.App5::repl.Session.App5.MessageQueueConnection}].from(allocate[Î» %0 â cats.effect.IO[+0]](call(izumi.distage.model.reflection.Provider$ProviderImpl$$Lambda$20240/0x0000000844d32040@221cbefb(cats.effect.Bracket[=Î» %0 â IO[+0],=Throwable]): izumi.distage.model.definition.DIResource::izumi.distage.model.definition.DIResource.FromCats[=Î» %1:0 â IO[+1:0],=Session::App5::MessageQueueConnection]))) ((basics.md:217)))
</code></pre>
<p>Will produce the following output:</p>
<pre class="prettyprint"><code class="language-scala">import distage.DIKey

val objectGraphResource = Injector().produceF[IO](module, GCMode(root = DIKey.get[MyApp]))
// objectGraphResource: izumi.distage.model.definition.DIResource.DIResourceBase[IO, izumi.distage.model.Locator] = izumi.distage.model.definition.DIResource$$anon$11@3f042278

objectGraphResource
  .use(_.get[MyApp].run)
  .unsafeRunSync()
// Connecting to Message Queue!
// Connecting to DB!
// Hello World!
// Disconnecting DB
// Disconnecting Message Queue
</code></pre>
<p>Lifecycle management <code>DIResource</code> is also available without an effect type, via <code>DIResource.Simple</code> and <code>DIResource.Mutable</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{DIResource, GCMode, ModuleDef, Injector}

class Init {
  var initialized = false
}

class InitResource extends DIResource.Simple[Init] {
  override def acquire = {
    val init = new Init
    init.initialized = true
    init
  }
  override def release(init: Init) = {
    init.initialized = false
  }
}

val module = new ModuleDef {
  make[Init].fromResource[InitResource]
}
// module: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App7::repl.Session.App7.Init}].from(allocate[Î» %0 â 0](call(Class(): repl.Session::repl.Session.App7::repl.Session.App7.InitResource))) ((basics.md:264)))

val closedInit = Injector()
  .produceGet[Init](module)
  .use {
    init =&gt;
      println(init.initialized)
      init
}
// true
// closedInit: izumi.fundamentals.platform.functional.package.Identity[Init] = repl.Session$App7$Init@688cf374

println(closedInit.initialized)
// false
</code></pre>
<p><code>DIResource</code> forms a monad and has the expected <code>.map</code>, <code>.flatMap</code>, <code>.evalMap</code>, <code>.mapK</code> methods.</p>
<p>You can convert between <code>DIResource</code> and <code>cats.effect.Resource</code> via <code>.toCats</code>/<code>.fromCats</code> methods, and between <code>zio.ZManaged</code> via <code>.toZIO</code>/<code>.fromZIO</code>.</p>
<h3><a href="#set-bindings" name="set-bindings" class="anchor"><span class="anchor-link"></span></a>Set Bindings</h3>
<p>Set bindings are useful for implementing listeners, plugins, hooks, http routes, healthchecks, migrations, etc. Everywhere where a collection of components is required, a Set Binding is appropriate.</p>
<p>To define a Set binding use <code>.many</code> and <code>.add</code> methods of the <a href="/latest/snapshot/api/izumi/distage/model/definition/ModuleDef.html">ModuleDef</a> DSL.</p>
<p>For example, we may declare many <a href="https://http4s.org">http4s</a> routes and serve them all from a central router:</p>
<pre class="prettyprint"><code class="language-scala">import cats.implicits._
import cats.effect.{Bracket, IO, Resource}
import distage.{GCMode, ModuleDef, Injector}
import org.http4s._
import org.http4s.server.Server
import org.http4s.client.Client
import org.http4s.dsl.io._
import org.http4s.implicits._
import org.http4s.server.blaze.BlazeServerBuilder
import org.http4s.client.blaze.BlazeClientBuilder

import scala.concurrent.ExecutionContext.Implicits.global

implicit val contextShift = IO.contextShift(global)
implicit val timer = IO.timer(global)
</code></pre>
<pre class="prettyprint"><code class="language-scala">val homeRoute = HttpRoutes.of[IO] { 
  case GET -&gt; Root / &quot;home&quot; =&gt; Ok(s&quot;Home page!&quot;) 
}
// homeRoute: HttpRoutes[IO] = Kleisli(org.http4s.HttpRoutes$$$Lambda$20282/0x0000000844d5f040@2ce16fa0)

object HomeRouteModule extends ModuleDef {
  many[HttpRoutes[IO]]
    .add(homeRoute)
}
</code></pre>
<p>We&rsquo;ve used <code>many</code> method to declare an open <code>Set</code> of http routes and then added one HTTP route into it. When module definitions are combined, <code>Sets</code> for the same binding will be merged together. You can summon a Set Bindings by summoning a scala <code>Set</code>, as in <code>Set[HttpRoutes[IO]]</code>.</p>
<p>Let&rsquo;s define a new module with another route:</p>
<pre class="prettyprint"><code class="language-scala">val blogRoute = HttpRoutes.of[IO] { 
  case GET -&gt; Root / &quot;blog&quot; / post =&gt; Ok(s&quot;Blog post ``$post&#39;&#39;!&quot;) 
}
// blogRoute: HttpRoutes[IO] = Kleisli(org.http4s.HttpRoutes$$$Lambda$20282/0x0000000844d5f040@4bd9466a)

object BlogRouteModule extends ModuleDef {  
  many[HttpRoutes[IO]]
    .add(blogRoute)
}
</code></pre>
<p>Now it&rsquo;s the time to define a <code>Server</code> component to serve all the different routes we have:</p>
<pre class="prettyprint"><code class="language-scala">def makeHttp4sServer(routes: Set[HttpRoutes[IO]]): Resource[IO, Server[IO]] = {
  // create a top-level router by combining all the routes
  val router: HttpApp[IO] = routes.toList.foldK.orNotFound

  // return a Resource value that will setup an http4s server 
  BlazeServerBuilder[IO]
    .bindHttp(8080, &quot;localhost&quot;)
    .withHttpApp(router)
    .resource
}

object HttpServerModule extends ModuleDef {
  make[Server[IO]].fromResource(makeHttp4sServer _)
  make[Client[IO]].fromResource(BlazeClientBuilder[IO](global).resource)
  addImplicit[Bracket[IO, Throwable]] // required for cats `Resource` in `fromResource`
}

// join all the module definitions
val finalModule = Seq(
  HomeRouteModule,
  BlogRouteModule,
  HttpServerModule,
).merge
// finalModule: izumi.distage.model.definition.Module = Module(make[{type.org.http4s.server.Server[=Î» %1:0 â IO[+1:0]]}].from(allocate[Î» %0 â cats.effect.IO[+0]](call(izumi.distage.model.reflection.Provider$ProviderImpl$$Lambda$20240/0x0000000844d32040@15c36347(scala.collection.immutable.Set[=Kleisli[=Î» %2:0 â OptionT[=Î» %4:0 â IO[+4:0],=2:0],-Request[=Î» %3:0 â IO[+3:0]],=Response[=Î» %3:0 â IO[+3:0]]]], cats.effect.Bracket[=Î» %0 â IO[+0],=Throwable]): izumi.distage.model.definition.DIResource::izumi.distage.model.definition.DIResource.FromCats[=Î» %1:0 â IO[+1:0],=Server[=Î» %2:0 â IO[+2:0]]]))) ((basics.md:369)), many[{type.scala.collection.immutable.Set[=Kleisli[=Î» %2:0 â OptionT[=Î» %4:0 â IO[+4:0],=2:0],-Request[=Î» %3:0 â IO[+3:0]],=Response[=Î» %3:0 â IO[+3:0]]]]}].add[{type.cats.data.Kleisli[=Î» %1:0 â OptionT[=Î» %3:0 â IO[+3:0],=1:0],-Request[=Î» %2:0 â IO[+2:0]],=Response[=Î» %2:0 â IO[+2:0]]]}].from(call(izumi.distage.model.providers.ProviderMagnet$$$Lambda$18370/0x00000008445ce840@1a5b35d8(): cats.data.Kleisli[=Î» %1:0 â OptionT[=Î» %3:0 â IO[+3:0],=1:0],-Request[=Î» %2:0 â IO[+2:0]],=Response[=Î» %2:0 â IO[+2:0]]])) ((basics.md:335)), make[{type.org.http4s.client.Client[=Î» %1:0 â IO[+1:0]]}].from(allocate[Î» %0 â cats.effect.IO[+0]](call(izumi.distage.model.reflection.Provider$ProviderImpl$$Lambda$20240/0x0000000844d32040@3de0c55c(cats.effect.Bracket[=Î» %0 â IO[+0],=Throwable]): izumi.distage.model.definition.DIResource::izumi.distage.model.definition.DIResource.FromCats[=Î» %1:0 â IO[+1:0],=Client[=Î» %2:0 â IO[+2:0]]]))) ((basics.md:370)), many[{type.scala.collection.immutable.Set[=Kleisli[=Î» %2:0 â OptionT[=Î» %4:0 â IO[+4:0],=2:0],-Request[=Î» %3:0 â IO[+3:0]],=Response[=Î» %3:0 â IO[+3:0]]]]}] ((basics.md:334)), many[{type.scala.collection.immutable.Set[=Kleisli[=Î» %2:0 â OptionT[=Î» %4:0 â IO[+4:0],=2:0],-Request[=Î» %3:0 â IO[+3:0]],=Response[=Î» %3:0 â IO[+3:0]]]]}].add[{type.cats.data.Kleisli[=Î» %1:0 â OptionT[=Î» %3:0 â IO[+3:0],=1:0],-Request[=Î» %2:0 â IO[+2:0]],=Response[=Î» %2:0 â IO[+2:0]]]}].from(call(izumi.distage.model.providers.ProviderMagnet$$$Lambda$18370/0x00000008445ce840@3c0b3e9c(): cats.data.Kleisli[=Î» %1:0 â OptionT[=Î» %3:0 â IO[+3:0],=1:0],-Request[=Î» %2:0 â IO[+2:0]],=Response[=Î» %2:0 â IO[+2:0]]])) ((basics.md:349)), make[{type.cats.effect.Bracket[=Î» %1:0 â IO[+1:0],=Throwable]}].from(value(cats.effect.IOInstances$$anon$3@4dc02844: cats.effect.Bracket[=Î» %1:0 â IO[+1:0],=Throwable])) ((basics.md:371)))

// wire the graph
val objects = Injector().produceF[IO](finalModule, GCMode.NoGC).unsafeGet().unsafeRunSync()
// objects: izumi.distage.model.Locator = izumi.distage.LocatorDefaultImpl@325cbb01

val server = objects.get[Server[IO]]
// server: Server[IO] = BlazeServer(/127.0.0.1:8080)
val client = objects.get[Client[IO]]
// client: Client[IO] = org.http4s.client.Client$$anon$1@716aad67
</code></pre>
<p>Check if it works:</p>
<pre class="prettyprint"><code class="language-scala">// check home page
client.expect[String](&quot;http://localhost:8080/home&quot;).unsafeRunSync()
// res10: String = Home page!

// check blog page
client.expect[String](&quot;http://localhost:8080/blog/1&quot;).unsafeRunSync()
// res11: String = Blog post ``1&#39;&#39;!
</code></pre>
<p>Further reading: the same concept is called <a href="https://github.com/google/guice/wiki/Multibindings">Multibindings</a> in Guice.</p>
<h3><a href="#effect-bindings" name="effect-bindings" class="anchor"><span class="anchor-link"></span></a>Effect Bindings</h3>
<p>Sometimes we want to effectfully create a component, but the resulting component or data does not need to be deallocated. An example might be a global <code>Semaphore</code> to limit the parallelism of the entire application based on configuration, or a test implementation of some service made with <code>Ref</code>s.</p>
<p>In these cases we can use <code>.fromEffect</code> to create a value using an effectful constructor.</p>
<p>Example with a <code>Ref</code>-based Tagless Final <code>KVStore</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{GCMode, ModuleDef, Injector}
import izumi.functional.bio.{BIOMonadError, BIOPrimitives, F}
import zio.{Task, IO}

trait KVStore[F[_, _]] {
  def get(key: String): F[NoSuchElementException, String]
  def put(key: String, value: String): F[Nothing, Unit]
}

def dummyKVStore[F[+_, +_]: BIOMonadError: BIOPrimitives]: F[Nothing, KVStore[F]] = {
  for {
    ref &lt;- F.mkRef(Map.empty[String, String])
  } yield new KVStore[F] {
    def put(key: String, value: String): F[Nothing, Unit] = {
      ref.update_(_ + (key -&gt; value))
    }
  
    def get(key: String): F[NoSuchElementException, String] = {
      for {
        map &lt;- ref.get
        res &lt;- map.get(key) match {
          case Some(value) =&gt; F.pure(value)
          case None        =&gt; F.fail(new NoSuchElementException(key))
        }
      } yield res
    }
  }
}

val kvStoreModule = new ModuleDef {
  make[KVStore[IO]].fromEffect(dummyKVStore[IO])
}
// kvStoreModule: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App13::repl.Session.App13.KVStore[=Î» %1:0,%1:1 â ZIO[-Any,+1:0,+1:1]]}].from(effect[Î» %0 â zio.ZIO[-Any,+Nothing,+0]](value(zio.ZIO$FlatMap@6e6cc333: zio.ZIO[-Any,+Nothing,+Session::App13::KVStore[=Î» %1:0,%1:1 â ZIO[-Any,+1:0,+1:1]]]))) ((basics.md:449)))

val io = Injector()
  .produceRunF[Task, String](kvStoreModule) {
    kv: KVStore[IO] =&gt;
      for {
        _    &lt;- kv.put(&quot;apple&quot;, &quot;pie&quot;)
        res1 &lt;- kv.get(&quot;apple&quot;)
        _    &lt;- kv.put(&quot;apple&quot;, &quot;ipad&quot;)
        res2 &lt;- kv.get(&quot;apple&quot;)
      } yield res1 + res2
  }
// io: Task[String] = zio.ZIO$CheckInterrupt@5cf7cd98

zio.Runtime.default.unsafeRun(io)
// res14: String = pieipad
</code></pre>
<p>You need to use effect-aware <code>Injector.produceF</code> method to use effect bindings.</p>
<h3><a href="#zio-has-bindings" name="zio-has-bindings" class="anchor"><span class="anchor-link"></span></a>ZIO Has Bindings</h3>
<p>You can inject into ZIO Environment using <code>make[_].fromHas</code> syntax </p>
<p>zio.Has implementations are derived at compile-time by <a href="/latest/snapshot/api/izumi/distage/constructors/HasConstructor.html">HasConstructor</a> macro and can be summoned at need. </p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{DIKey, ModuleDef, Injector, ProviderMagnet, Tag}
import izumi.distage.constructors.TraitConstructor
import zio.console.{putStrLn, Console}
import zio.{UIO, URIO, ZIO, Ref, Task, Has}

trait Hello {
  def hello: UIO[String]
}
trait World {
  def world: UIO[String]
}

// Environment forwarders that allow
// using service functions from everywhere

val hello: URIO[Has[Hello], String] = ZIO.accessM(_.get.hello)
// hello: URIO[Has[Hello], String] = zio.ZIO$Read@606b9946

val world: URIO[Has[World], String] = ZIO.accessM(_.get.world)
// world: URIO[Has[World], String] = zio.ZIO$Read@48e6613f

// service implementations

val makeHello = {
  (for {
    _     &lt;- putStrLn(&quot;Creating Enterprise Hellower...&quot;)
    hello = new Hello { val hello = UIO(&quot;Hello&quot;) }
  } yield hello).toManaged { _ =&gt;
    putStrLn(&quot;Shutting down Enterprise Hellower&quot;)
  }
}
// makeHello: zio.ZManaged[Console, Nothing, AnyRef with Hello{val hello: zio.UIO[String]}] = zio.ZManaged@499671d1

val makeWorld = {
  for {
    counter &lt;- Ref.make(0)
  } yield new World {
    val world = counter.get.map(c =&gt; if (c &lt; 1) &quot;World&quot; else &quot;THE World&quot;)
  }
}
// makeWorld: ZIO[Any, Nothing, AnyRef with World{val world: zio.ZIO[Any,Nothing,String]}] = zio.ZIO$FlatMap@12c136d0

// the main function

val turboFunctionalHelloWorld: URIO[Has[Hello] with Has[World] with Has[Console.Service], Unit] = {
  for {
    hello &lt;- hello
    world &lt;- world
    _     &lt;- putStrLn(s&quot;$hello $world&quot;)
  } yield ()
}
// turboFunctionalHelloWorld: URIO[Has[Hello] with Has[World] with Has[Console.Service], Unit] = zio.ZIO$FlatMap@24484221

val definition = new ModuleDef {
  make[Hello].fromHas(makeHello)
  make[World].fromHas(makeWorld)
  make[Console.Service].fromHas(Console.live)
  make[Unit].fromHas(turboFunctionalHelloWorld)
}
// definition: AnyRef with ModuleDef = Module(make[{type.zio.console.package::zio.console.Console::zio.console.Console.Service}].from(allocate[Î» %2 â zio.ZIO[-Any,+Nothing,+2]](call(izumi.distage.model.reflection.Provider$ProviderImpl$$Lambda$20240/0x0000000844d32040@232081b2(): izumi.distage.model.definition.DIResource::izumi.distage.model.definition.DIResource.FromZIO[=Any,=Nothing,=package::Console::Service]))) ((basics.md:533)), make[{type.scala.Unit}].from(effect[Î» %2 â zio.ZIO[-Any,+Nothing,+2]](call(izumi.distage.model.reflection.Provider$ProviderImpl$$Lambda$20240/0x0000000844d32040@459f86bd(repl.Session::repl.Session.App15::repl.Session.App15.Hello, repl.Session::repl.Session.App15::repl.Session.App15.World, zio.console.package::zio.console.Console::zio.console.Console.Service): zio.ZIO[-Any,+Nothing,+Unit]))) ((basics.md:534)), make[{type.repl.Session::repl.Session.App15::repl.Session.App15.World}].from(effect[Î» %2 â zio.ZIO[-Any,+Nothing,+2]](call(izumi.distage.model.reflection.Provider$ProviderImpl$$Lambda$20240/0x0000000844d32040@706561f9(): zio.ZIO[-Any,+Nothing,+(Session::App15::World &amp; {def world(): ZIO[-Any,+Nothing,+String]})]))) ((basics.md:532)), make[{type.repl.Session::repl.Session.App15::repl.Session.App15.Hello}].from(allocate[Î» %2 â zio.ZIO[-Any,+Nothing,+2]](call(izumi.distage.model.reflection.Provider$ProviderImpl$$Lambda$20240/0x0000000844d32040@83770a(zio.console.package::zio.console.Console::zio.console.Console.Service): izumi.distage.model.definition.DIResource::izumi.distage.model.definition.DIResource.FromZIO[=Any,=Nothing,=(Session::App15::Hello &amp; {def hello(): ZIO[-Any,+Nothing,+String]})]))) ((basics.md:531)))

val main = Injector()
  .produceRunF[Task, Unit](definition)((_: Unit) =&gt; Task.unit)
// main: Task[Unit] = zio.ZIO$CheckInterrupt@225c31fa

zio.Runtime.default.unsafeRun(main)
// Creating Enterprise Hellower...
// Hello World
// Shutting down Enterprise Hellower
</code></pre>
<p>Any ZIO Service that requires an environment can be turned into a service without an environment dependency by providing the dependency in each method. This pattern can be generalized by implementing an instance of <code>cats.Contravariant</code> for your services and using it to turn environment dependencies into constructor parameters â that way ZIO Environment can be used uniformly for declaration of dependencies, but the dependencies used inside the service do not leak to other services calling it. Details: <a href="https://gitter.im/ZIO/Core?at=5dbb06a86570b076740f6db2">https://gitter.im/ZIO/Core?at=5dbb06a86570b076740f6db2</a></p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import cats.Contravariant
import distage.{GCMode, Injector, ModuleDef, ProviderMagnet, Tag, TagK, HasConstructor}
import zio.{Task, UIO, URIO, ZIO, Has}

trait Dependee[-R] {
def x(y: String): URIO[R, Int]
}
trait Depender[-R] {
def y: URIO[R, String]
}
implicit val contra1: Contravariant[Dependee] = new Contravariant[Dependee] {
  def contramap[A, B](fa: Dependee[A])(f: B =&gt; A): Dependee[B] = new Dependee[B] { def x(y: String) = fa.x(y).provideSome(f) }
}
// contra1: Contravariant[Dependee] = repl.Session$App17$$anon$12@2cabecc3
implicit val contra2: Contravariant[Depender] = new Contravariant[Depender] {
  def contramap[A, B](fa: Depender[A])(f: B =&gt; A): Depender[B] = new Depender[B] { def y = fa.y.provideSome(f) }
}
// contra2: Contravariant[Depender] = repl.Session$App17$$anon$14@378be57b

type DependeeR = Has[Dependee[Any]]
type DependerR = Has[Depender[Any]]
object dependee extends Dependee[DependeeR] { def x(y: String) = ZIO.accessM(_.get.x(y)) }
object depender extends Depender[DependerR] { def y            = ZIO.accessM(_.get.y) }

// cycle
object dependerImpl extends Depender[DependeeR] {
  def y: URIO[DependeeR, String] = dependee.x(&quot;hello&quot;).map(_.toString)
}
object dependeeImpl extends Dependee[DependerR] {
  def x(y: String): URIO[DependerR, Int] = {
    if (y == &quot;hello&quot;) UIO(5) 
    else depender.y.map(y.length + _.length)
  }
}

/** Fulfill the environment dependencies of a service from the object graph */
def fullfill[R: Tag: HasConstructor, M[_]: TagK: Contravariant](service: M[R]): ProviderMagnet[M[Any]] = {
  HasConstructor[R]
    .map(depsCakeR =&gt; Contravariant[M].contramap(service)(_ =&gt; depsCakeR))
}

val module = new ModuleDef {
  make[Depender[Any]].from(fullfill(dependerImpl))
  make[Dependee[Any]].from(fullfill(dependeeImpl))
}
// module: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App17::repl.Session.App17.Depender[-Any]}].from(call(izumi.distage.model.reflection.Provider$ProviderImpl$$Lambda$20240/0x0000000844d32040@1827a51e(repl.Session::repl.Session.App17::repl.Session.App17.Dependee[-Any]): repl.Session::repl.Session.App17::repl.Session.App17.Depender[-Any])) ((basics.md:612)), make[{type.repl.Session::repl.Session.App17::repl.Session.App17.Dependee[-Any]}].from(call(izumi.distage.model.reflection.Provider$ProviderImpl$$Lambda$20240/0x0000000844d32040@706f3b5c(repl.Session::repl.Session.App17::repl.Session.App17.Depender[-Any]): repl.Session::repl.Session.App17::repl.Session.App17.Dependee[-Any])) ((basics.md:613)))

Injector()
  .produceRunF(module) {
    HasConstructor[DependeeR].map {
      (for {
        r &lt;- dependee.x(&quot;zxc&quot;)
        _ &lt;- Task(println(s&quot;result: $r&quot;))
      } yield ()).provide(_)
    }
  }.fold(_ =&gt; 1, _ =&gt; 0)
// res18: URIO[Any, Int] = &lt;function1&gt;
</code></pre>
<h3><a href="#auto-traits" name="auto-traits" class="anchor"><span class="anchor-link"></span></a>Auto-Traits</h3>
<p>distage can instantiate traits and structural types. All unimplemented fields in a trait or a refinement are filled in from the object graph.</p>
<p>Trait implementations are derived at compile-time by <a href="/latest/snapshot/api/izumi/distage/constructors/TraitConstructor.html">TraitConstructor</a> macro and can be summoned at need. </p>
<p>If a suitable trait is specified as an implementation class for a binding, <code>TraitConstructor</code> will be used automatically:</p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{ModuleDef, Id, Injector}

trait Trait1 {
  def a: Int @Id(&quot;a&quot;)
}
trait Trait2 {
  def b: Int @Id(&quot;b&quot;)
}

/** All methods in this trait are implemented,
  * so a constructor for it will be generated
  * even though it&#39;s not a class */
trait Pluser {
  def plus(a: Int, b: Int) = a + b
}

trait PlusedInt {
  def result(): Int
}
object PlusedInt {

  /**
    * Besides the dependency on `Pluser`,
    * this class defines 2 more dependencies
    * to be injected from the object graph:
    *
    * `def a: Int @Id(&quot;a&quot;)` and
    * `def b: Int @Id(&quot;b&quot;)`
    * 
    * When an abstract type is declared as an implementation,
    * its no-argument abstract defs &amp; vals are considered as
    * dependency parameters by TraitConstructor. (empty-parens and
    * parameterized methods are not considered parameters)
    *
    * Here, using an abstract class directly as an implementation
    * lets us avoid writing a lengthier constructor, like this one:
    * 
    * {{{
    *   final class Impl(
    *     pluser: Pluser,
    *     override val a: Int @Id(&quot;a&quot;),
    *     override val b: Int @Id(&quot;b&quot;),
    *   ) extends PlusedInt with Trait1 with Trait2
    * }}}
    */
  abstract class Impl(
    pluser: Pluser
  ) extends PlusedInt
    with Trait1
    with Trait2 {
    override def result(): Int = {
      pluser.plus(a, b)
    }
  }

}

Injector()
  .produceRun(new ModuleDef {
    make[Int].named(&quot;a&quot;).from(1)
    make[Int].named(&quot;b&quot;).from(2)
    make[Pluser]
    make[PlusedInt].from[PlusedInt.Impl]
  }) {
    plusedInt: PlusedInt =&gt; 
      plusedInt.result
  }
// res20: Int = 3
</code></pre>
<p>Abstract classes or traits without obvious concrete subclasses may hinder the readability of a codebase, if you still want to use them to avoid writing the full constructor, you may use an optional <a href="/latest/snapshot/api/izumi/distage/model/definition/impl.html">@impl</a> documenting annotation to aid the reader in understanding your intention.</p>
<pre class="prettyprint"><code class="language-scala">import distage.impl

@impl abstract class Impl(
  pluser: Pluser
) extends PlusedInt
</code></pre>
<h3><a href="#auto-factories" name="auto-factories" class="anchor"><span class="anchor-link"></span></a>Auto-Factories</h3>
<p><code>distage</code> can instantiate &lsquo;factory&rsquo; classes from suitable traits. This feature is especially useful with <code>Akka</code>. All unimplemented methods <em>with parameters</em> in a trait will be filled by factory methods:</p>
<p>Given a class <code>ActorFactory</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.ModuleDef
import java.util.UUID

class SessionStorage

class UserActor(sessionId: UUID, sessionStorage: SessionStorage)

trait ActorFactory {
  // UserActor will be created as follows:
  //   sessionId argument is provided by the user
  //   sessionStorage argument is wired from the object graph
  def createActor(sessionId: UUID): UserActor
}
</code></pre>
<p>And a binding of <code>ActorFactory</code> <em>without</em> an implementation</p>
<pre class="prettyprint"><code class="language-scala">class ActorModule extends ModuleDef {
  make[ActorFactory]
}
</code></pre>
<p><code>distage</code> will derive and bind the following implementation for <code>ActorFactory</code>:</p>
<pre class="prettyprint"><code class="language-scala">class ActorFactoryImpl(sessionStorage: SessionStorage) extends ActorFactory {
  override def createActor(sessionId: UUID): UserActor = {
    new UserActor(sessionId, sessionStorage)
  }
}
</code></pre>
<p><code>@With</code> annotation can be used to specify the implementation class, to avoid leaking the implementation type in factory method result:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{ModuleDef, Injector, With}

trait Actor { 
  def receive(msg: Any): Unit
}

object Actor {
  trait Factory {
    def newActor(id: String): Actor @With[Actor.Impl]
  }

  final class Impl(id: String, config: Actor.Configuration) extends Actor {
    def receive(msg: Any) = {
      val response = s&quot;Actor `$id` received a message: $msg&quot;
      println(if (config.allCaps) response.toUpperCase else response)
    }
  }

  final case class Configuration(allCaps: Boolean)
}

val factoryModule = new ModuleDef {
  make[Actor.Factory]
  make[Actor.Configuration].from(Actor.Configuration(allCaps = false))
}
// factoryModule: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App21::repl.Session.App21.Actor::repl.Session.App21.Actor.Configuration}].from(call(izumi.distage.model.providers.ProviderMagnet$$$Lambda$18370/0x00000008445ce840@67bab86(): repl.Session::repl.Session.App21::repl.Session.App21.Actor::repl.Session.App21.Actor.Configuration)) ((basics.md:792)), make[{type.repl.Session::repl.Session.App21::repl.Session.App21.Actor::repl.Session.App21.Actor.Factory}].from(call(Factory(repl.Session::repl.Session.App21::repl.Session.App21.Actor::repl.Session.App21.Actor.Configuration): repl.Session::repl.Session.App21::repl.Session.App21.Actor::repl.Session.App21.Actor.Factory)) ((basics.md:791)))

Injector()
  .produceGet[Actor.Factory](factoryModule)
  .use(_.newActor(&quot;Martin Odersky&quot;).receive(&quot;ping&quot;))
// Actor `Martin Odersky` received a message: ping
// res22: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()
</code></pre>
<p>You can use this feature to concisely provide non-Singleton semantics for some of your components.</p>
<p>Factory implementations are derived at compile-time by <a href="/latest/snapshot/api/izumi/distage/constructors/FactoryConstructor.html">FactoryConstructor</a> macro and can be summoned at need.</p>
<h3><a href="#tagless-final-style" name="tagless-final-style" class="anchor"><span class="anchor-link"></span></a>Tagless Final Style</h3>
<p>Tagless Final is one of the popular patterns for structuring purely-functional applications. If you&rsquo;re not familiar with tagless final you can skip this section.</p>
<p>Brief introduction to tagless final:</p>
<ul>
  <li><a href="https://medium.com/@calvin.l.fer/deferring-commitments-tagless-final-704d768f15cb">Deferring Commitments: Tagless Final</a></li>
  <li><a href="https://www.beyondthelines.net/programming/introduction-to-tagless-final/">Introduction to Tagless Final</a></li>
</ul>
<p>Advantages of <code>distage</code> as a driver for TF compared to implicits:</p>
<ul>
  <li>easy explicit overrides</li>
  <li>easy <a href="basics.html#effect-bindings">effectful instantiation</a> and <a href="basics.html#resource-bindings-lifecycle">resource management</a></li>
  <li>extremely easy &amp; scalable <a href="distage-testkit.html#testkit">test</a> context setup due to the above</li>
  <li>multiple different implementations for a type using disambiguation by <code>@Id</code></li>
</ul>
<p>For example, let&rsquo;s take <a href="http://frees.io/docs/core/handlers/#tagless-interpretation">freestyle&rsquo;s tagless example</a> and make it safer and more flexible by replacing dependencies on global <code>import</code>ed implementations from with explicit modules.</p>
<p>First, the program we want to write:</p>
<pre class="prettyprint"><code class="language-scala">import cats.Monad
import cats.effect.{Sync, IO}
import cats.syntax.all._
import distage.{GCMode, Module, ModuleDef, Injector, Tag, TagK, TagKK}

trait Validation[F[_]] {
  def minSize(s: String, n: Int): F[Boolean]
  def hasNumber(s: String): F[Boolean]
}
def Validation[F[_]: Validation]: Validation[F] = implicitly

trait Interaction[F[_]] {
  def tell(msg: String): F[Unit]
  def ask(prompt: String): F[String]
}
def Interaction[F[_]: Interaction]: Interaction[F] = implicitly

class TaglessProgram[F[_]: Monad: Validation: Interaction] {
  def program: F[Unit] = for {
    userInput &lt;- Interaction[F].ask(&quot;Give me something with at least 3 chars and a number on it&quot;)
    valid     &lt;- (Validation[F].minSize(userInput, 3), Validation[F].hasNumber(userInput)).mapN(_ &amp;&amp; _)
    _         &lt;- if (valid) Interaction[F].tell(&quot;awesomesauce!&quot;)
                 else       Interaction[F].tell(s&quot;$userInput is not valid&quot;)
  } yield ()
}

def ProgramModule[F[_]: TagK: Monad] = new ModuleDef {
  make[TaglessProgram[F]]
  addImplicit[Monad[F]]
}
</code></pre>
<p><a href="/latest/snapshot/api/izumi/fundamentals/reflection/Tags/TagK.html">TagK</a> is distage&rsquo;s analogue of <code>TypeTag</code> for higher-kinded types such as <code>F[_]</code>, it allows preserving type-information at runtime for type parameters. You&rsquo;ll need to add a <a href="/latest/snapshot/api/izumi/fundamentals/reflection/Tags/TagK.html">TagK</a> context bound to create a module parameterized by an abstract <code>F[_]</code>. To parameterize by non-higher-kinded types, use just <a href="/latest/snapshot/api/izumi/fundamentals/reflection/Tags/Tag.html">Tag</a>.</p>
<p>Now the interpreters for <code>Validation</code> and <code>Interaction</code>:</p>
<pre class="prettyprint"><code class="language-scala">final class SyncValidation[F[_]](implicit F: Sync[F]) extends Validation[F] {
  def minSize(s: String, n: Int): F[Boolean] = F.delay(s.size &gt;= n)
  def hasNumber(s: String): F[Boolean]       = F.delay(s.exists(c =&gt; &quot;0123456789&quot;.contains(c)))
}
  
final class SyncInteraction[F[_]](implicit F: Sync[F]) extends Interaction[F] {
  def tell(s: String): F[Unit]  = F.delay(println(s))
  def ask(s: String): F[String] = F.delay(&quot;This could have been user input 1&quot;)
}

def SyncInterpreters[F[_]: TagK: Sync] = {
  new ModuleDef {
    make[Validation[F]].from[SyncValidation[F]]
    make[Interaction[F]].from[SyncInteraction[F]]
    addImplicit[Sync[F]]
  }
}

// combine all modules

def SyncProgram[F[_]: TagK: Sync] = ProgramModule[F] ++ SyncInterpreters[F]

// create object graph Resource

val objectsResource = Injector().produceF[IO](SyncProgram[IO], GCMode.NoGC)
// objectsResource: izumi.distage.model.definition.DIResource.DIResourceBase[IO, izumi.distage.model.Locator] = izumi.distage.model.definition.DIResource$$anon$11@751268b9

// run

objectsResource.use(_.get[TaglessProgram[IO]].program).unsafeRunSync()
// awesomesauce!
</code></pre>
<p>The program module is polymorphic over effect type. It can be instantiated by a different effect:</p>
<pre class="prettyprint"><code class="language-scala">import zio.interop.catz._
import zio.Task

val ZIOProgram = ProgramModule[Task] ++ SyncInterpreters[Task]
// ZIOProgram: Module = Module(make[{type.cats.effect.Sync[=Î» %0 â ZIO[-Any,+Throwable,+0]]}].from(value(zio.interop.CatsConcurrent@2b3e430b: cats.effect.Sync[=Î» %0 â ZIO[-Any,+Throwable,+0]])) ((basics.md:872)), make[{type.repl.Session::repl.Session.App23::repl.Session.App23.Interaction[=Î» %0 â ZIO[-Any,+Throwable,+0]]}].from(call(Class(cats.effect.Sync[=Î» %0 â ZIO[-Any,+Throwable,+0]]): repl.Session::repl.Session.App23::repl.Session.App23.SyncInteraction[=Î» %0 â ZIO[-Any,+Throwable,+0]])) ((basics.md:871)), make[{type.cats.Monad[=Î» %0 â ZIO[-Any,+Throwable,+0]]}].from(value(zio.interop.CatsConcurrent@2b3e430b: cats.Monad[=Î» %0 â ZIO[-Any,+Throwable,+0]])) ((basics.md:849)), make[{type.repl.Session::repl.Session.App23::repl.Session.App23.Validation[=Î» %0 â ZIO[-Any,+Throwable,+0]]}].from(call(Class(cats.effect.Sync[=Î» %0 â ZIO[-Any,+Throwable,+0]]): repl.Session::repl.Session.App23::repl.Session.App23.SyncValidation[=Î» %0 â ZIO[-Any,+Throwable,+0]])) ((basics.md:870)), make[{type.repl.Session::repl.Session.App23::repl.Session.App23.TaglessProgram[=Î» %0 â ZIO[-Any,+Throwable,+0]]}].from(call(Class(cats.Monad[=Î» %0 â ZIO[-Any,+Throwable,+0]], repl.Session::repl.Session.App23::repl.Session.App23.Validation[=Î» %0 â ZIO[-Any,+Throwable,+0]], repl.Session::repl.Session.App23::repl.Session.App23.Interaction[=Î» %0 â ZIO[-Any,+Throwable,+0]]): repl.Session::repl.Session.App23::repl.Session.App23.TaglessProgram[=Î» %0 â ZIO[-Any,+Throwable,+0]])) ((basics.md:848)))
</code></pre>
<p>We may even choose different interpreters at runtime:</p>
<pre class="prettyprint"><code class="language-scala">import zio.RIO
import zio.console.{Console, getStrLn, putStrLn}

object RealInteractionZIO extends Interaction[RIO[Console, ?]] {
  def tell(s: String): RIO[Console, Unit]  = putStrLn(s)
  def ask(s: String): RIO[Console, String] = putStrLn(s) *&gt; getStrLn
}

val RealInterpretersZIO = {
  SyncInterpreters[RIO[Console, ?]] overridenBy new ModuleDef {
    make[Interaction[RIO[Console, ?]]].from(RealInteractionZIO)
  }
}
// RealInterpretersZIO: Module = Module(make[{type.cats.effect.Sync[=Î» %0 â ZIO[-Has[=package::Console::Service],+Throwable,+0]]}].from(value(zio.interop.CatsConcurrent@2b3e430b: cats.effect.Sync[=Î» %0 â ZIO[-Has[=package::Console::Service],+Throwable,+0]])) ((basics.md:872)), make[{type.repl.Session::repl.Session.App23::repl.Session.App23.Interaction[=Î» %1:0 â ZIO[-Has[=package::Console::Service],+Throwable,+1:0]]}].from(call(izumi.distage.model.providers.ProviderMagnet$$$Lambda$18370/0x00000008445ce840@2eeeca06(): repl.Session::repl.Session.App23::repl.Session.App23.RealInteractionZIO)) ((basics.md:915)), make[{type.repl.Session::repl.Session.App23::repl.Session.App23.Validation[=Î» %0 â ZIO[-Has[=package::Console::Service],+Throwable,+0]]}].from(call(Class(cats.effect.Sync[=Î» %0 â ZIO[-Has[=package::Console::Service],+Throwable,+0]]): repl.Session::repl.Session.App23::repl.Session.App23.SyncValidation[=Î» %0 â ZIO[-Has[=package::Console::Service],+Throwable,+0]])) ((basics.md:870)))

def chooseInterpreters(isDummy: Boolean) = {
  val interpreters = if (isDummy) SyncInterpreters[RIO[Console, ?]]
                     else         RealInterpretersZIO
  val module = ProgramModule[RIO[Console, ?]] ++ interpreters
  Injector().produceGetF[RIO[Console, ?], TaglessProgram[RIO[Console, ?]]](module)
}

// execute

chooseInterpreters(true)
// res25: izumi.distage.model.definition.DIResource.DIResourceBase[zio.ZIO[zio.Has[Console.Service], Throwable, Î²$5$], TaglessProgram[zio.ZIO[zio.Has[Console.Service], Throwable, Î²$6$]]] = izumi.distage.model.definition.DIResource$$anon$10@1c843170
</code></pre>
<p>Modules can be polymorphic over arbitrary kinds - use <code>TagKK</code> to abstract over bifunctors:</p>
<pre class="prettyprint"><code class="language-scala">class BifunctorIOModule[F[_, _]: TagKK] extends ModuleDef
</code></pre>
<p>Or use <code>Tag.auto.T</code> to abstract over any kind:</p>
<pre class="prettyprint"><code class="language-scala">class MonadTransModule[F[_[_], _]: Tag.auto.T] extends ModuleDef
</code></pre>
<pre class="prettyprint"><code class="language-scala">class TrifunctorModule[F[_, _, _]: Tag.auto.T] extends ModuleDef
</code></pre>
<pre class="prettyprint"><code class="language-scala">class EldritchModule[F[+_, -_[_, _], _[_[_, _], _], _]: Tag.auto.T] extends ModuleDef
</code></pre>
<p>consult <a href="/latest/snapshot/api/izumi/fundamentals/reflection/WithTags.html#HKTag">HKTag</a> docs for more details.</p>
<h3><a href="#cats-zio-integration" name="cats-zio-integration" class="anchor"><span class="anchor-link"></span></a>Cats &amp; ZIO Integration</h3>
<p>Cats &amp; ZIO instances and syntax are available automatically in <code>distage-core</code>, without wildcard imports, if your project depends on <code>cats-core</code>, <code>cats-effect</code> or <code>zio</code>. But distage <em>won&rsquo;t</em> bring in <code>cats</code> or <code>zio</code> as dependencies if you don&rsquo;t already depend on them. (<a href="https://blog.7mind.io/no-more-orphans.html">No More Orphans</a> blog post details how that works)</p>
<p><a href="basics.html#resource-bindings-lifecycle">Cats Resource &amp; ZIO ZManaged Bindings</a> also work out of the box without any magic imports.</p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import cats.syntax.semigroup._
import cats.effect.{ExitCode, IO, IOApp}
import distage.{DIKey, GCMode, Injector}

trait AppEntrypoint {
  def run: IO[Unit]
}

object Main extends App {
  def run(args: List[String]): IO[ExitCode] = {
    
    // `distage.Module` has a Monoid instance

    val myModules = ProgramModule[IO] |+| SyncInterpreters[IO]

    val plan = Injector().plan(myModules, GCMode(DIKey.get[AppEntrypoint]))

    for {
      // resolveImportsF can effectfully add missing instances to an existing plan
      // (You can also create instances effectfully inside `ModuleDef` via `make[_].fromEffect` bindings)

      newPlan &lt;- plan.resolveImportsF[IO] {
        case i if i.target == DIKey.get[DBConnection] =&gt;
           DBConnection.create[IO]
      }

      // `produceF` specifies an Effect to run in.
      // Effects used in Resource and Effect Bindings 
      // should match the effect in `produceF`

      _ &lt;- Injector().produceF[IO](newPlan).use {
        classes =&gt;
          classes.get[AppEntrypoint].run
      }
    } yield ExitCode.Success
  }
}
</code></pre>
</div>
<div>
<a href="https://github.com/7mind/izumi/tree/master/doc/microsite/target/mdoc/distage/basics.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.10.8*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../distage/index.html" title="distage: Staged Dependency Injection" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
distage: Staged Dependency Injection
</span>
</div>
</a>
<a href="../distage/advanced-features.html" title="Advanced Features" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Advanced Features
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
7mind.io
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
