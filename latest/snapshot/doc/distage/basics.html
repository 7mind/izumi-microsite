<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="microsite">
<meta name="generator" content="Paradox, paradox-material-theme=0.9.5-SNAPSHOT, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="microsite">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>Basics ? Izumi Project</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Izumi Project" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Izumi Project
</span>
<span class="md-header-nav__topic">
Basics
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/7mind/izumi"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
7mind/izumi
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Izumi Project" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="../index.html" title="Izumi Project">
Izumi Project
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/7mind/izumi"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
7mind/izumi
</div>
</a>

</div>
<ul>
  <li><a href="../idealingua/index.html" class="page">IdeaLingua RPC &amp; Domain Modeling Language</a>
  <ul>
    <li><a href="../idealingua/language-reference.html" class="page">Idealingua Language Reference</a></li>
    <li><a href="../idealingua/json.html" class="page">JSON Wire Format</a></li>
    <li><a href="../idealingua/cogen.html" class="page">Code generator reference</a></li>
    <li><a href="../idealingua/cogen-circe.html" class="page">Circe serialization reference</a></li>
  </ul></li>
  <li><a href="../distage/index.html" class="page">distage: Staged Dependency Injection</a>
  <ul>
    <li><a href="../distage/basics.html" class="active page">Basics</a></li>
    <li><a href="../distage/config_injection.html" class="page">Config Injection</a></li>
    <li><a href="../distage/other-features.html" class="page">Other Features</a></li>
    <li><a href="../distage/debugging.html" class="page">Debugging</a></li>
    <li><a href="../distage/cookbook.html" class="page">Cookbook</a></li>
    <li><a href="../distage/roles.html" class="page">Role-Based Applications</a></li>
    <li><a href="../distage/testkit.html" class="page">Testkit</a></li>
    <li><a href="../distage/reference.html" class="page">Syntax Summary</a></li>
  </ul></li>
  <li><a href="../logstage/index.html" class="page">LogStage</a>
  <ul>
    <li><a href="../logstage/policy.html" class="page">Rendering policy</a></li>
    <li><a href="../logstage/config.html" class="page">Logstage Config</a></li>
    <li><a href="../logstage/custom_ctx.html" class="page">Custom Context</a></li>
  </ul></li>
  <li><a href="../sbt/index.html" class="page">SBT Toolkit</a></li>
  <li><a href="../manifesto/index.html" class="page">Productivity and challenges</a></li>
  <li><a href="../pper/index.html" class="page">PPER Pattern</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../distage/basics.html#basics" class="header">Basics</a>
  <ul>
    <li><a href="../distage/basics.html#tutorial" class="header">Tutorial</a></li>
    <li><a href="../distage/basics.html#function-bindings" class="header">Function Bindings</a></li>
    <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
    <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
    <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings &amp; Lifecycle</a></li>
    <li><a href="../distage/basics.html#injecting-implicits" class="header">Injecting Implicits</a></li>
    <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a></li>
    <li><a href="../distage/basics.html#testkit" class="header">Testkit</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.9.5*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../distage/basics.html#basics" class="header">Basics</a>
  <ul>
    <li><a href="../distage/basics.html#tutorial" class="header">Tutorial</a></li>
    <li><a href="../distage/basics.html#function-bindings" class="header">Function Bindings</a></li>
    <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
    <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
    <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings &amp; Lifecycle</a></li>
    <li><a href="../distage/basics.html#injecting-implicits" class="header">Injecting Implicits</a></li>
    <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a></li>
    <li><a href="../distage/basics.html#testkit" class="header">Testkit</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#basics" name="basics" class="anchor"><span class="anchor-link"></span></a>Basics</h1>
<div class="toc ">
<ul>
  <li><a href="../distage/basics.html#tutorial" class="header">Tutorial</a></li>
  <li><a href="../distage/basics.html#function-bindings" class="header">Function Bindings</a></li>
  <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
  <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
  <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings &amp; Lifecycle</a></li>
  <li><a href="../distage/basics.html#injecting-implicits" class="header">Injecting Implicits</a></li>
  <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a></li>
  <li><a href="../distage/basics.html#testkit" class="header">Testkit</a></li>
</ul>
</div>
<h3><a href="#tutorial" name="tutorial" class="anchor"><span class="anchor-link"></span></a>Tutorial</h3>
<p>Suppose we want to create an abstract <code>Greeter</code> component that we want to use without knowing its concrete implementation:</p>
<pre class="prettyprint"><code class="language-scala">trait Greeter {
  def hello(name: String): Unit
}
</code></pre>
<p>A simple implementation would be:</p>
<pre class="prettyprint"><code class="language-scala">final class PrintGreeter extends Greeter {
  override def hello(name: String) = println(s&quot;Hello $name!&quot;) 
}
</code></pre>
<p>Let&rsquo;s define some more components that depend on a <code>Greeter</code>:</p>
<pre class="prettyprint"><code class="language-scala">trait Byer {
  def bye(name: String): Unit
}

final class PrintByer extends Byer {  
  override def bye(name: String) = println(s&quot;Bye $name!&quot;)
}

final class HelloByeApp(greeter: Greeter, byer: Byer) {
  def run(): Unit = {
    println(&quot;What&#39;s your name?&quot;)
    val name = readLine()
    
    greeter.hello(name)
    byer.bye(name)
  }
}
</code></pre>
<p>The app above uses <code>Greeter</code> and <code>Byer</code> to hold a simple conversation with the user.</p>
<p>To actually run the app, we&rsquo;ll have to bind the real implementations of <code>Greeter</code> and <code>Byer</code>.</p>
<pre class="prettyprint"><code class="language-scala">import distage.{ModuleDef, Injector, GCMode}

object HelloByeModule extends ModuleDef {
  make[Greeter].from[PrintGreeter]
  make[Byer].from[PrintByer]
  make[HelloByeApp]
}
</code></pre>
<p>Since <code>HelloByeApp</code> is not an interface, but a <code>final class</code> that implements itself, we don&rsquo;t have to specify an implementation class for it.</p>
<p>Let&rsquo;s launch the app and see what happens:</p>
<pre class="prettyprint"><code class="language-scala">val injector = Injector()

val plan = injector.plan(HelloByeModule, GCMode.NoGC)
val objects = injector.produceUnsafe(plan)

val app = objects.get[HelloByeApp]
</code></pre>
<pre class="prettyprint"><code class="language-scala">app.run()
// What&#39;s your name?
// kai
// Hello kai!
// Bye kai!
</code></pre>
<p>Given a set of bindings, such as <code>HelloByeModule</code>, <code>distage</code> will lookup the dependencies (constructor or function arguments) of each implementation and deduce a <code>plan</code> to satisfy each dependency using the other implementations in that module. Once finished, it will happily return the <code>plan</code> back to you as a simple datatype. We can print <code>HelloByeModule</code>&rsquo;s plan while we&rsquo;re at it:</p>
<pre class="prettyprint"><code class="language-scala">println(plan.render)
// {type.Session::App0::Byer} (basics.md:62) := make[Session::App0::PrintByer] ()
// {type.Session::App0::Greeter} (basics.md:61) := make[Session::App0::PrintGreeter] ()
// {type.Session::App0::HelloByeApp} (basics.md:63) := make[Session::App0::HelloByeApp] (
//   arg greeter: Session::App0::Greeter = lookup({type.Session::App0::Greeter})
//   arg byer: Session::App0::Byer = lookup({type.Session::App0::Byer})
// )
</code></pre>
<p>Since <code>plan</code> is just a piece of data, we need to interpret it to create the actual object graph ? <code>Injector</code>&rsquo;s <code>produce</code> method is the default interpreter. <code>Injector</code> contains no logic of its own beyond interpreting instructions, its output is fully determined by the plan. This makes <a href="debugging.html#debugging">debugging</a> quite easy.</p>
<p>Given that plans are data, it&rsquo;s possible to <a href="other-features.html#compile-time-checks">verify them at compile-time</a> or <a href="other-features.html#compile-time-instantiation">splice equivalent Scala code</a> to do the instantiation before ever running the application. When used in that way, <code>distage</code> is a great alternative to compile-time frameworks such as <code>MacWire</code> all the while keeping the flexibility to interpret at runtime when needed. This flexibility in interpretation allows adding features, such as <a href="other-features.html#plugins">Plugins</a> and <a href="config_injection.html#config-injection">Typesafe Config integration</a> by transforming plans and bindings.</p>
<p>Note: classes in <code>distage</code> are always created exactly once, even if many different classes depend on them - they&rsquo;re <code>Singletons</code>. Non-singleton semantics are not available, however you can create multiple <code>named</code> instances and disambiguate between them with <code>@Id</code> annotation:</p>
<pre class="prettyprint"><code class="language-scala">import distage.Id

new ModuleDef {
  make[Byer].named(&quot;byer-1&quot;).from[PrintByer]
  make[Byer].named(&quot;byer-2&quot;).from {
    otherByer: Byer @Id(&quot;byer-1&quot;) =&gt;
      new Byer {
        def bye(name: String) = otherByer.bye(s&quot;NOT-$name&quot;)
      }
  }
}
// res3: AnyRef with ModuleDef = Set(SingletonBinding({type.repl.Session::repl.Session.App0::repl.Session.App0.Byer@byer-2},ProviderImpl({java.lang.Object &amp; repl.Session::repl.Session.App0::repl.Session.App0.Byer},&lt;function1&gt;(repl.Session::repl.Session.App0::repl.Session.App0.Byer): {java.lang.Object &amp; repl.Session::repl.Session.App0::repl.Session.App0.Byer}),Set(),(basics.md:118)), SingletonBinding({type.repl.Session::repl.Session.App0::repl.Session.App0.Byer@byer-1},TypeImpl(repl.Session::repl.Session.App0::repl.Session.App0.PrintByer),Set(),(basics.md:117)))
</code></pre>
<p>You can also create factory classes to help you mint new non-singleton instances. <a href="#auto-factories">Auto-Factories</a> can reduce boilerplate involved in doing this.</p>
<p>Modules can be combined into larger modules with <code>++</code> and <code>overridenBy</code> operators. Let&rsquo;s use <code>overridenBy</code> to greet in ALL CAPS:</p>
<pre class="prettyprint"><code class="language-scala">val caps = HelloByeModule.overridenBy(new ModuleDef {
  make[Greeter].from(new Greeter {
    override def hello(name: String) = println(s&quot;HELLO ${name.toUpperCase}&quot;)
  })
})

val capsUniverse = injector.produceUnsafe(caps, GCMode.NoGC)
</code></pre>
<pre class="prettyprint"><code class="language-scala">capsUniverse.get[HelloByeApp].run()
// What&#39;s your name?
// kai
// HELLO KAI
// Bye kai!
</code></pre>
<p>We&rsquo;ve overriden the <code>Greeter</code> binding in <code>HelloByeModule</code> with an implementation of <code>Greeter</code> that prints in ALL CAPS. For simple cases like this we can write implementations right inside the module.</p>
<h3><a href="#function-bindings" name="function-bindings" class="anchor"><span class="anchor-link"></span></a>Function Bindings</h3>
<p>To bind to a function instead of a class constructor use <code>.from</code> method in <a href="/latest/snapshot/api/com/github/pshirshov/izumi/distage/model/definition/ModuleDef.html">ModuleDef</a> DSL:</p>
<pre class="prettyprint"><code class="language-scala">import distage._

case class HostPort(host: String, port: Int)

class HttpServer(hostPort: HostPort)

object HttpServerModule extends ModuleDef {
  make[HttpServer].from {
    hostPort: HostPort =&gt;
      val modifiedPort = hostPort.port + 1000
      new HttpServer(hostPort.copy(port = modifiedPort))
  }
}
</code></pre>
<p>To inject named instances or <a href="config_injection.html#config-injection">config values</a>, add annotations such as <code>@Id</code> and <code>@ConfPath</code> to lambda arguments&rsquo; types:</p>
<pre class="prettyprint"><code class="language-scala">import distage.config._

object HostPortModule extends ModuleDef {
  make[HostPort].named(&quot;default&quot;).from(HostPort(&quot;localhost&quot;, 8080))
  make[HostPort].from {
    (maybeConfigHostPort: Option[HostPort] @ConfPath(&quot;http&quot;),
     defaultHostPort: HostPort @Id(&quot;default&quot;)) =&gt;
      maybeConfigHostPort.getOrElse(defaultHostPort)
  }
}
</code></pre>
<p>Given a <code>Locator</code> we can retrieve instances by type, call methods on them or summon them with a function:</p>
<pre class="prettyprint"><code class="language-scala">import scala.util.Random

val objects = Injector().produceUnsafe(HelloByeModule, GCMode.NoGC)
// objects: Locator = izumi.distage.LocatorDefaultImpl@248d8d6d

objects.run {
  (hello: Hello, bye: Bye) =&gt;
    val names = Array(&quot;Snow&quot;, &quot;Marisa&quot;, &quot;Shelby&quot;)
    val rnd = Random.nextInt(3)
    println(s&quot;Random index: $rnd&quot;)
    hello(names(rnd))
    bye(names(rnd))
}
// Random index: 2
// Hello Shelby
// Bye Shelby
</code></pre>
<pre class="prettyprint"><code class="language-scala">objects.runOption { i: Int =&gt; i + 10 } match {
  case None =&gt; println(&quot;There is no Int in the object graph!&quot;)
  case Some(i) =&gt; println(s&quot;Int is $i&quot;)
}
// There is no Int in the object graph!
</code></pre>
<p>consult <a href="/latest/snapshot/api/com/github/pshirshov/izumi/distage/model/providers/ProviderMagnet.html">ProviderMagnet</a> docs for more details.</p>
<h3><a href="#set-bindings" name="set-bindings" class="anchor"><span class="anchor-link"></span></a>Set Bindings</h3>
<p>Set bindings are useful for implementing event listeners, plugins, hooks, http routes, healthchecks, migrations, etc. Everywhere where you need to gather up a bunch of similar components is probably a good place for a Set Binding.</p>
<p>To define a Set binding use <code>.many</code> and <code>.add</code> methods in <a href="/latest/snapshot/api/com/github/pshirshov/izumi/distage/model/definition/ModuleDef.html">ModuleDef</a> DSL.</p>
<p>For example, we can gather and serve all the different <a href="https://http4s.org">http4s</a> routes added in multiple independent modules:</p>
<pre class="prettyprint"><code class="language-scala">// boilerplate
import cats.implicits._
import cats.effect._
import distage._
import org.http4s._
import org.http4s.Uri.uri
import org.http4s.dsl.io._
import org.http4s.implicits._
import org.http4s.server.blaze._

import scala.concurrent.ExecutionContext.Implicits.global

implicit val contextShift = IO.contextShift(global)
implicit val timer = IO.timer(global)
</code></pre>
<pre class="prettyprint"><code class="language-scala">object HomeRouteModule extends ModuleDef {

  val homeRoute = HttpRoutes.of[IO] { 
    case GET -&gt; Root / &quot;home&quot; =&gt; Ok(s&quot;Home page!&quot;) 
  }

  many[HttpRoutes[IO]]
    .add(homeRoute)
}
</code></pre>
<p>We&rsquo;ve used <code>many</code> method to declare an open <code>Set</code> of http routes and then added one HTTP route into it. When module definitions are combined, <code>Sets</code> for the same binding will be merged together. You can summon a Set Bindings by summoning a scala <code>Set</code>, as in <code>Set[HttpRoutes[IO]]</code>.</p>
<p>Let&rsquo;s define a new module with another route:</p>
<pre class="prettyprint"><code class="language-scala">object BlogRouteModule extends ModuleDef {

  val blogRoute = HttpRoutes.of[IO] { 
    case GET -&gt; Root / &quot;blog&quot; / post =&gt; Ok(s&quot;Blog post ``$post&#39;&#39;!&quot;) 
  }
  
  many[HttpRoutes[IO]]
    .add(blogRoute)
}
</code></pre>
<p>Now it&rsquo;s the time to define a <code>Server</code> component to serve all the different routes we have:</p>
<pre class="prettyprint"><code class="language-scala">final class HttpServer(routes: Set[HttpRoutes[IO]]) {
  
  val router: HttpApp[IO] = 
    routes.toList.foldK.orNotFound

  val serverResource = 
    BlazeServerBuilder[IO]
      .bindHttp(8080, &quot;localhost&quot;)
      .withHttpApp(router)
      .resource
}

object HttpServerModule extends ModuleDef {
  make[HttpServer]
}
</code></pre>
<p>Now, let&rsquo;s wire all the modules and create the server!</p>
<pre class="prettyprint"><code class="language-scala">val finalModule = Seq(
    HomeRouteModule,
    BlogRouteModule,
    HttpServerModule,
  ).merge

val objects = Injector().produceUnsafe(finalModule, GCMode.NoGC)

val server = objects.get[HttpServer]
</code></pre>
<p>Let&rsquo;s check if it works:</p>
<pre class="prettyprint"><code class="language-scala">server.router.run(Request(uri = uri(&quot;/home&quot;)))
  .flatMap(_.as[String]).unsafeRunSync
// res10: String = &quot;Home page!&quot;
</code></pre>
<pre class="prettyprint"><code class="language-scala">server.router.run(Request(uri = uri(&quot;/blog/1&quot;)))
  .flatMap(_.as[String]).unsafeRunSync
// res11: String = &quot;Blog post ``1&#39;&#39;!&quot;
</code></pre>
<p>Fantastic!</p>
<p>See also, same concept in <a href="https://github.com/google/guice/wiki/Multibindings">Guice</a>.</p>
<h3><a href="#effect-bindings" name="effect-bindings" class="anchor"><span class="anchor-link"></span></a>Effect Bindings</h3>
<p>Sometimes we need to effectfully create a component or fetch some data and inject it into the object graph during startup (e.g. read a configuration file), but the resulting component or data does not need to be closed. An example might be a global <code>Semaphore</code> that limits the parallelism of an entire application based on configuration value or a <code>dummy</code>/<code>test double</code> implementation of some external service made for testing using simple <code>Ref</code>s.</p>
<p>In these cases we can use <code>.fromEffect</code> to simply bind a value created effectfully.</p>
<p>Example with <code>ZIO</code> <code>Semaphore</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage._
import distage.config._
import zio._

case class Content(bytes: Array[Byte])

case class UploadConfig(maxParallelUploads: Long)

class UploaderModule extends ModuleDef {
  make[Semaphore].named(&quot;upload-limit&quot;).fromEffect {
    conf: UploadConfig @ConfPath(&quot;myapp.uploads&quot;) =&gt;
      Semaphore.make(conf.maxParallelUploads)
  }
  
  make[Uploader]
}

class Uploader(limit: Semaphore @Id(&quot;upload-limit&quot;)) {
  def upload(content: Content): IO[Throwable, Unit] =
    limit.withPermit(upload(content))
}
</code></pre>
<p>Example with a <code>Dummy</code> <code>KVStore</code>:</p>
<pre class="prettyprint"><code class="language-scala">trait KVStore[F[_, _]] {
  def put(key: String, value: String): F[Nothing, Unit]
  def get(key: String): F[NoSuchElementException, String]
}

object KVStore {
  def dummy: IO[Nothing, KVStore[IO]] = for {
    ref &lt;- Ref.make(Map.empty[String, String])
    kvStore = new KVStore[IO] {
      def put(key: String, value: String): IO[Nothing, Unit] =
        ref.update(_ + (key -&gt; value)).unit
      
      def get(key: String): IO[NoSuchElementException, String] = 
        for {
          map &lt;- ref.get
          maybeValue = map.get(key)
          res &lt;- maybeValue match {
            case None =&gt; 
              IO.fail(new NoSuchElementException(key))
            case Some(value) =&gt; 
              IO.succeed(value)
          }
        } yield res
    }
  } yield kvStore
}

val kvStoreModule = new ModuleDef {
  make[KVStore[IO]].fromEffect(KVStore.dummy)
}
// kvStoreModule: AnyRef with ModuleDef = Set(SingletonBinding({type.repl.Session::repl.Session.App12::repl.Session.App12.KVStore[=? %0,%1 ? ZIO[-Any,+0,+1]]},EffectImpl(repl.Session::repl.Session.App12::repl.Session.App12.KVStore[=? %0,%1 ? ZIO[-Any,+0,+1]],? %0 ? zio.ZIO[-Any,+Nothing,+0],InstanceImpl(zio.ZIO[-Any,+Nothing,+Session::App12::KVStore[=? %0,%1 ? ZIO[-Any,+0,+1]]],zio.ZIO$FlatMap@7419d963)),Set(),(basics.md:438)))

new DefaultRuntime{}.unsafeRun {
  Injector().produceF[IO[Throwable, ?]](kvStoreModule, GCMode.NoGC)
    .use {
      objects =&gt;
        val kv = objects.get[KVStore[IO]]
        
        for {
          _ &lt;- kv.put(&quot;apple&quot;, &quot;pie&quot;)
          res &lt;- kv.get(&quot;apple&quot;)
        } yield res
    }
}
// res13: String = &quot;pie&quot;
</code></pre>
<p>You need to use effect-aware <code>Injector.produceF</code>/<code>Injector.produceUnsafeF</code> methods to use effect bindings.</p>
<h3><a href="#resource-bindings-lifecycle" name="resource-bindings-lifecycle" class="anchor"><span class="anchor-link"></span></a>Resource Bindings &amp; Lifecycle</h3>
<p>Lifecycle is supported via Resource bindings. You can inject any <a href="https://typelevel.org/cats-effect/datatypes/resource.html">cats.effect.Resource</a> into the object graph. You can also inject <a href="/latest/snapshot/api/com/github/pshirshov/izumi/distage/model/definition/DIResource.html">DIResource</a> classes. Global resources will be deallocated when the app or the test ends.</p>
<p>Note that lifecycle control via <code>DIResource</code> is available in non-FP applications as well via inheritance from <code>DIResource.Simple</code> and <code>DIResource.Mutable</code>.</p>
<p>Example with <code>cats</code> Resource:</p>
<pre class="prettyprint"><code class="language-scala">import distage._
import cats.effect._

class DBConnection
class MessageQueueConnection

val dbResource = Resource.make(
  acquire = IO { println(&quot;Connecting to DB!&quot;); new DBConnection }
)(release = _ =&gt; IO(println(&quot;Disconnecting DB&quot;)))
// dbResource: Resource[IO, DBConnection] = Allocate(
//   Map(
//     Delay(&lt;function0&gt;),
//     scala.Function1$$Lambda$19479/0x0000000843153840@3ed20bb4,
//     1
//   )
// )

val mqResource = Resource.make(
  acquire = IO { println(&quot;Connecting to Message Queue!&quot;); new MessageQueueConnection }
)(release = _ =&gt; IO(println(&quot;Disconnecting Message Queue&quot;)))
// mqResource: Resource[IO, MessageQueueConnection] = Allocate(
//   Map(
//     Delay(&lt;function0&gt;),
//     scala.Function1$$Lambda$19479/0x0000000843153840@165fb559,
//     1
//   )
// )

class MyApp(db: DBConnection, mq: MessageQueueConnection) {
  val run = IO(println(&quot;Hello World!&quot;))
}

def module = new ModuleDef {
  make[DBConnection].fromResource(dbResource)
  make[MessageQueueConnection].fromResource(mqResource)
  addImplicit[Bracket[IO, Throwable]]
  make[MyApp]
}
</code></pre>
<p>Will produce the following output:</p>
<pre class="prettyprint"><code class="language-scala">Injector().produceF[IO](module, GCMode.NoGC).use {
  objects =&gt;
    objects.get[MyApp].run
}.unsafeRunSync()
// Connecting to DB!
// Connecting to Message Queue!
// Hello World!
// Disconnecting Message Queue
// Disconnecting DB
</code></pre>
<p>Example with <code>DIResource.Simple</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage._

class Init {
  var initialized = false
}

class InitResource extends DIResource.Simple[Init] {
  override def acquire = {
    val init = new Init
    init.initialized = true
    init
  }
  override def release(init: Init) = {
    init.initialized = false
  }
}

val module = new ModuleDef {
  make[Init].fromResource[InitResource]
}
// module: AnyRef with ModuleDef = Set(SingletonBinding({type.repl.Session::repl.Session.App16::repl.Session.App16.Init},ResourceImpl(repl.Session::repl.Session.App16::repl.Session.App16.Init,? %0 ? 0,TypeImpl(repl.Session::repl.Session.App16::repl.Session.App16.InitResource)),Set(),(basics.md:554)))
</code></pre>
<pre class="prettyprint"><code class="language-scala">val closedInit = Injector().produce(module, GCMode.NoGC).use {
  objects =&gt;
    val init = objects.get[Init] 
    println(init.initialized)
    init
}
// true
// closedInit: izumi.fundamentals.platform.functional.package.Identity[Init] = repl.Session$App16$Init@4e0f3372
println(closedInit.initialized)
// false
</code></pre>
<p><code>DIResource</code> forms a monad and has the expected <code>.map</code>, <code>.flatMap</code>, <code>.evalMap</code> methods available. You can convert a <code>DIResource</code> into a <code>cats.effect.Resource</code> via <code>.toCats</code> method.</p>
<p>You need to use resource-aware <code>Injector.produce</code>/<code>Injector.produceF</code> methods to control lifecycle of the object graph.</p>
<h3><a href="#injecting-implicits" name="injecting-implicits" class="anchor"><span class="anchor-link"></span></a>Injecting Implicits</h3><div class="callout warning "><div class="callout-title">TODO</div>
<p>Sorry, this page is not ready yet</p>
<p>Relevant ticket: <a href="https://github.com/7mind/izumi/issues/230">https://github.com/7mind/izumi/issues/230</a></p></div>
<p>Implicits are managed like any other class. To make them available for summoning, declare them in a module:</p>
<pre class="prettyprint"><code class="language-scala">import cats.Monad
import distage._
import zio.IO
import zio.interop.catz._

object IOMonad extends ModuleDef {
  addImplicit[Monad[IO[Throwable, ?]]]
  // same as make[Monad[IO[Throwable, ?]]].from(implicitly[Monad[IO[Throwable, ?]]])
}
</code></pre>
<p>Implicits for managed classes are injected from the object graph, NOT from the surrounding lexical scope. If they were captured from lexical scope inside <code>ModuleDef</code>, then classes would effectively depend on specific <em>implementations</em> of implicits available in scope at <code>ModuleDef</code> definition point. Depending on implementations is unmodular! We want to late-bind implicit dependencies same as any other dependencies, therefore you must specify implementations for implicits in <code>ModuleDef</code>.</p>
<pre class="prettyprint"><code class="language-scala">import cats._
import distage._

trait KVStore[F[_]] {
  def fetch(key: String): F[String]
}

final class KVStoreEitherImpl(implicit F: MonadError[Either[Error, ?], Error]) extends KVStore[Either[Error, ?]] {
  def fetch(key: String) = F.raiseError(new Error(s&quot;no value for key $key!&quot;))
}

val kvstoreModuleBad = new ModuleDef {
  // We DON&#39;T want this import to be necessary here
  // import cats.instances.either._

  make[KVStore[Either[Error, ?]]].from[KVStoreEitherImpl]
}

// Instead, wire implicits explicitly
val kvstoreModuleGood = new ModuleDef {

  make[KVStore[Either[Error, ?]]].from[KVStoreEitherImpl]
  
  // Ok to import here
  import cats.instances.either._
  
  // add the implicit dependency into the object graph
  addImplicit[MonadError[Either[Error, ?], Error]]
  
}
</code></pre>
<p>Implicits obey the usual lexical scope in user code.</p>
<p>You can participate in this ticket at <a href="https://github.com/7mind/izumi/issues/230">https://github.com/7mind/izumi/issues/230</a></p>
<h3><a href="#tagless-final-style" name="tagless-final-style" class="anchor"><span class="anchor-link"></span></a>Tagless Final Style</h3>
<p>Tagless Final is one of the popular patterns for structuring purely-functional applications. If you&rsquo;re not familiar with tagless final you can skip this section.</p>
<p>Brief introduction to tagless final:</p>
<ul>
  <li><a href="https://medium.com/@calvin.l.fer/deferring-commitments-tagless-final-704d768f15cb">Deferring Commitments: Tagless Final</a></li>
  <li><a href="https://www.beyondthelines.net/programming/introduction-to-tagless-final/">Introduction to Tagless Final</a></li>
</ul>
<p>Advantages of <code>distage</code> as a driver for TF compared to implicits:</p>
<ul>
  <li>easy explicit overrides</li>
  <li>easy <a href="basics.html#effect-bindings">effectful instantiation</a> and <a href="basics.html#resource-bindings-lifecycle">resource management</a></li>
  <li>extremely easy &amp; scalable <a href="#testkit">test</a> context setup due to the above</li>
  <li>multiple different implementations via <code>@Id</code> annotation</li>
</ul>
<p>As an example, let&rsquo;s take <a href="http://frees.io/docs/core/handlers/#tagless-interpretation">freestyle&rsquo;s tagless example</a> and make it safer and more flexible by replacing dependencies on global <code>import</code>ed implementations from with explicit modules.</p>
<p>First, the program we want to write:</p>
<pre class="prettyprint"><code class="language-scala">import cats._
import cats.implicits._
import distage._

trait Validation[F[_]] {
  def minSize(s: String, n: Int): F[Boolean]
  def hasNumber(s: String): F[Boolean]
}
def Validation[F[_]: Validation]: Validation[F] = implicitly

trait Interaction[F[_]] {
  def tell(msg: String): F[Unit]
  def ask(prompt: String): F[String]
}
def Interaction[F[_]: Interaction]: Interaction[F] = implicitly

class TaglessProgram[F[_]: Monad: Validation: Interaction] {
  def program: F[Unit] = for {
    userInput &lt;- Interaction[F].ask(&quot;Give me something with at least 3 chars and a number on it&quot;)
    valid     &lt;- (Validation[F].minSize(userInput, 3), Validation[F].hasNumber(userInput)).mapN(_ &amp;&amp; _)
    _         &lt;- if (valid) 
                    Interaction[F].tell(&quot;awesomesauce!&quot;)
                 else 
                    Interaction[F].tell(s&quot;$userInput is not valid&quot;)
  } yield ()
}

class Program[F[_]: TagK: Monad] extends ModuleDef {
  make[TaglessProgram[F]]

  addImplicit[Monad[F]]
}
</code></pre>
<p><a href="/latest/snapshot/api/com/github/pshirshov/izumi/fundamentals/reflection/WithTags.html#TagK">TagK</a> is distage&rsquo;s analogue of <code>TypeTag</code> for higher-kinded types such as <code>F[_]</code>, it allows preserving type-information at runtime for types that aren&rsquo;t yet known at definition. You&rsquo;ll need to add a <a href="/latest/snapshot/api/com/github/pshirshov/izumi/fundamentals/reflection/WithTags.html#TagK">TagK</a> context bound to create a module parameterized by an abstract <code>F[_]</code>. Use <a href="/latest/snapshot/api/com/github/pshirshov/izumi/fundamentals/reflection/WithTags.html#Tag">Tag</a> to create modules parameterized by non-higher-kinded types.</p>
<p>Interpreters:</p>
<pre class="prettyprint"><code class="language-scala">import scala.util.Try
import cats.instances.all._

def tryValidation = new Validation[Try] {
  def minSize(s: String, n: Int): Try[Boolean] = Try(s.size &gt;= n)
  def hasNumber(s: String): Try[Boolean] = Try(s.exists(c =&gt; &quot;0123456789&quot;.contains(c)))
}
  
def tryInteraction = new Interaction[Try] {
  def tell(s: String): Try[Unit] = Try(println(s))
  def ask(s: String): Try[String] = Try(&quot;This could have been user input 1&quot;)
}

object TryInterpreters extends ModuleDef {
  make[Validation[Try]].from(tryValidation)
  make[Interaction[Try]].from(tryInteraction)
}

// combine all modules
val TryProgram = new Program[Try] ++ TryInterpreters
// TryProgram: Module = Set(SingletonBinding({type.repl.Session::repl.Session.App18::repl.Session.App18.TaglessProgram[=? %0 ? Try[+0]]},ProviderImpl(repl.Session::repl.Session.App18::repl.Session.App18.TaglessProgram[=? %0 ? Try[+0]],&lt;function1&gt;(cats.Monad[=? %0 ? Try[+0]], repl.Session::repl.Session.App18::repl.Session.App18.Validation[=? %0 ? Try[+0]], repl.Session::repl.Session.App18::repl.Session.App18.Interaction[=? %0 ? Try[+0]]): repl.Session::repl.Session.App18::repl.Session.App18.TaglessProgram[=? %0 ? Try[+0]]),Set(),(basics.md:636)), SingletonBinding({type.cats.Monad[=? %0 ? Try[+0]]},InstanceImpl(cats.Monad[=? %0 ? Try[+0]],cats.instances.TryInstances$$anon$1@7e6221d1),Set(),(basics.md:638)), SingletonBinding({type.repl.Session::repl.Session.App18::repl.Session.App18.Validation[=? %0 ? Try[+0]]},ProviderImpl({java.lang.Object &amp; repl.Session::repl.Session.App18::repl.Session.App18.Validation[=? %0 ? Try[+0]]},izumi.distage.model.providers.ProviderMagnet$$$Lambda$18974/0x0000000843616040@40c18604(): {java.lang.Object &amp; repl.Session::repl.Session.App18::repl.Session.App18.Validation[=? %0 ? Try[+0]]}),Set(),(basics.md:670)), SingletonBinding({type.repl.Session::repl.Session.App18::repl.Session.App18.Interaction[=? %0 ? Try[+0]]},ProviderImpl({java.lang.Object &amp; repl.Session::repl.Session.App18::repl.Session.App18.Interaction[=? %0 ? Try[+0]]},izumi.distage.model.providers.ProviderMagnet$$$Lambda$18974/0x0000000843616040@7014b43b(): {java.lang.Object &amp; repl.Session::repl.Session.App18::repl.Session.App18.Interaction[=? %0 ? Try[+0]]}),Set(),(basics.md:671)))

// create object graph
val objects = Injector().produceUnsafe(TryProgram, GCMode.NoGC)
// objects: Locator = izumi.distage.LocatorDefaultImpl@1bef8984

// run
objects.get[TaglessProgram[Try]].program
// awesomesauce!
// res19: Try[Unit] = Success(())
</code></pre>
<p>The program module is polymorphic over its eventual monad, we can easily parameterize it with a different monad:</p>
<pre class="prettyprint"><code class="language-scala">import cats.effect._

def SyncInterpreters[F[_]: TagK](implicit F: Sync[F]) = new ModuleDef {
  make[Validation[F]].from(new Validation[F] {
    def minSize(s: String, n: Int): F[Boolean] = F.delay(s.size &gt;= n)
    def hasNumber(s: String): F[Boolean] = F.delay(s.exists(c =&gt; &quot;0123456789&quot;.contains(c)))
  })
  make[Interaction[F]].from(new Interaction[F] {
    def tell(s: String): F[Unit] = F.delay(println(s))
    def ask(s: String): F[String] = F.delay(&quot;This could have been user input 1&quot;)
  })
}

def IOProgram = new Program[IO] ++ SyncInterpreters[IO]
</code></pre>
<p>We can leave it completely polymorphic as well:</p>
<pre class="prettyprint"><code class="language-scala">def SyncProgram[F[_]: TagK: Sync] = new Program[F] ++ SyncInterpreters[F]
</code></pre>
<p>Or choose different interpreters at runtime:</p>
<pre class="prettyprint"><code class="language-scala">def DifferentTryInterpreters = ???
def chooseInterpreters(default: Boolean) = {
  val interpreters = if (default) TryInterpreters else DifferentTryInterpreters
  new Program[Try] ++ interpreters
}
</code></pre>
<p>Modules can be polymorphic over arbitrary kinds - use <code>TagKK</code> to abstract over bifunctors:</p>
<pre class="prettyprint"><code class="language-scala">class BifunctorIOModule[F[_, _]: TagKK] extends ModuleDef
</code></pre>
<p>Or use <code>Tag.auto.T</code> to abstract over any kind:</p>
<pre class="prettyprint"><code class="language-scala">class MonadTransModule[F[_[_], _]: Tag.auto.T] extends ModuleDef
</code></pre>
<pre class="prettyprint"><code class="language-scala">class TrifunctorModule[F[_, _, _]: Tag.auto.T] extends ModuleDef
</code></pre>
<pre class="prettyprint"><code class="language-scala">class EldritchModule[F[+_, -_[_, _], _[_[_, _], _], _]: Tag.auto.T] extends ModuleDef
</code></pre>
<p>consult <a href="/latest/snapshot/api/com/github/pshirshov/izumi/fundamentals/reflection/WithTags.html#HKTag">HKTag</a> docs for more details.</p>
<h3><a href="#testkit" name="testkit" class="anchor"><span class="anchor-link"></span></a>Testkit</h3>
<p><code>distage-testkit</code> module provides integration with <code>scalatest</code>:</p>
<pre class="prettyprint"><code class="language-scala">libraryDependencies += Izumi.R.distage_testkit
</code></pre>
<p>or</p>
<pre class="prettyprint"><code class="language-scala">libraryDependencies += &quot;io.7mind.izumi&quot; %% &quot;distage-plugins&quot; % &quot;0.9.5-SNAPSHOT&quot;
</code></pre>
<p>If you&rsquo;re not using <a href="../sbt/index.html#bills-of-materials">sbt-izumi-deps</a> plugin.</p>
<p>Example usage:</p>
<p>```scala</p>
<p>```</p>
</div>
<div>
<a href="https://github.com/7mind/izumi/tree/master/doc/microsite/target/mdoc/distage/basics.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.9.5*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../distage/index.html" title="distage: Staged Dependency Injection" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
distage: Staged Dependency Injection
</span>
</div>
</a>
<a href="../distage/config_injection.html" title="Config Injection" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Config Injection
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
7mind.io
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
