{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Izumi Project"},{"location":"/index.html#izumi-project","text":"Izumi (jap. ??, spring) is a set of independent libraries and frameworks allowing you to significantly increase productivity of your Scala development.\nincluding the following components:\ndistage ? Staged, transparent and debuggable runtime & compile-time Dependency Injection Framework, logstage ? Automatic structural logs from Scala string interpolations, idealingua ? API Definition, Data Modeling and RPC Language, optimized for fast prototyping ? like gRPC, but with a human face. Currently generates servers and clients for Go, TypeScript, C# and Scala, Opinionated SBT plugins ? Reduces verbosity of SBT builds and introduces new features ? inter-project shared test scopes and BOM plugins (from Maven), Percept-Plan-Execute-Repeat (PPER) ? a pattern that enables modeling very complex domains and orchestrate deadly complex processes a lot easier than you’re used to.","title":"Izumi Project"},{"location":"/index.html#dependencies","text":"To use, add the following into project/build.sbt,\nlibraryDependencies ++= Seq(\n  // Core DIStage library\n  \"io.7mind.izumi\" %% \"distage-core\" % \"0.9.10-SNAPSHOT\",\n  // Testkit for ScalaTest\n  \"io.7mind.izumi\" %% \"distage-testkit\" % \"0.9.10-SNAPSHOT\" % Test,\n  // Typesafe Config support\n  \"io.7mind.izumi\" %% \"distage-config\" % \"0.9.10-SNAPSHOT\",\n  // Classpath discovery support\n  \"io.7mind.izumi\" %% \"distage-plugins\" % \"0.9.10-SNAPSHOT\",\n  // Roles & Application entrypoint framework\n  \"io.7mind.izumi\" %% \"distage-roles\" % \"0.9.10-SNAPSHOT\",\n  \n  // Core LogStage library\n  \"io.7mind.izumi\" %% \"logstage-core\" % \"0.9.10-SNAPSHOT\",\n  // Configure LogStage with Typesafe Config\n  \"io.7mind.izumi\" %% \"logstage-config\" % \"0.9.10-SNAPSHOT\",\n  // LogStage integration with DIStage\n  \"io.7mind.izumi\" %% \"logstage-di\" % \"0.9.10-SNAPSHOT\",\n  // Write logs as JSON\n  \"io.7mind.izumi\" %% \"logstage-rendering-circe \" % \"0.9.10-SNAPSHOT\",\n  // Route Slf4J logs to LogStage\n  \"io.7mind.izumi\" %% \"logstage-adapter-slf4j \" % \"0.9.10-SNAPSHOT\",\n  // Route LogStage logs to Slf4J\n  \"io.7mind.izumi\" %% \"logstage-sink-slf4j \" % \"0.9.10-SNAPSHOT\",\n  \n  // Idealingua Runtime Dependencies (for use with the Idealingua compiler)\n  \"io.7mind.izumi\" %% \"idealingua-v1-runtime-rpc-http4s\" % \"0.9.10-SNAPSHOT\",\n)\nScaladoc\nIzumi on GitHub\nLatest SNAPSHOT documentation","title":"Dependencies"},{"location":"/index.html#credits","text":"YourKit supports open source projects with innovative and intelligent tools for monitoring and profiling Java and .NET applications. YourKit is the creator of YourKit Java Profiler YourKit .NET Profiler and YourKit YouMonitor.","title":"Credits"},{"location":"/idealingua/index.html","text":"","title":"IdeaLingua RPC & Domain Modeling Language ? Izumi Project"},{"location":"/idealingua/index.html#idealingua-rpc-domain-modeling-language","text":"IdeaLingua is an RPC framework & Domain Modeling Language, it’s purpose is to:\nShare & publish APIs and data models in a common concise format Allow remote calls to services given their public API definitions. Create idiomatic API clients and servers for all programming languages ? currently Scala, TypeScript, C# & Go. Support frontend-to-backend and backend-to-frontend calls (ala push notifications, via buzzer definitions) Abstract away details such as the network protocol or the serialization format. Save developers from untyped and brittle REST.","title":"IdeaLingua RPC & Domain Modeling Language"},{"location":"/idealingua/index.html#user-service-example","text":"package user.api\n\nenum Gender = Male | Female\n\nid EntityID {\n  uuid: uuid\n}\n\nmixin Entity {\n  id: EntityID\n}\n\nmixin Person {\n  name: str\n  surname: str\n  gender: Gender\n}\n\ndata User {\n  & Entity\n  + Person\n  password: str\n}\n\ndata PublicUser {\n  + User\n  - password: str\n}\n\nadt Result = Success | Failure\n\ndata Success {\n  message: str\n}\n\ndata Failure {\n  code: int8\n}\n\nservice UserService {\n  def saveUser(user: User): Result\n  def findUserByName(name: str): list[PublicUser] | Failure\n}","title":"User Service Example"},{"location":"/idealingua/index.html#quick-start","text":"You may use our preconfigured Docker environment to experiment with Izumi IDL compiler:\ndocker run -ti --rm septimalmind/izumi-env\nThen try this snippet:\nexport COMPILER=\"io.7mind.izumi:idealingua-v1-compiler_2.12:$izumi.version$\"\nexport S_REPOSITORY=https://oss.sonatype.org/content/repositories/snapshots \nexport R_REPOSITORY=https://oss.sonatype.org/content/repositories/releases\n\n# create sample project in `testproject` directory\ncoursier launch -r $S_REPOSITORY -r $R_REPOSITORY $COMPILER -- :init testproject \n\ncd testproject \n\n# compile Scala and Typescript projects using all the defaults\ncoursier launch -r $S_REPOSITORY -r $R_REPOSITORY $COMPILER -- :scala :typescript\n\n# Run SBT on generated Scala project\npushd .\ncd target/scala\nsbt package\npopd\n\n# Run tsc on generated Typescript project\npushd .\ncd target/typescript\nyarn install\ntsc\npopd\n\napt install -y mc\nmc","title":"Quick start"},{"location":"/idealingua/index.html#example-project","text":"See idealingua-example for examples for Scala, TypeScript, Go, C# and other languages.","title":"Example Project"},{"location":"/idealingua/index.html#installation","text":"","title":"Installation"},{"location":"/idealingua/index.html#using-sbt-plugin","text":"Add the following to your project/plugins.sbt file:\nval izumi_version = \"0.9.10-SNAPSHOT\"\naddSbtPlugin(\"io.7mind.izumi\" % \"sbt-idealingua\" % izumi_version)\nPlace your domain definitions into /src/main/izumi directory, then enable the plugin for that project. For the generated code to compile, you will also need to add dependencies on the Idealingua RTS modules:\nval izumi = prop\n\nizumiProject\n  .enablePlugins(IdealinguaPlugin)\n  .settings(\n    libraryDependencies ++= Seq(\n        Izumi.R.idealingua_model\n      , Izumi.R.idealingua_runtime_rpc\n      , Izumi.R.idealingua_runtime_rpc_http4s\n      , Izumi.R.idealingua_runtime_rpc_circe\n    )\n  )\nYou can depend on the code generated by Idealinguain in your other Scala projects:\nproject.dependsOn(izumiProject)","title":"Using SBT Plugin"},{"location":"/idealingua/index.html#using-the-standalone-compiler","text":"The compiler is built as an uberjar and published to Maven Central.\nThe preferred way to install the compiler is via coursier\nTo install current release version:\n# install release executable\ncoursier bootstrap izumi.r2:idealingua-compiler_2.12:0.9.10-SNAPSHOT -o idlc\n\n./idlc --help\nTo install development snapshot:\n# install snapshot\ncoursier bootstrap -r https://oss.sonatype.org/content/repositories/snapshots/ izumi.r2:idealingua-compiler_2.12:0.7.0-SNAPSHOT -o idlc\n\n./idlc --help\nCommandline examples:\n# compile sources in ./src and output generated code to ./target/scala and ./target/typescript \n# all compiler plugins for Scala and TypeScript are enabled by * pattern\n\n./idlc -s src -t target -L scala=* -L typescript=*\n# compile with `AnyValExtension` compiler plugin for Scala disabled\n\n./idlc -s src -t target -L scala=-AnyvalExtension -L typescript=*","title":"Using the standalone compiler"},{"location":"/idealingua/index.html#scala-http4s-transport","text":"Most likely you’ll need to use Kind Projector and enable partial unification:\nscalacOptions += \"-Ypartial-unification\"\n\nresolvers += Resolver.sonatypeRepo(\"releases\")\n\naddCompilerPlugin(\"org.spire-math\" % \"kind-projector\" % \"0.9.8\" cross CrossVersion.binary)\nYou may find the test suite for the http4s backend here.","title":"Scala http4s Transport"},{"location":"/idealingua/language-reference.html","text":"","title":"Idealingua Language Reference ? Izumi Project"},{"location":"/idealingua/language-reference.html#idealingua-language-reference","text":"","title":"Idealingua Language Reference"},{"location":"/idealingua/language-reference.html#keywords-and-aliases","text":"Keyword Aliases Explanation domain package, namespace Namespace containing collection of entities import References a domain by id include Includes *.model file by name alias type, using Type alias enum Enumeration mixin interface Mixin, named collection of fields data dto, struct Data adt choice Algebraic Data Type id Identifier, named collection of scalars service Service interface def fn, func, fun Method","title":"Keywords and aliases"},{"location":"/idealingua/language-reference.html#inheritance-operators","text":"Keyword Aliases Explanation Example + +++, ... Inherit structure (copy fields) + Mixin & &&& Inherit interface & Mixin - --- Drop structure or field (doesn’t work for interfaces) - Mixin, - field: str","title":"Inheritance operators"},{"location":"/idealingua/language-reference.html#built-in-types","text":"","title":"Built-in types"},{"location":"/idealingua/language-reference.html#scalars","text":"Type name Aliases Explanation Scala type str string String String bool boolean, bit Boolean Boolean i08 byte, int8 8-bit integer Byte i16 short, int16 16-bit integer Short i32 int, int32 32-bit integer Int i64 long, int64 64-bit integer Long f32 float, flt Single precision floating point Float f64 double, dbl Double precision floating point Double uid uuid UUID java.util.UUID tsz dtl, datetimel Timestamp with timezone java.time.ZonedDateTime tsl dtz, datetimez Local timestamp java.time.LocalDateTime time time Time java.time.LocalTime date date Date java.time.LocalDate\nNotes:\nWhen the target language lacks a corresponding numeric type, we use the smallest type available that includes the required type. e.g. in TypeScript i08 is number When the target language lacks types for time","title":"Scalars"},{"location":"/idealingua/language-reference.html#collections","text":"Type name Explanation Scala mapping list[T] List List map[K, V] Map (only scalar and id keys are supported) Map opt[T] Optional value Option set[T] Set (unordered) Set","title":"Collections"},{"location":"/idealingua/json.html","text":"","title":"JSON Wire Format ? Izumi Project"},{"location":"/idealingua/json.html#json-wire-format","text":"IdeaLingua employs a simple JSON-based wire format. To interoperate, all the language translators should implement this spec.","title":"JSON Wire Format"},{"location":"/idealingua/json.html#data-data-class","text":"data defined as:\npackage example\n\ndata User {\n  name: str\n  surname: str\n  id: uuid\n}\nShould be rendered as:\n{\n  \"name\": \"Lorem\",\n  \"surname\": \"Ipsum\",\n  \"id\": \"13bee602-521b-47c2-ad81-30527f8b2398\"\n}","title":"data: Data Class"},{"location":"/idealingua/json.html#mixin-mixin","text":"When sent over the wire, mixins include a fully qualified name of their implementation.\nmixins defined as:\npackage example\n\nmixin IntPair {\n  x: i32\n  y: i32\n}\n\ndata NamedIntPair {\n  & IntPair\n  name: str\n}\nShould be rendered as:\n{ \n  \"example.IntPair#Struct\": {\n    \"x\": 256,\n    \"y\": 512\n  }\n}\nfor the default implementation, and:\n{\n  \"example#NamedIntPair\": {\n    \"x\": 256,\n    \"y\": 512,\n    \"name\": \"Vertex\"\n  }\n}\nfor the NamedIntPair implementation.","title":"mixin: Mixin"},{"location":"/idealingua/json.html#adt-algebraic-data-type","text":"adt’s include an unqualified name of their variant.\nadt defined as:\npackage example\n\nadt AB = A | Z as B\n\ndata A {\n  value: i32\n}\n\ndata Z {\n  value: str\n}\nShould be rendered as:\n{\n  \"A\": { \n    \"value\": 1\n  }\n}\nfor the A variant, and:\n{\n  \"B\": {\n    \"value\": \"abc\"\n  }\n}\nfor the Z as B variant","title":"adt: Algebraic Data Type"},{"location":"/idealingua/json.html#id-identifier","text":"Ids are rendered as strings prefixed by type name and separated by : symbol. Field order is preserved.\nid defined as:\npackage example\n\nid UserId {\n  userId: uuid\n  companyName: str\n}\nShould be rendered as:\n\"UserId#837006c8-d070-4cde-a2dd-8999c186ef02:Lightbend\"","title":"id: Identifier"},{"location":"/idealingua/json.html#alias-type-alias","text":"Type Aliases should be rendered directly as their aliased types and should never impact serialization.","title":"alias: Type Alias"},{"location":"/idealingua/json.html#enum-enumeration","text":"Enums are rendered as strings.\nenum defined as:\npackage example\n\nenum Gender = MALE | FEMALE\nShould be rendered as:\n\"FEMALE\"","title":"enum: Enumeration"},{"location":"/idealingua/json.html#service","text":"Service outputs are always wrapped into a JSON object with one field \"value\".\nFor service defined as:\npackage example\n\nservice SayHello {\n  def sayHello(): str\n}\nsayHello method will return a result rendered as:\n{ \"value\": \"hello\" }","title":"Service"},{"location":"/idealingua/cogen.html","text":"","title":"Code generator reference ? Izumi Project"},{"location":"/idealingua/cogen.html#code-generator-reference","text":"We support the following concepts:\nEnumerations Algebraic Data Types Type aliases Mixins Data Classes Identifiers Services","title":"Code generator reference"},{"location":"/idealingua/cogen.html#inheritance","text":"We support two forms of inheritance: interface inheritance (& modifier) and structural mixins (* modifier) The only difference between structural inheritance and interface inheritance is presence/absence of the base interface in the list of supertypes Both Data Classes and Mixins support both forms of inheritance Services, ADTs, Type Aliases, Identifiers and Enumerations does not support inheritance We provide widening narrowing implicit functions as well as copy constructors for all the generated entities","title":"Inheritance"},{"location":"/idealingua/cogen.html#example","text":"mixin IntPair {\n  x: i32\n  y: i32\n}\n\nmixin Metadata {\n  id: str\n  name: str\n}\n\nmixin PointLike {\n  + Metadata\n  * IntPair\n}\n\ndata Point {\n  + Metadata\n  * IntPair\n}","title":"Example"},{"location":"/idealingua/cogen.html#scala-output","text":"trait IntPair {\n  def y: Int\n  def x: Int\n}\n\ntrait Metadata {\n  def name: String\n  def id: String\n}\n\nfinal case class Point(y: Int, name: String, x: Int, id: String) extends Metadata\n\ntrait PointLike extends Metadata {\n  def y: Int\n  def x: Int\n  def name: String\n  def id: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#constructs","text":"Notes:\nAll the examples of generated code are given in minimal form Generated code for codecs, implicit conversions and type info is omitted","title":"Constructs"},{"location":"/idealingua/cogen.html#mixin-mixin","text":"mixin Person {\n  name: str\n  surname: str\n}","title":"mixin: Mixin"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Person {\n  def name: String\n  def surname: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#data-data-class","text":"Differences between Mixins and Data Classes:\nData classes cannot be subclassed Data classes are always rendered as case classes, Mixins are always rendered as pair of Interface and Implementation\ndata HumanUser {\n  + IdentifiedUser\n  * Person\n}","title":"data: Data Class"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class HumanUser(name: String, surname: String, id: UserId) extends IdentifiedUser with Person","title":"Scala output"},{"location":"/idealingua/cogen.html#adt-algebraic-data-type","text":"mixin Success {\n  values: map[str, str]\n}\nmixin Failure {\n  message: str\n}\nadt Result {\n  Success\n  Failure\n}","title":"adt: Algebraic Data Type"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Failure extends Any { def message: String }\n\ntrait Success extends Any { def values: scala.collection.immutable.Map[String, String] }\n\nsealed trait Result \n\nobject Result {\n  type Element = Result\n  \n  case class Success(value: Success) extends Result\n  case class Failure(value: Failure) extends Result\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#alias-type-alias","text":"alias UserId = str","title":"alias: Type Alias"},{"location":"/idealingua/cogen.html#scala-output","text":"package object domain01 {\ntype UserId = String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#enum-enumeration","text":"enum Gender {\n  MALE\n  FEMALE\n}","title":"enum: Enumeration"},{"location":"/idealingua/cogen.html#scala-output","text":"sealed trait Gender\n\nobject Gender {\n  type Element = Gender\n  def all: Seq[Gender] = Seq(MALE, FEMALE)\n  def parse(value: String) = value match {\n    case \"MALE\" => MALE\n    case \"FEMALE\" => FEMALE\n  }\n  case object MALE extends Gender { override def toString: String = \"MALE\" }\n  case object FEMALE extends Gender { override def toString: String = \"FEMALE\" }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#id-identifier","text":"Notes:\nYou can use only scalar builtin types for identifier fields We provide both parser and sane .toString implementation .toString uses the following format: Name#urlencoded(part1):urlencoded(part2):... Fields are sorted by name before using in parser and .toString\nid UserId {\n  value: uid\n  company: uid\n}","title":"id: Identifier"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class UserId(value: java.util.UUID, company: java.util.UUID) {\n  override def toString: String = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.company, this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"UserId#$suffix\"\n  }\n}\n\nobject UserId {\n  def parse(s: String): UserId = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    UserId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]), parsePart[java.util.UUID](parts(1), classOf[java.util.UUID]))\n  }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#service-service","text":"id RecordId {\n  value: uid\n}\n\nmixin WithRecordId {\n  id: RecordId\n}\n\nmixin WithResult {\n  result: shared.rpc#Result\n}\n\nmixin UserData {\n  email: str\n}\n\nmixin PrivateUserData {\n  balance: f64\n}\n\nservice UserService {\n  def deleteUser(WithRecordId): (WithResult)\n  def createUser(UserData, PrivateUserData): (WithRecordId, WithResult)\n}\nNotes:\nService signature cannot accept anything except of Mixins (improvements planned) ServerDispatcher allows you to route wrapped result type to an appropriate method of an abstract implementation ClientDispatcher just passes input to an abstract receiver ClientWrapper allows you to transform unwrapped method signatures into wrapping instances ServerWrapped provides you an unwrapping service implementation ServiceUnwrapped provides you a way to implement services with signatures unwrapped","title":"service: Service"},{"location":"/idealingua/cogen.html#scala-output","text":"import _root_.izumi.idealingua.model._\nimport _root_.izumi.idealingua.runtime._\n\nclass UserServiceServerDispatcher[R[+_], S <: UserService[R]](val service: S) extends transport.AbstractServerDispatcher[R, S] {\n  import UserService._\n  override def dispatch(input: UserService.InUserService): R[UserService.OutUserService] = input match {\n    case value: UserService.InDeleteUser =>\n      service.deleteUser(value)\n    case value: UserService.InCreateUser =>\n      service.createUser(value)\n  }\n}\n\nclass UserServiceClientDispatcher[R[+_], S <: UserService[R]](dispatcher: transport.AbstractClientDispatcher[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = dispatcher.dispatch(input, classOf[UserService.OutDeleteUser])\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = dispatcher.dispatch(input, classOf[UserService.OutCreateUser])\n}\n\nclass UserServiceClientWrapper[R[+_], S <: UserService[R]](val service: S) extends model.IDLClientWrapper[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser] = {\n    service.deleteUser(UserService.InDeleteUser(id = id))\n  }\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser] = {\n    service.createUser(UserService.InCreateUser(balance = balance, email = email))\n  }\n}\n\ntrait UserServiceUnwrapped[R[+_], S <: UserService[R]] extends model.IDLServiceExploded[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser]\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser]\n}\n\nclass UserServiceServerWrapper[R[+_], S <: UserService[R]](val service: UserServiceUnwrapped[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = service.deleteUser(id = input.id)\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = service.createUser(balance = input.balance, email = input.email)\n}\n\ntrait UserService[R[_]] extends izumi.idealingua.runtime.model.IDLService[R] {\n  import UserService._\n  override type InputType = UserService.InUserService\n  override type OutputType = UserService.OutUserService\n  \n  override def inputClass: Class[UserService.InUserService] = classOf[UserService.InUserService]\n  override def outputClass: Class[UserService.OutUserService] = classOf[UserService.OutUserService]\n  \n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser]\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser]\n}\n\nobject UserService {\n  sealed trait InUserService extends Any \n  sealed trait OutUserService extends Any\n\n  case class InDeleteUser(id: RecordId) extends UserService.InUserService with WithRecordId\n  case class OutDeleteUser(result: shared.rpc.Result) extends AnyVal with UserService.OutUserService with WithResult\n  case class InCreateUser(balance: Double, email: String) extends UserService.InUserService with UserData with PrivateUserData\n  case class OutCreateUser(result: shared.rpc.Result, id: RecordId) extends UserService.OutUserService with WithRecordId with WithResult\n}","title":"Scala output"},{"location":"/idealingua/cogen-circe.html","text":"","title":"Circe serialization reference ? Izumi Project"},{"location":"/idealingua/cogen-circe.html#circe-serialization-reference","text":"","title":"Circe serialization reference"},{"location":"/idealingua/cogen-circe.html#polymorphism-and-time","text":"Notes:\nData classes cannot be polymorphic\nThe following example demonstrates how polymorphism and time values are handled:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\ntrait Polymorphic\n\nfinal case class TestPayload(\n                        zonedDateTime: ZonedDateTime = ZonedDateTime.now()\n                        , utcZonedDateTime: ZonedDateTime = ZonedDateTime.now(ZoneId.of(\"UTC\"))\n                        , localDateTime: LocalDateTime = LocalDateTime.now()\n                        , localTime: LocalTime = LocalTime.now()\n                        , localDate: LocalDate = LocalDate.now()\n                      ) extends Polymorphic\n\nobject TestPayload {\n  implicit val encodeTestPayload: Encoder[TestPayload] = deriveEncoder[TestPayload]\n  implicit val decodeTestPayload: Decoder[TestPayload] = deriveDecoder[TestPayload]\n}\n\nfinal case class AnotherPayload(message: String) extends Polymorphic\n\nobject AnotherPayload {\n  implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n  implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n}\n\nobject Polymorphic {\n    implicit val encodePolymorphic: Encoder[Polymorphic] = Encoder.instance { c =>\n    c match {\n      case v: TestPayload =>\n        Map(\"com.test#TestPayload\" -> v).asJson\n      case v: AnotherPayload =>\n        Map(\"com.test#RealPayload\" -> v).asJson\n    }\n  }\n  implicit val decodePolymorphic: Decoder[Polymorphic] = Decoder.instance(c => {\n    val fname = c.keys.flatMap(_.headOption).toSeq.head\n    val value = c.downField(fname)\n    fname match {\n      case \"com.test#TestPayload\" =>\n        value.as[TestPayload]\n      case \"com.test#RealPayload\" =>\n        value.as[AnotherPayload]\n    }\n  })\n}\n\ndef test(t: Polymorphic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Polymorphic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(TestPayload())\ntest(AnotherPayload(\"hi\"))\nThis example produces the following output:\nTestPayload:\nEncoded:\n{\"TestPayload\":{\"zonedDateTime\":\"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\"utcZonedDateTime\":\"2018-04-02T21:34:31.367744Z[UTC]\",\"localDateTime\":\"2018-04-02T22:34:31.36778\",\"localTime\":\"22:34:31.367813\",\"localDate\":\"2018-04-02\"}}\n\nParsed:\nRight({\n  \"TestPayload\" : {\n    \"zonedDateTime\" : \"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\n    \"utcZonedDateTime\" : \"2018-04-02T21:34:31.367744Z[UTC]\",\n    \"localDateTime\" : \"2018-04-02T22:34:31.36778\",\n    \"localTime\" : \"22:34:31.367813\",\n    \"localDate\" : \"2018-04-02\"\n  }\n})\n\nRestored:\nRight(Right(TestPayload(2018-04-02T22:34:31.367649+01:00[Europe/Dublin],2018-04-02T21:34:31.367744Z[UTC],2018-04-02T22:34:31.367780,22:34:31.367813,2018-04-02)))\n\n\nAnotherPayload:\nEncoded:\n{\"RealPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"RealPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Polymorphism and time"},{"location":"/idealingua/cogen-circe.html#algebraic-types","text":"Notes:\nWorks same way as polymorphic types Use short names instead of fully qualified names You may introduce a local alias for an algebraic type member: adt MyAdt { domain1.A as A1 | A}. This allows you to resolve name conflicts\nCogen example for ADTs:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\nsealed trait Algebraic\n\nobject NS1 {\n\n  case class Payload(localTime: LocalTime = LocalTime.now()) extends Algebraic\n\n  object Payload {\n    implicit val encodeTestPayload: Encoder[Payload] = deriveEncoder[Payload]\n    implicit val decodeTestPayload: Decoder[Payload] = deriveDecoder[Payload]\n  }\n\n}\n\nobject NS2 {\n\n  case class AnotherPayload(message: String) extends Algebraic\n\n  object AnotherPayload {\n    implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n    implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n  }\n\n}\nobject Algebraic {\n  implicit val encodePolymorphic: Encoder[Algebraic] = deriveEncoder[Algebraic]\n  implicit val decodePolymorphic: Decoder[Algebraic] = deriveDecoder[Algebraic]\n}\n\ndef test(t: Algebraic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Algebraic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(NS1.Payload())\ntest(NS2.AnotherPayload(\"hi\"))\nOutput:\nEncoded:\n{\"Payload\":{\"localTime\":\"18:13:31.942072\"}}\n\nParsed:\nRight({\n  \"Payload\" : {\n    \"localTime\" : \"18:13:31.942072\"\n  }\n})\n\nRestored:\nRight(Right(Payload(18:13:31.942072)))\n\nEncoded:\n{\"AnotherPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"AnotherPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Algebraic types"},{"location":"/idealingua/cogen-circe.html#identifiers","text":"Identifiers codec just invokes .toString and .parse to serialize/deserialize Identifiers.\nPlease check identifier codegen example for additional details.\nFull example:\nfinal case class CompanyId(value: java.util.UUID) {\n  override def toString: String = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"CompanyId#$suffix\"\n  }\n}\n\ntrait CompanyIdCirce {\n  import _root_.io.circe.{ Encoder, Decoder }\n  implicit val encodeCompanyId: Encoder[CompanyId] = Encoder.encodeString.contramap(_.toString)\n  implicit val decodeCompanyId: Decoder[CompanyId] = Decoder.decodeString.map(CompanyId.parse)\n}\n\nobject CompanyId extends CompanyIdCirce {\n  def parse(s: String): CompanyId = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    CompanyId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]))\n  }\n  implicit class CompanyIdExtensions(_value: CompanyId)\n}","title":"Identifiers"},{"location":"/idealingua/cogen-circe.html#enumerations","text":"Identifiers codec just invokes .toString and .parse same way as it implemented for Identifiers.","title":"Enumerations"},{"location":"/distage/index.html","text":"","title":"distage: Staged Dependency Injection ? Izumi Project"},{"location":"/distage/index.html#distage-staged-dependency-injection","text":"distage is a pragmatic module system for Scala that combines simplicity and reliability of pure FP with extreme late-binding and flexibility of runtime dependency injection frameworks such as Guice.\ndistage is unopinionated, it’s good for structuring applications written in either imperative Scala style or in pure FP Tagless Final Style","title":"distage: Staged Dependency Injection"},{"location":"/distage/index.html#why-use-distage-","text":"Faster applications and tests: distage guarantees that no unneccessary instantiations will happen during your tests or application startup. Quicker failure detection: distage peforms all the integration checks for your application and tests even before any instantiations happened. Simpler tests: distage eliminates all the hard work of setting up your test environments, especially polymorphic ones. Simpler development workflows: distage allows you to develop Role-Based Applications – a fusion of Microservices and Monoliths. You may run all your services in one process for development purposes (and even switch to mock implementations with a single commandline argument). Faster compile times and low mental overhead: Unlike fully compile-time DIs, distage does not impose a compile time penalty for medium/large projects. distage extensions are simple to write and do not require type-level programming. Simpler deployments: distage allows you to simplify deployments and reduce your running costs by leveraging Role-Based Applications Architecture. Simpler debugging: distage provides you important insights about your application and allows you to introspect and modify it on the fly, before any instantiations happen. Higher Correctness: distage supports resources and lifecycle natively and guarantees proper cleanups even when something went wrong. Cheaper integration tests: distage provides you great memoization support for your tests so you may reuse expensive resources (like database connections) across multiple integration tests, gaining performance and without sacrificing correctness. No pressure: distage is non-invasive and designed to not impact the way your Scala code is written. It just removes all the initialization boilerplate. You don’t need to learn magic tricks to write components in a distage application.\ndistage is recommended by industry leaders:\nGiven its native support for type classes and higher-kinded types – both features indispensable to functional programming – distage is one of the leading dependency injection libraries out there. Bonus points for being built by a wicked-smart team that contributes to ZIO! -? John A. De Goes","title":"Why use distage?"},{"location":"/distage/index.html#faq","text":"Q: how to pronounce “distage” ?\nA: ‘Dee-stage’! Although, you may pronounce it however you like.\nQ: isn’t it unsafe to use a runtime dependency injection framework?\nA: distage has static verification mechanisms allowing to achieve same level of guarantees as hand-written static code. Full compile-time DI support is under development.","title":"FAQ"},{"location":"/distage/index.html#further-reading","text":"distage Example Project Slides - distage: Staged Dependency Injection Tutorial Config Injection Other features Debugging Cookbook Role-Based Apps Testkit Syntax reference","title":"Further reading"},{"location":"/distage/index.html#pper","text":"See PPER Overview","title":"PPER"},{"location":"/distage/basics.html","text":"","title":"Basics ? Izumi Project"},{"location":"/distage/basics.html#basics","text":"Tutorial Function Bindings Set Bindings Effect Bindings Resource Bindings & Lifecycle Injecting Implicits Tagless Final Style Testkit","title":"Basics"},{"location":"/distage/basics.html#tutorial","text":"Suppose we want to create an abstract Greeter component that we want to use without knowing its concrete implementation:\ntrait Greeter {\n  def hello(name: String): Unit\n}\nA simple implementation would be:\nfinal class PrintGreeter extends Greeter {\n  override def hello(name: String) = println(s\"Hello $name!\") \n}\nLet’s define some more components that depend on a Greeter:\ntrait Byer {\n  def bye(name: String): Unit\n}\n\nfinal class PrintByer extends Byer {  \n  override def bye(name: String) = println(s\"Bye $name!\")\n}\n\nfinal class HelloByeApp(greeter: Greeter, byer: Byer) {\n  def run(): Unit = {\n    println(\"What's your name?\")\n    val name = readLine()\n    \n    greeter.hello(name)\n    byer.bye(name)\n  }\n}\nThe app above uses Greeter and Byer to hold a simple conversation with the user.\nTo actually run the app, we’ll have to bind the real implementations of Greeter and Byer.\nimport distage.{ModuleDef, Injector, GCMode}\n\nobject HelloByeModule extends ModuleDef {\n  make[Greeter].from[PrintGreeter]\n  make[Byer].from[PrintByer]\n  make[HelloByeApp]\n}\nSince HelloByeApp is not an interface, but a final class that implements itself, we don’t have to specify an implementation class for it.\nLet’s launch the app and see what happens:\nval injector = Injector()\n\nval plan = injector.plan(HelloByeModule, GCMode.NoGC)\nval objects = injector.produceUnsafe(plan)\n\nval app = objects.get[HelloByeApp]\napp.run()\n// What's your name?\n// kai\n// Hello kai!\n// Bye kai!\nGiven a set of bindings, such as HelloByeModule, distage will lookup the dependencies (constructor or function arguments) of each implementation and deduce a plan to satisfy each dependency using the other implementations in that module. Once finished, it will happily return the plan back to you as a simple datatype. We can print HelloByeModule’s plan while we’re at it:\nprintln(plan.render)\n// {type.Session::App0::Byer} (basics.md:62) := make[Session::App0::PrintByer] ()\n// {type.Session::App0::Greeter} (basics.md:61) := make[Session::App0::PrintGreeter] ()\n// {type.Session::App0::HelloByeApp} (basics.md:63) := make[Session::App0::HelloByeApp] (\n//   arg greeter: Session::App0::Greeter = lookup({type.Session::App0::Greeter})\n//   arg byer: Session::App0::Byer = lookup({type.Session::App0::Byer})\n// )\nSince plan is just a piece of data, we need to interpret it to create the actual object graph ? Injector’s produce method is the default interpreter. Injector contains no logic of its own beyond interpreting instructions, its output is fully determined by the plan. This makes debugging quite easy.\nGiven that plans are data, it’s possible to verify them at compile-time or splice equivalent Scala code to do the instantiation before ever running the application. When used in that way, distage is a great alternative to compile-time frameworks such as MacWire all the while keeping the flexibility to interpret at runtime when needed. This flexibility in interpretation allows adding features, such as Plugins and Typesafe Config integration by transforming plans and bindings.\nNote: classes in distage are always created exactly once, even if many different classes depend on them - they’re Singletons. Non-singleton semantics are not available, however you can create multiple named instances and disambiguate between them with @Id annotation:\nimport distage.Id\n\nnew ModuleDef {\n  make[Byer].named(\"byer-1\").from[PrintByer]\n  make[Byer].named(\"byer-2\").from {\n    otherByer: Byer @Id(\"byer-1\") =>\n      new Byer {\n        def bye(name: String) = otherByer.bye(s\"NOT-$name\")\n      }\n  }\n}\n// res3: AnyRef with ModuleDef = ListSet(SingletonBinding({type.repl.Session::repl.Session.App0::repl.Session.App0.Byer@byer-1},TypeImpl(repl.Session::repl.Session.App0::repl.Session.App0.PrintByer),Set(),(basics.md:117)), SingletonBinding({type.repl.Session::repl.Session.App0::repl.Session.App0.Byer@byer-2},ProviderImpl({java.lang.Object & repl.Session::repl.Session.App0::repl.Session.App0.Byer},<function1>(repl.Session::repl.Session.App0::repl.Session.App0.Byer): {java.lang.Object & repl.Session::repl.Session.App0::repl.Session.App0.Byer}),Set(),(basics.md:118)))\nYou can also create factory classes to help you mint new non-singleton instances. Auto-Factories can reduce boilerplate involved in doing this.\nModules can be combined into larger modules with ++ and overridenBy operators. Let’s use overridenBy to greet in ALL CAPS:\nval caps = HelloByeModule.overridenBy(new ModuleDef {\n  make[Greeter].from(new Greeter {\n    override def hello(name: String) = println(s\"HELLO ${name.toUpperCase}\")\n  })\n})\n\nval capsUniverse = injector.produceUnsafe(caps, GCMode.NoGC)\ncapsUniverse.get[HelloByeApp].run()\n// What's your name?\n// kai\n// HELLO KAI\n// Bye kai!\nWe’ve overriden the Greeter binding in HelloByeModule with an implementation of Greeter that prints in ALL CAPS. For simple cases like this we can write implementations right inside the module.","title":"Tutorial"},{"location":"/distage/basics.html#function-bindings","text":"To bind to a function instead of a class constructor use .from method in ModuleDef DSL:\nimport distage._\n\ncase class HostPort(host: String, port: Int)\n\nclass HttpServer(hostPort: HostPort)\n\nobject HttpServerModule extends ModuleDef {\n  make[HttpServer].from {\n    hostPort: HostPort =>\n      val modifiedPort = hostPort.port + 1000\n      new HttpServer(hostPort.copy(port = modifiedPort))\n  }\n}\nTo inject named instances or config values, add annotations such as @Id and @ConfPath to lambda arguments’ types:\nimport distage.config._\n\nobject HostPortModule extends ModuleDef {\n  make[HostPort].named(\"default\").from(HostPort(\"localhost\", 8080))\n  make[HostPort].from {\n    (maybeConfigHostPort: Option[HostPort] @ConfPath(\"http\"),\n     defaultHostPort: HostPort @Id(\"default\")) =>\n      maybeConfigHostPort.getOrElse(defaultHostPort)\n  }\n}\nGiven a Locator we can retrieve instances by type, call methods on them or summon them with a function:\nimport scala.util.Random\n\nval objects = Injector().produceUnsafe(HelloByeModule, GCMode.NoGC)\n// objects: Locator = izumi.distage.LocatorDefaultImpl@d1e8887\n\nobjects.run {\n  (hello: Hello, bye: Bye) =>\n    val names = Array(\"Snow\", \"Marisa\", \"Shelby\")\n    val rnd = Random.nextInt(3)\n    println(s\"Random index: $rnd\")\n    hello(names(rnd))\n    bye(names(rnd))\n}\n// Random index: 0\n// Hello Snow\n// Bye Snow\nobjects.runOption { i: Int => i + 10 } match {\n  case None => println(\"There is no Int in the object graph!\")\n  case Some(i) => println(s\"Int is $i\")\n}\n// There is no Int in the object graph!\nconsult ProviderMagnet docs for more details.","title":"Function Bindings"},{"location":"/distage/basics.html#set-bindings","text":"Set bindings are useful for implementing event listeners, plugins, hooks, http routes, healthchecks, migrations, etc. Everywhere where you need to gather up a bunch of similar components is probably a good place for a Set Binding.\nTo define a Set binding use .many and .add methods in ModuleDef DSL.\nFor example, we can gather and serve all the different http4s routes added in multiple independent modules:\n// boilerplate\nimport cats.implicits._\nimport cats.effect._\nimport distage._\nimport org.http4s._\nimport org.http4s.Uri.uri\nimport org.http4s.dsl.io._\nimport org.http4s.implicits._\nimport org.http4s.server.blaze._\n\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nimplicit val contextShift = IO.contextShift(global)\nimplicit val timer = IO.timer(global)\nobject HomeRouteModule extends ModuleDef {\n\n  val homeRoute = HttpRoutes.of[IO] { \n    case GET -> Root / \"home\" => Ok(s\"Home page!\") \n  }\n\n  many[HttpRoutes[IO]]\n    .add(homeRoute)\n}\nWe’ve used many method to declare an open Set of http routes and then added one HTTP route into it. When module definitions are combined, Sets for the same binding will be merged together. You can summon a Set Bindings by summoning a scala Set, as in Set[HttpRoutes[IO]].\nLet’s define a new module with another route:\nobject BlogRouteModule extends ModuleDef {\n\n  val blogRoute = HttpRoutes.of[IO] { \n    case GET -> Root / \"blog\" / post => Ok(s\"Blog post ``$post''!\") \n  }\n  \n  many[HttpRoutes[IO]]\n    .add(blogRoute)\n}\nNow it’s the time to define a Server component to serve all the different routes we have:\nfinal class HttpServer(routes: Set[HttpRoutes[IO]]) {\n  \n  val router: HttpApp[IO] = \n    routes.toList.foldK.orNotFound\n\n  val serverResource = \n    BlazeServerBuilder[IO]\n      .bindHttp(8080, \"localhost\")\n      .withHttpApp(router)\n      .resource\n}\n\nobject HttpServerModule extends ModuleDef {\n  make[HttpServer]\n}\nNow, let’s wire all the modules and create the server!\nval finalModule = Seq(\n    HomeRouteModule,\n    BlogRouteModule,\n    HttpServerModule,\n  ).merge\n\nval objects = Injector().produceUnsafe(finalModule, GCMode.NoGC)\n\nval server = objects.get[HttpServer]\nLet’s check if it works:\nserver.router.run(Request(uri = uri(\"/home\")))\n  .flatMap(_.as[String]).unsafeRunSync\n// res10: String = \"Home page!\"\nserver.router.run(Request(uri = uri(\"/blog/1\")))\n  .flatMap(_.as[String]).unsafeRunSync\n// res11: String = \"Blog post ``1''!\"\nFantastic!\nSee also, same concept in Guice.","title":"Set Bindings"},{"location":"/distage/basics.html#effect-bindings","text":"Sometimes we need to effectfully create a component or fetch some data and inject it into the object graph during startup (e.g. read a configuration file), but the resulting component or data does not need to be closed. An example might be a global Semaphore that limits the parallelism of an entire application based on configuration value or a dummy/test double implementation of some external service made for testing using simple Refs.\nIn these cases we can use .fromEffect to simply bind a value created effectfully.\nExample with ZIO Semaphore:\nimport distage._\nimport distage.config._\nimport zio._\n\ncase class Content(bytes: Array[Byte])\n\ncase class UploadConfig(maxParallelUploads: Long)\n\nclass UploaderModule extends ModuleDef {\n  make[Semaphore].named(\"upload-limit\").fromEffect {\n    conf: UploadConfig @ConfPath(\"myapp.uploads\") =>\n      Semaphore.make(conf.maxParallelUploads)\n  }\n  \n  make[Uploader]\n}\n\nclass Uploader(limit: Semaphore @Id(\"upload-limit\")) {\n  def upload(content: Content): IO[Throwable, Unit] =\n    limit.withPermit(upload(content))\n}\nExample with a Dummy KVStore:\ntrait KVStore[F[_, _]] {\n  def put(key: String, value: String): F[Nothing, Unit]\n  def get(key: String): F[NoSuchElementException, String]\n}\n\nobject KVStore {\n  def dummy: IO[Nothing, KVStore[IO]] = for {\n    ref <- Ref.make(Map.empty[String, String])\n    kvStore = new KVStore[IO] {\n      def put(key: String, value: String): IO[Nothing, Unit] =\n        ref.update(_ + (key -> value)).unit\n      \n      def get(key: String): IO[NoSuchElementException, String] = \n        for {\n          map <- ref.get\n          maybeValue = map.get(key)\n          res <- maybeValue match {\n            case None => \n              IO.fail(new NoSuchElementException(key))\n            case Some(value) => \n              IO.succeed(value)\n          }\n        } yield res\n    }\n  } yield kvStore\n}\n\nval kvStoreModule = new ModuleDef {\n  make[KVStore[IO]].fromEffect(KVStore.dummy)\n}\n// kvStoreModule: AnyRef with ModuleDef = ListSet(SingletonBinding({type.repl.Session::repl.Session.App12::repl.Session.App12.KVStore[=? %1:0,%1:1 ? ZIO[-Any,+1:0,+1:1]]},EffectImpl(repl.Session::repl.Session.App12::repl.Session.App12.KVStore[=? %1:0,%1:1 ? ZIO[-Any,+1:0,+1:1]],? %0 ? zio.ZIO[-Any,+Nothing,+0],InstanceImpl(zio.ZIO[-Any,+Nothing,+Session::App12::KVStore[=? %2:0,%2:1 ? ZIO[-Any,+2:0,+2:1]]],zio.ZIO$FlatMap@5042f34a)),Set(),(basics.md:438)))\n\nnew DefaultRuntime{}.unsafeRun {\n  Injector().produceF[IO[Throwable, ?]](kvStoreModule, GCMode.NoGC)\n    .use {\n      objects =>\n        val kv = objects.get[KVStore[IO]]\n        \n        for {\n          _ <- kv.put(\"apple\", \"pie\")\n          res <- kv.get(\"apple\")\n        } yield res\n    }\n}\n// res13: String = \"pie\"\nYou need to use effect-aware Injector.produceF/Injector.produceUnsafeF methods to use effect bindings.","title":"Effect Bindings"},{"location":"/distage/basics.html#resource-bindings-lifecycle","text":"Lifecycle is supported via Resource bindings. You can inject any cats.effect.Resource into the object graph. You can also inject DIResource classes. Global resources will be deallocated when the app or the test ends.\nNote that lifecycle control via DIResource is available in non-FP applications as well via inheritance from DIResource.Simple and DIResource.Mutable.\nExample with cats Resource:\nimport distage._\nimport cats.effect._\n\nclass DBConnection\nclass MessageQueueConnection\n\nval dbResource = Resource.make(\n  acquire = IO { println(\"Connecting to DB!\"); new DBConnection }\n)(release = _ => IO(println(\"Disconnecting DB\")))\n// dbResource: Resource[IO, DBConnection] = Allocate(\n//   Map(\n//     Delay(<function0>),\n//     scala.Function1$$Lambda$19601/0x0000000844c0f040@311ad409,\n//     1\n//   )\n// )\n\nval mqResource = Resource.make(\n  acquire = IO { println(\"Connecting to Message Queue!\"); new MessageQueueConnection }\n)(release = _ => IO(println(\"Disconnecting Message Queue\")))\n// mqResource: Resource[IO, MessageQueueConnection] = Allocate(\n//   Map(\n//     Delay(<function0>),\n//     scala.Function1$$Lambda$19601/0x0000000844c0f040@1700e7e9,\n//     1\n//   )\n// )\n\nclass MyApp(db: DBConnection, mq: MessageQueueConnection) {\n  val run = IO(println(\"Hello World!\"))\n}\n\ndef module = new ModuleDef {\n  make[DBConnection].fromResource(dbResource)\n  make[MessageQueueConnection].fromResource(mqResource)\n  addImplicit[Bracket[IO, Throwable]]\n  make[MyApp]\n}\nWill produce the following output:\nInjector().produceF[IO](module, GCMode.NoGC).use {\n  objects =>\n    objects.get[MyApp].run\n}.unsafeRunSync()\n// Connecting to DB!\n// Connecting to Message Queue!\n// Hello World!\n// Disconnecting Message Queue\n// Disconnecting DB\nExample with DIResource.Simple:\nimport distage._\n\nclass Init {\n  var initialized = false\n}\n\nclass InitResource extends DIResource.Simple[Init] {\n  override def acquire = {\n    val init = new Init\n    init.initialized = true\n    init\n  }\n  override def release(init: Init) = {\n    init.initialized = false\n  }\n}\n\nval module = new ModuleDef {\n  make[Init].fromResource[InitResource]\n}\n// module: AnyRef with ModuleDef = ListSet(SingletonBinding({type.repl.Session::repl.Session.App16::repl.Session.App16.Init},ResourceImpl(repl.Session::repl.Session.App16::repl.Session.App16.Init,? %0 ? 0,TypeImpl(repl.Session::repl.Session.App16::repl.Session.App16.InitResource)),Set(),(basics.md:554)))\nval closedInit = Injector().produce(module, GCMode.NoGC).use {\n  objects =>\n    val init = objects.get[Init] \n    println(init.initialized)\n    init\n}\n// true\n// closedInit: izumi.fundamentals.platform.functional.package.Identity[Init] = repl.Session$App16$Init@1d6d9b5a\nprintln(closedInit.initialized)\n// false\nDIResource forms a monad and has the expected .map, .flatMap, .evalMap methods available. You can convert a DIResource into a cats.effect.Resource via .toCats method.\nYou need to use resource-aware Injector.produce/Injector.produceF methods to control lifecycle of the object graph.","title":"Resource Bindings & Lifecycle"},{"location":"/distage/basics.html#injecting-implicits","text":"TODO Sorry, this page is not ready yet Relevant ticket: https://github.com/7mind/izumi/issues/230\nImplicits are managed like any other class. To make them available for summoning, declare them in a module:\nimport cats.Monad\nimport distage._\nimport zio.IO\nimport zio.interop.catz._\n\nobject IOMonad extends ModuleDef {\n  addImplicit[Monad[IO[Throwable, ?]]]\n  // same as make[Monad[IO[Throwable, ?]]].from(implicitly[Monad[IO[Throwable, ?]]])\n}\nImplicits for managed classes are injected from the object graph, NOT from the surrounding lexical scope. If they were captured from lexical scope inside ModuleDef, then classes would effectively depend on specific implementations of implicits available in scope at ModuleDef definition point. Depending on implementations is unmodular! We want to late-bind implicit dependencies same as any other dependencies, therefore you must specify implementations for implicits in ModuleDef.\nimport cats._\nimport distage._\n\ntrait KVStore[F[_]] {\n  def fetch(key: String): F[String]\n}\n\nfinal class KVStoreEitherImpl(implicit F: MonadError[Either[Error, ?], Error]) extends KVStore[Either[Error, ?]] {\n  def fetch(key: String) = F.raiseError(new Error(s\"no value for key $key!\"))\n}\n\nval kvstoreModuleBad = new ModuleDef {\n  // We DON'T want this import to be necessary here\n  // import cats.instances.either._\n\n  make[KVStore[Either[Error, ?]]].from[KVStoreEitherImpl]\n}\n\n// Instead, wire implicits explicitly\nval kvstoreModuleGood = new ModuleDef {\n\n  make[KVStore[Either[Error, ?]]].from[KVStoreEitherImpl]\n  \n  // Ok to import here\n  import cats.instances.either._\n  \n  // add the implicit dependency into the object graph\n  addImplicit[MonadError[Either[Error, ?], Error]]\n  \n}\nImplicits obey the usual lexical scope in user code.\nYou can participate in this ticket at https://github.com/7mind/izumi/issues/230","title":"Injecting Implicits"},{"location":"/distage/basics.html#tagless-final-style","text":"Tagless Final is one of the popular patterns for structuring purely-functional applications. If you’re not familiar with tagless final you can skip this section.\nBrief introduction to tagless final:\nDeferring Commitments: Tagless Final Introduction to Tagless Final\nAdvantages of distage as a driver for TF compared to implicits:\neasy explicit overrides easy effectful instantiation and resource management extremely easy & scalable test context setup due to the above multiple different implementations via @Id annotation\nAs an example, let’s take freestyle’s tagless example and make it safer and more flexible by replacing dependencies on global imported implementations from with explicit modules.\nFirst, the program we want to write:\nimport cats._\nimport cats.implicits._\nimport distage._\n\ntrait Validation[F[_]] {\n  def minSize(s: String, n: Int): F[Boolean]\n  def hasNumber(s: String): F[Boolean]\n}\ndef Validation[F[_]: Validation]: Validation[F] = implicitly\n\ntrait Interaction[F[_]] {\n  def tell(msg: String): F[Unit]\n  def ask(prompt: String): F[String]\n}\ndef Interaction[F[_]: Interaction]: Interaction[F] = implicitly\n\nclass TaglessProgram[F[_]: Monad: Validation: Interaction] {\n  def program: F[Unit] = for {\n    userInput <- Interaction[F].ask(\"Give me something with at least 3 chars and a number on it\")\n    valid     <- (Validation[F].minSize(userInput, 3), Validation[F].hasNumber(userInput)).mapN(_ && _)\n    _         <- if (valid) \n                    Interaction[F].tell(\"awesomesauce!\")\n                 else \n                    Interaction[F].tell(s\"$userInput is not valid\")\n  } yield ()\n}\n\nclass Program[F[_]: TagK: Monad] extends ModuleDef {\n  make[TaglessProgram[F]]\n\n  addImplicit[Monad[F]]\n}\nTagK is distage’s analogue of TypeTag for higher-kinded types such as F[_], it allows preserving type-information at runtime for types that aren’t yet known at definition. You’ll need to add a TagK context bound to create a module parameterized by an abstract F[_]. Use Tag to create modules parameterized by non-higher-kinded types.\nInterpreters:\nimport scala.util.Try\nimport cats.instances.all._\n\ndef tryValidation = new Validation[Try] {\n  def minSize(s: String, n: Int): Try[Boolean] = Try(s.size >= n)\n  def hasNumber(s: String): Try[Boolean] = Try(s.exists(c => \"0123456789\".contains(c)))\n}\n  \ndef tryInteraction = new Interaction[Try] {\n  def tell(s: String): Try[Unit] = Try(println(s))\n  def ask(s: String): Try[String] = Try(\"This could have been user input 1\")\n}\n\nobject TryInterpreters extends ModuleDef {\n  make[Validation[Try]].from(tryValidation)\n  make[Interaction[Try]].from(tryInteraction)\n}\n\n// combine all modules\nval TryProgram = new Program[Try] ++ TryInterpreters\n// TryProgram: Module = ListSet(SingletonBinding({type.repl.Session::repl.Session.App18::repl.Session.App18.Validation[=? %1:0 ? Try[+1:0]]},ProviderImpl({java.lang.Object & repl.Session::repl.Session.App18::repl.Session.App18.Validation[=? %1:0 ? Try[+1:0]]},izumi.distage.model.providers.ProviderMagnet$$$Lambda$18217/0x000000084469b040@20dd99de(): {java.lang.Object & repl.Session::repl.Session.App18::repl.Session.App18.Validation[=? %1:0 ? Try[+1:0]]}),Set(),(basics.md:670)), SingletonBinding({type.repl.Session::repl.Session.App18::repl.Session.App18.Interaction[=? %1:0 ? Try[+1:0]]},ProviderImpl({java.lang.Object & repl.Session::repl.Session.App18::repl.Session.App18.Interaction[=? %1:0 ? Try[+1:0]]},izumi.distage.model.providers.ProviderMagnet$$$Lambda$18217/0x000000084469b040@139c1c28(): {java.lang.Object & repl.Session::repl.Session.App18::repl.Session.App18.Interaction[=? %1:0 ? Try[+1:0]]}),Set(),(basics.md:671)), SingletonBinding({type.repl.Session::repl.Session.App18::repl.Session.App18.TaglessProgram[=? %1:0 ? Try[+1:0]]},ProviderImpl(repl.Session::repl.Session.App18::repl.Session.App18.TaglessProgram[=? %1:0 ? Try[+1:0]],<function1>(cats.Monad[=? %1:0 ? Try[+1:0]], repl.Session::repl.Session.App18::repl.Session.App18.Validation[=? %1:0 ? Try[+1:0]], repl.Session::repl.Session.App18::repl.Session.App18.Interaction[=? %1:0 ? Try[+1:0]]): repl.Session::repl.Session.App18::repl.Session.App18.TaglessProgram[=? %1:0 ? Try[+1:0]]),Set(),(basics.md:636)), SingletonBinding({type.cats.Monad[=? %1:0 ? Try[+1:0]]},InstanceImpl(cats.Monad[=? %1:0 ? Try[+1:0]],cats.instances.TryInstances$$anon$1@1c9693a3),Set(),(basics.md:638)))\n\n// create object graph\nval objects = Injector().produceUnsafe(TryProgram, GCMode.NoGC)\n// objects: Locator = izumi.distage.LocatorDefaultImpl@7a6e9f98\n\n// run\nobjects.get[TaglessProgram[Try]].program\n// awesomesauce!\n// res19: Try[Unit] = Success(())\nThe program module is polymorphic over its eventual monad, we can easily parameterize it with a different monad:\nimport cats.effect._\n\ndef SyncInterpreters[F[_]: TagK](implicit F: Sync[F]) = new ModuleDef {\n  make[Validation[F]].from(new Validation[F] {\n    def minSize(s: String, n: Int): F[Boolean] = F.delay(s.size >= n)\n    def hasNumber(s: String): F[Boolean] = F.delay(s.exists(c => \"0123456789\".contains(c)))\n  })\n  make[Interaction[F]].from(new Interaction[F] {\n    def tell(s: String): F[Unit] = F.delay(println(s))\n    def ask(s: String): F[String] = F.delay(\"This could have been user input 1\")\n  })\n}\n\ndef IOProgram = new Program[IO] ++ SyncInterpreters[IO]\nWe can leave it completely polymorphic as well:\ndef SyncProgram[F[_]: TagK: Sync] = new Program[F] ++ SyncInterpreters[F]\nOr choose different interpreters at runtime:\ndef DifferentTryInterpreters = ???\ndef chooseInterpreters(default: Boolean) = {\n  val interpreters = if (default) TryInterpreters else DifferentTryInterpreters\n  new Program[Try] ++ interpreters\n}\nModules can be polymorphic over arbitrary kinds - use TagKK to abstract over bifunctors:\nclass BifunctorIOModule[F[_, _]: TagKK] extends ModuleDef\nOr use Tag.auto.T to abstract over any kind:\nclass MonadTransModule[F[_[_], _]: Tag.auto.T] extends ModuleDef\nclass TrifunctorModule[F[_, _, _]: Tag.auto.T] extends ModuleDef\nclass EldritchModule[F[+_, -_[_, _], _[_[_, _], _], _]: Tag.auto.T] extends ModuleDef\nconsult HKTag docs for more details.","title":"Tagless Final Style"},{"location":"/distage/basics.html#testkit","text":"distage-testkit module provides integration with scalatest:\nlibraryDependencies += Izumi.R.distage_testkit\nor\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-plugins\" % \"0.9.10-SNAPSHOT\"\nIf you’re not using sbt-izumi-deps plugin.\nExample usage:\n```scala\n```","title":"Testkit"},{"location":"/distage/config_injection.html","text":"","title":"Config Injection ? Izumi Project"},{"location":"/distage/config_injection.html#config-injection","text":"distage-config library parses typesafe-config into arbitrary case classes or sealed traits and makes them available for summoning as a class dependency.\nTo use it, add distage-config library:\nlibraryDependencies += Izumi.R.distage_config\nor\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-config\" % \"0.9.10-SNAPSHOT\"\nIf you’re not using sbt-izumi-deps plugin.\nWrite a config in HOCON format:\n# resources/application.conf\nprogram {\n    config {\n        different = true\n    }\n}\nAdd ConfigModule into your injector:\nimport distage.config._\nimport com.typesafe.config.ConfigFactory\n\nval config = ConfigFactory.load()\n\nval injector = Injector(new ConfigModule(AppConfig(config)))\nNow you can automatically parse config entries into case classes and summon them from any class:\nfinal case class Config(different: Boolean)\n\nclass ConfiguredTaglessProgram[F[_]](\n  config: Config @ConfPath(\"program.config\"),\n  primaryProgram: TaglessProgram[F] @Id(\"primary\"),\n  differentProgram: TaglessProgram[F] @Id(\"different\") ) {\n\n    val program = if (config.different) differentProgram else primaryProgram\n}\n\nclass ConfiguredTryProgram[F[_]: TagK: Monad] extends ModuleDef {\n  make[ConfiguredProgram[F]]\n  make[TaglessProgram[F]].named(\"primary\")\n  make[TaglessProgram[F]].named(\"different\")\n}","title":"Config Injection"},{"location":"/distage/other-features.html","text":"","title":"Other Features ? Izumi Project"},{"location":"/distage/other-features.html#other-features","text":"Garbage Collection Auto-Traits Auto-Factories Plugins Compile-Time Instantiation Compile-Time Checks Example: Roles Circular Dependencies support Automatic Resolution with generated proxies Manual Resolution with by-name parameters Auto-Sets Weak Sets Cats Integration","title":"Other Features"},{"location":"/distage/other-features.html#garbage-collection","text":"A garbage collector is included in distage by default. Given a set of GC root keys, GC will remove all bindings that are neither direct nor transitive dependencies of the supplied roots ? these bindings will be thrown out and never instantiated.\nGC serves two important purposes:\nIt enables faster tests by omitting unrequired instantiations and initialization of potentially heavy resources, It enables multiple independent applications, aka “Roles” to be hosted within a single .jar file.\nTo use garbage collector, pass GC roots as an argument to Injector.produce* methods:\nimport distage._\n\ncase class A(b: B)\ncase class B()\ncase class C() {\n  println(\"C!\")\n}\n\nval module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n// module: AnyRef with ModuleDef = ListSet(SingletonBinding({type.repl.Session::repl.Session.App0::repl.Session.App0.C},TypeImpl(repl.Session::repl.Session.App0::repl.Session.App0.C),Set(),(other-features.md:28)), SingletonBinding({type.repl.Session::repl.Session.App0::repl.Session.App0.B},TypeImpl(repl.Session::repl.Session.App0::repl.Session.App0.B),Set(),(other-features.md:27)), SingletonBinding({type.repl.Session::repl.Session.App0::repl.Session.App0.A},TypeImpl(repl.Session::repl.Session.App0::repl.Session.App0.A),Set(),(other-features.md:26)))\nval gc = GCMode.GCRoots(Set[DIKey](DIKey.get[A]))\n// gc: package.GCMode.GCRoots = GCRoots(\n//   Set(\n//     TypeKey(\n//       SafeType(TypeRef(ThisType(class App0), class A, List()), Session::App0::A)\n//     )\n//   )\n// )\n\nval locator = Injector().produceUnsafe(module, mode = gc)\n// locator: Locator = izumi.distage.LocatorDefaultImpl@6fcaa60b\n\n// A and B are here\nlocator.find[A]\n// res1: Option[A] = Some(A(B()))\nlocator.find[B]\n// res2: Option[B] = Some(B())\n\n// C was not created\nlocator.find[C]\n// res3: Option[C] = None\nClass C was removed because neither B nor A depended on it. It’s not present in the Locator and the \"C!\" message was never printed. But, if class B were to depend on C as in case class B(c: C), it would’ve been retained, because A - the GC root, would depend on B which in turns depends on C.","title":"Garbage Collection"},{"location":"/distage/other-features.html#auto-traits","text":"TODO Sorry, this page is not ready yet\n…","title":"Auto-Traits"},{"location":"/distage/other-features.html#auto-factories","text":"distage can automatically create ‘factory’ classes from suitable traits. This feature is especially useful with Akka.\nGiven a class ActorFactory:\nimport distage._\nimport java.util.UUID\n\nclass SessionStorage\n\nclass UserActor(sessionId: UUID, sessionStorage: SessionStorage)\n\ntrait ActorFactory {\n  def createActor(sessionId: UUID): UserActor\n}\nAnd a binding of ActorFactory without an implementation\nclass ActorModule extends ModuleDef {\n  make[ActorFactory]\n}\ndistage will derive and bind the following implementation for ActorFactory:\nclass ActorFactoryImpl(sessionStorage: SessionStorage) extends ActorFactory {\n  override def createActor(sessionId: UUID): UserActor = {\n    new UserActor(sessionId, sessionStorage)\n  }\n}\nYou can use this feature to concisely provide non-singleton semantics for some of your components.\nBy default, the factory implementation class will be created automatically at runtime. To create factories at compile-time summon an implicit FactoryConstructor for your type.","title":"Auto-Factories"},{"location":"/distage/other-features.html#plugins","text":"Plugins are a distage extension that allows you to automatically pick up all Plugin modules that are defined in specified package on the classpath.\nPlugins are especially useful in scenarios with extreme late-binding, when the list of loaded application modules is not known ahead of time. Plugins are compatible with compile-time checks as long as they’re defined in a separate module.\nTo use plugins add distage-plugins library:\nlibraryDependencies += Izumi.R.distage_plugins\nor\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-plugins\" % \"0.9.10-SNAPSHOT\"\nIf you’re not using sbt-izumi-deps plugin.\nCreate a module extending the PluginDef trait instead of ModuleDef:\npackage com.example.petstore\n\nimport distage._\nimport distage.plugins._\n\ntrait PetStorePlugin extends PluginDef {\n  make[PetRepository]\n  make[PetStoreService]\n  make[PetStoreController]\n}\nAt your app entry point use a plugin loader to discover all PluginDefs:\nval pluginLoader = new PluginLoaderDefaultImpl(\n  PluginConfig(\n    debug = true\n  , packagesEnabled = Seq(\"com.example.petstore\") // packages to scan\n  , packagesDisabled = Seq.empty         // packages to ignore\n  )\n)\n\nval appModules: Seq[PluginBase] = pluginLoader.load()\nval app: ModuleBase = appModules.merge\nLaunch as normal with the loaded modules:\nInjector().produce(app).use {\n  _.get[PetStoreController].run\n}\nPlugins also allow a program to extend itself at runtime by adding new Plugin classes to the classpath via java -cp","title":"Plugins"},{"location":"/distage/other-features.html#compile-time-instantiation","text":"TODO Sorry, this page is not ready yet Relevant ticket: https://github.com/7mind/izumi/issues/453\nWIP\nYou can participate in this ticket at https://github.com/7mind/izumi/issues/453","title":"Compile-Time Instantiation"},{"location":"/distage/other-features.html#compile-time-checks","text":"TODO Sorry, this page is not ready yet Relevant ticket: https://github.com/7mind/izumi/issues/51\nAs of now, an experimental plugin-checking API is available in distage-app module.\nTo use it add distage-app library:\nlibraryDependencies += Izumi.R.distage_app\nor\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-app\" % \"0.9.10-SNAPSHOT\"\nIf you’re not using sbt-izumi-deps plugin.\nOnly plugins defined in a different module can be checked at compile-time, test scope counts as a different module.","title":"Compile-Time Checks"},{"location":"/distage/other-features.html#example-","text":"In main scope:\n// src/main/scala/com/example/AppPlugin.scala\npackage com.example\nimport distage._\nimport distage.plugins._\nimport distage.config._\nimport izumi.distage.app.ModuleRequirements\n\nfinal case class HostPort(host: String, port: Int)\n\nfinal case class Config(hostPort: HostPort)\n\nfinal class Service(conf: Config @ConfPath(\"config\"), otherService: OtherService)\n\n// OtherService class is not defined here, even though Service depends on it\nfinal class AppPlugin extends PluginDef {\n  make[Service]\n}\n\n// Declare OtherService as an external dependency\nfinal class AppRequirements extends ModuleRequirements(\n  // If we remove this line, compilation will rightfully break\n  Set(DIKey.get[OtherService])\n)\nIn config:\n// src/main/resources/application.conf\n// We are going to check if our starting configuration is correct as well.\nconfig {\n  // If we remove these, the compilation will rightfully break, as the `HostPort` case class won't deserialize from the config\n  host = localhost\n  port = 8080\n}\nIn test scope:\n// src/test/scala/com/example/test/AppPluginTest.scala\npackage com.example.test\n\nimport com.example._\nimport org.scalatest.WordSpec\nimport izumi.distage.app.StaticPluginChecker\n\nfinal class AppPluginTest extends WordSpec {\n  \n  \"App plugin will work (if OtherService will be provided later)\" in {\n    StaticPluginChecker.checkWithConfig[AppPlugin, AppRequirements](disableTags = \"\", configFileRegex = \"*.application.conf\")   \n  }\n\n}\ncheckWithConfig will run at compile-time, every time that AppPluginTest is recompiled.\nYou can participate in this ticket at https://github.com/7mind/izumi/issues/51","title":"Example:"},{"location":"/distage/other-features.html#roles","text":"TODO Sorry, this page is not ready yet\n“Roles” are a pattern of multi-tenant applications, in which multiple separate microservices all reside within a single .jar. This strategy helps cut down development, maintenance and operations costs associated with maintaining fully separate code bases and binaries. Apps are chosen via command-line parameters: ./launcher app1 app2 app3. If you’re not launching all apps hosted by the launcher at the same time, the redundant components from unlaunched apps will be garbage collected and won’t be started.\nconsult slides Roles: a viable alternative to Microservices for more details.\ndistage-roles module hosts the current experimental Roles API:\nlibraryDependencies += Izumi.R.distage_roles\nor\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-roles\" % \"0.9.10-SNAPSHOT\"\nIf you’re not using sbt-izumi-deps plugin.","title":"Roles"},{"location":"/distage/other-features.html#circular-dependencies-support","text":"distage automatically resolves circular dependencies, including self-reference:\nimport distage._\n\ncase class A(b: B)\ncase class B(a: A) \ncase class C(c: C)\n\nval locator = Injector().produce(new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n})\n\nlocator.get[A] eq locator.get[B].a\n// res0: Boolean = true\nlocator.get[B] eq locator.get[A].b\n// res1: Boolean = true\nlocator.get[C] eq locator.get[C].c\n// res2: Boolean = true","title":"Circular Dependencies support"},{"location":"/distage/other-features.html#automatic-resolution-with-generated-proxies","text":"The above strategy depends on distage-proxy-cglib module which is brought in by default with distage-core.\nIt’s enabled by default. If you want to disable it, use noCogen bootstrap environment:\nimport izumi.distage.bootstrap.DefaultBootstrapContext\nimport distage._\n\nInjector(DefaultBootstrapContext.noCogen)","title":"Automatic Resolution with generated proxies"},{"location":"/distage/other-features.html#manual-resolution-with-by-name-parameters","text":"Most cycles can also be resolved manually when identified, using by-name parameters.\nCircular dependencies in the following example are all resolved via Scala’s native by-name’s, without any proxy generation:\nimport izumi.distage.bootstrap.DefaultBootstrapContext.noCogen\nimport distage._\n\nclass A(b0: => B) {\n  def b: B = b0\n}\n\nclass B(a0: => A) {\n  def a: A = a0\n}\n\nclass C(self: => C) {\n  def c: C = self\n}\n\nval module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n\nval locator = Injector(noCogen).produce(module)\n\nassert(locator.get[A].b eq locator.get[B])\nassert(locator.get[B].a eq locator.get[A])\nassert(locator.get[C].c eq locator.get[C])\nThe proxy generation via cglib is still enabled by default, because in scenarios with extreme late-binding, cycles can emerge unexpectedly, outside of control of the origin module.\nNB: Currently a limitation applies to by-names - ALL dependencies on a class engaged in a by-name circular dependency have to be by-name, otherwise distage will transparently revert to generating proxies.","title":"Manual Resolution with by-name parameters"},{"location":"/distage/other-features.html#auto-sets","text":"AutoSet Planner Hooks traverse the plan and collect all future objects matching a predicate.\nUsing Auto-Sets you can e.g. collect all AutoCloseable classes and .close() them after the application has finished work.\nNOTE: please use Resource bindings for real lifecycle, this is just an example.\ntrait PrintResource(name: String) {\n  def start(): Unit = println(s\"$name started\")\n  def stop(): Unit = println(s\"$name stopped\")\n}\n\nclass A extends PrintResource(\"A\")\nclass B(val a: A) extends PrintResource(\"B\")\nclass C(val b: B) extends PrintResource(\"C\")\n\nval resources = Injector(new BootstrapModuleDef {\n  many[PlanningHook]\n    .add(new AssignableFromAutoSetHook[PrintResource])\n}).produce(new ModuleDef {\n  make[C]\n  make[B]\n  make[A]\n}).get[Set[PrintResource]]\n\nresources.foreach(_.start())\nresources.reverse.foreach(_.stop())\n\n// Will print:\n// A started\n// B started\n// C started\n// C stopped\n// B stopped\n// A stopped\nCalling .foreach on an auto-set is safe; the actions will be executed in order of dependencies. Auto-Sets preserve ordering, they use ListSet under the hood, unlike user-defined Sets. e.g. If C depends on B depends on A, autoset order is: A, B, C, to start call: A, B, C, to close call: C, B, A. When you use auto-sets for finalization, you must .reverse the autoset.\nNote: Auto-Sets are NOT subject to Garbage Collection, they are assembled after garbage collection is done, as such they can’t contain garbage by construction.\nNOTE: please use Resource bindings for real lifecycle, this is just an example.\nSee also: same concept in MacWire","title":"Auto-Sets"},{"location":"/distage/other-features.html#weak-sets","text":"Set bindings can contain weak references. References designated as weak will be retained by Garbage Collector only if there are other references to them except the set binding itself.\nExample:\nimport distage._\n\nsealed trait SetElem\n\nfinal class Strong extends SetElem {\n  println(\"Strong constructed\")\n}\n\nfinal class Weak extends SetElem {\n  println(\"Weak constructed\")\n}\n\nval module = new ModuleDef {\n  make[Strong]\n  make[Weak]\n  \n  many[SetElem]\n    .ref[Strong]\n    .weak[Weak]\n}\n\n// Designate Set[SetElem] as the garbage collection root,\n// everything that Set[SetElem] does not strongly depend on will be garbage collected\n// and will not be constructed. \nval roots = Set[DIKey](DIKey.get[Set[SetElem]])\n\nval locator = Injector().produceUnsafe(HACK_OVERRIDE_module, roots = roots)\n\nlocator.get[Set[SetElem]].size == 1\n// res0: Boolean = true\nThe Weak class was not required in any dependency of Set[SetElem], so it was pruned. The Strong class remained, because the reference to it was strong, therefore it was counted as a dependency of Set[SetElem]\nIf we change Strong to depend on Weak, then Weak will be retained:\nfinal class Strong(weak: Weak) {\n  println(\"Strong constructed\")\n}\n\nlocator.get[Set[SetElem]].size == 2\n// res1: Boolean = true","title":"Weak Sets"},{"location":"/distage/other-features.html#cats-integration","text":"Additional cats instances and syntax are available automatically without imports if cats-core or cats-effect are already dependencies of your project. (Note: distage won’t bring cats as a dependency if you don’t already use it. See No More Orphans for the technique)\nCats Resource Bindings will also work out of the box without any magic imports.\nExample:\nimport cats.implicits._\nimport cats.effect._\nimport distage._\nimport com.example.{DBConnection, AppEntrypoint}\n\nobject Main extends IOApp {\n  def run(args: List[String]): IO[Unit] = {\n    // ModuleDef has a Monoid instance\n    val myModules = module1 |+| module2\n    \n    for {\n      // resolveImportsF can effectfully add missing instances to an existing plan\n      // (You can create instances effectfully beforehand via `make[_].fromEffect` bindings)\n      plan <- myModules.resolveImportsF[IO] {\n        case i if i.target == DIKey.get[DBConnection] =>\n           DBConnection.create[IO]\n      } \n      // `produceF` specifies an Effect to run in; \n      // Effect used in Resource and Effect Bindings \n      // should match the effect in `produceF`\n      classes <- Injector().produceF[IO](plan)\n      _ <- classes.get[AppEntrypoint].run\n    } yield ()\n  }\n}","title":"Cats Integration"},{"location":"/distage/debugging.html","text":"","title":"Debugging ? Izumi Project"},{"location":"/distage/debugging.html#debugging","text":"","title":"Debugging"},{"location":"/distage/debugging.html#pretty-printing-plans","text":"You can print the plan to get detailed info on what will happen during instantiation. The printout includes file:line info so your IDE can show you where the binding was defined!\nval plan = Injector().plan(module)\n\nSystem.err.println(plan)\nYou can also query a plan to see the dependencies and reverse dependencies of a specific class and their order of instantiation:\n// Print dependencies\nSystem.err.println(plan.topology.dependencies.tree(DIKey.get[Circular1]))\n// Print reverse dependencies\nSystem.err.println(plan.topology.dependees.tree(DIKey.get[Circular1]))\nThe printer highlights circular dependencies.\ndistage also uses some macros to create TagKs and function bindings, you can turn on macro debug output during compilation by setting -Dizumi.debug.macro.rtti=true java property:\nsbt -Dizumi.debug.macro.rtti=true compile","title":"Pretty-printing plans"},{"location":"/distage/debugging.html#graphviz-rendering","text":"Add GraphDumpBootstrapModule to your Injector’s configuration to enable dumping of graphviz files with a graphical representation of the Plan.\nval injector = Injector(new GraphDumpBootstrapModule())\nData will be saved dumped to ./target/plan-last-full.gv and ./target/plan-last-nogc.gv in current working directory.\nYou’ll need a GraphViz installation to render these files into a viewable PNG images:\ndot -Tpng target/plan-last-nogc.gv -o out.png","title":"Graphviz rendering"},{"location":"/distage/cookbook.html","text":"","title":"Cookbook ? Izumi Project"},{"location":"/distage/cookbook.html#cookbook","text":"","title":"Cookbook"},{"location":"/distage/cookbook.html#inner-classes-and-path-dependent-types","text":"To instantiate path-dependent types via constructor, their prefix type must be present in the object graph:\nimport distage._\n\ntrait Path {\n  class A\n  class B\n}\n\nval path = new Path {}\n// path: AnyRef with Path = repl.Session$App0$$anon$1@550e5180\n\nval module = new ModuleDef {\n  make[path.A]\n  make[path.type].from[path.type](path: path.type)\n}\n// module: AnyRef with ModuleDef = ListSet(SingletonBinding({type.repl.Session.App0.<refinement>},ProviderImpl(repl.Session.App0.<refinement>,izumi.distage.model.providers.ProviderMagnet$$$Lambda$18217/0x000000084469b040@2c2531d7(): repl.Session.App0.<refinement>),Set(),(cookbook.md:25)), SingletonBinding({type.{java.lang.Object & repl.Session::repl.Session.App0::repl.Session.App0.Path}::repl.Session.App0.Path.A},TypeImpl({java.lang.Object & repl.Session::repl.Session.App0::repl.Session.App0.Path}::repl.Session.App0.Path.A),Set(),(cookbook.md:24)))\nThe same applies to type projections:\nval module1 = new ModuleDef {\n  make[Path#B]\n  make[Path].from(new Path {})\n}\n// module1: AnyRef with ModuleDef = ListSet(SingletonBinding({type.repl.Session::repl.Session.App0::repl.Session.App0.Path::repl.Session.App0.Path.B},TypeImpl(repl.Session::repl.Session.App0::repl.Session.App0.Path::repl.Session.App0.Path.B),Set(),(cookbook.md:33)), SingletonBinding({type.repl.Session::repl.Session.App0::repl.Session.App0.Path},ProviderImpl({java.lang.Object & repl.Session::repl.Session.App0::repl.Session.App0.Path},izumi.distage.model.providers.ProviderMagnet$$$Lambda$18217/0x000000084469b040@4da5db4f(): {java.lang.Object & repl.Session::repl.Session.App0::repl.Session.App0.Path}),Set(),(cookbook.md:34)))\nFunction and instance bindings and constructors generated by implicit AnyConstructor do not require the type prefix:\nval module2 = new ModuleDef {\n  make[Path#B].fromValue {\n    val path = new Path {}\n    new path.B\n  }\n}\n// module2: AnyRef with ModuleDef = ListSet(SingletonBinding({type.repl.Session::repl.Session.App0::repl.Session.App0.Path::repl.Session.App0.Path.B},InstanceImpl({java.lang.Object & repl.Session::repl.Session.App0::repl.Session.App0.Path}::repl.Session.App0.Path.B,repl.Session$App0$Path$B@6cf0724c),Set(),(cookbook.md:42)))","title":"Inner Classes and Path-Dependent Types"},{"location":"/distage/cookbook.html#depending-on-locator","text":"Classes can depend on the Locator (container of the final object graph):\nimport distage._\n\nclass A(all: LocatorRef) {\n  def c = all.get.get[C]\n}\nclass B\nclass C\n\nval module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n\nval locator = Injector().produce(module)\n\nassert(locator.get[A].c eq locator.get[C])\nLocator contains metadata about the plan and the bindings from which it was ultimately created:\n// Plan that created this locator\nval plan: OrderedPlan = locator.plan\n\n// Bindings from which the Plan was built\nval moduleDef: ModuleBase = plan.definition","title":"Depending on Locator"},{"location":"/distage/roles.html","text":"","title":"Role-Based Applications ? Izumi Project"},{"location":"/distage/roles.html#role-based-applications","text":"","title":"Role-Based Applications"},{"location":"/distage/roles.html#basics","text":"","title":"Basics"},{"location":"/distage/testkit.html","text":"","title":"Testkit ? Izumi Project"},{"location":"/distage/testkit.html#testkit","text":"TODO Sorry, this page is not ready yet\ndistage sample project features several examples of testkit usage.\nHigh-level syntax example of distage-testkit for scalatest:\nclass DistageTestExampleBIO extends DistageBIOSpecScalatest[ZIO] {\n\n  \"distage test runner\" should {\n    \"support bifunctor\" in {\n      service: MockUserRepository[ZIO[Throwable, ?]] =>\n        for {\n          _ <- ZIO(assert(service != null))\n        } yield ()\n    }\n  }\n\n}","title":"Testkit"},{"location":"/distage/testkit.html#basics","text":"","title":"Basics"},{"location":"/distage/testkit.html#testkit-and-role-based-applications","text":"","title":"Testkit and Role-Based Applications"},{"location":"/distage/reference.html","text":"","title":"Syntax Summary ? Izumi Project"},{"location":"/distage/reference.html#syntax-summary","text":"","title":"Syntax Summary"},{"location":"/distage/reference.html#syntax-summary","text":"ModuleDef DSL syntax:\nSingleton bindings:\n  - `make[X]` = create X using its constructor\n  - `make[X].from[XImpl]` = bind X to its subtype XImpl using XImpl's constructor\n  - `make[X].from(myX)` = bind X to an already existing instance `myX`\n  - `make[X].from { y: Y => new X(y) }` = bind X to an instance of X constructed by a given [[izumi.distage.model.providers.ProviderMagnet Provider]] function\n  - `make[X].named(\"special\")` = bind a named instance of X. It can then be summoned using [[Id]] annotation.\n  - `make[X].using[X](\"special\")` = bind X to refer to another already bound named instance at key `[X].named(\"special\")`\n  - `make[X].fromEffect(X.create[F]: F[X])` = create X using a purely-functional effect `X.create` in `F` monad\n  - `make[X].fromResource(X.resource[F]: Resource[F, X])` = create X using a Resource specifying its creation and destruction lifecycle\n\nSet bindings:\n  - `many[X].add[X1].add[X2]` = bind a [[Set]] of X, and add subtypes X1 and X2 created via their constructors to it.\n                                Sets can be bound in multiple different modules. All the elements of the same set in different modules will be joined together.\n  - `many[X].add(x1).add(x2)` = add *instances* x1 and x2 to a `Set[X]`\n  - `many[X].add { y: Y => new X1(y).add { y: Y => X2(y) }` = add instances of X1 and X2 constructed by a given [[izumi.distage.model.providers.ProviderMagnet Provider]] function\n  - `many[X].named(\"special\").add[X1]` = create a named set of X, all the elements of it are added to this named set.\n  - `many[X].ref[XImpl]` = add a reference to an already **existing** binding of XImpl to a set of X's\n  - `many[X].ref[X](\"special\")` = add a reference to an **existing** named binding of X to a set of X's\n\nTags:\n  - `make[X].tagged(\"t1\", \"t2)` = attach tags to X's binding. Tags can be processed in a special way. See [[izumi.distage.roles.model.RoleId]]\n  - `many[X].add[X1].tagged(\"x1tag\")` = Tag a specific element of X. The tags of sets and their elements are separate.\n  - `many[X].tagged(\"xsettag\")` = Tag the binding of empty Set of X with a tag. The tags of sets and their elements are separate.\n\nIncludes:\n  - `include(that: ModuleDef)` = add all bindings in `that` module into `this` module","title":"Syntax Summary"},{"location":"/logstage/index.html","text":"","title":"LogStage ? Izumi Project"},{"location":"/logstage/index.html#logstage","text":"LogStage is a zero-cost structural logging framework for Scala & Scala.js\nKey features:\nLogStage extracts structure from ordinary string interpolations in your log messages with zero changes to code. LogStage uses macros to extract log structure, its faster at runtime than a typical reflective structural logging frameworks, Log contexts Console, File and SLF4J sinks included, File sink supports log rotation, Human-readable output and JSON output included, Method-level logging granularity. Can configure methods com.example.Service.start and com.example.Service.doSomething independently, Slf4J adapters: route legacy Slf4J logs into LogStage router","title":"LogStage"},{"location":"/logstage/index.html#overview","text":"The following snippet:\nimport logstage._\nimport scala.util.Random\n\nval logger = IzLogger()\n\nval justAnArg = \"example\"\nval justAList = List[Any](10, \"green\", \"bottles\")\n\nlogger.trace(s\"Argument: $justAnArg, another arg: $justAList\")\n\n// custom name, not based on `val` name\nlogger.info(s\"Named expression: ${Random.nextInt() -> \"random number\"}\")\n\n// print result without a name\nlogger.warn(s\"Invisible argument: ${Random.nextInt() -> \"random number\" -> null}\")\n\n// add following fields to all messages printed by a new logger value\nval ctxLogger = logger(\"userId\" -> \"user@google.com\", \"company\" -> \"acme\")\nval delta = Random.nextInt(1000)\n\nctxLogger.info(s\"Processing time: $delta\")\nWill look like this in string form:\nAnd like this in JSON:\nNote:\nJSON formatter is type aware! Each JSON message contains @class field with holds a unique event class identifier. All events produced by the same source code line will share the same event class.","title":"Overview"},{"location":"/logstage/index.html#syntax-reference","text":"1) Simple variable:\nscala logger.info(s\"My message: $argument\")\n2) Chain:\nscala logger.info(s\"My message: ${call.method} ${access.value}\")\n3) Named expression:\nscala logger.info(s\"My message: ${Some.expression -> \"argname\"}\")\n4) Invisible name expression:\nscala logger.info(s\"My message: ${Some.expression -> \"argname\" -> null}\")\n5) De-camelcased name:\nscala logger.info(${camelCaseName-> ' '})","title":"Syntax Reference"},{"location":"/logstage/index.html#dependencies","text":"// LogStage API, you need it to use the logger\nlibraryDependencies += Izumi.R.logstage_core\n\n// Optional\nlibraryDependencies ++= Seq(\n  // Json output\n  Izumi.R.logstage_rendering_circe,\n  // Router from Slf4j to LogStage\n  Izumi.R.logstage_adapter-slf4j,\n  // Configure LogStage with Typesafe Config\n  Izumi.R.logstage_config,\n  // LogStage integration with DIStage \n  Izumi.R.logstage_di,\n  // Router from LogStage to Slf4J\n  Izumi.R.logstage_sink_slf4j,\n)\nor\nval izumi_version = \"0.9.10-SNAPSHOT\"\n// LogStage API, you need it to use the logger\nlibraryDependencies += \"io.7mind.izumi\" %% \"logstage-core\" % izumi_version\n\n// optional\nlibraryDependencies ++= Seq(\n  // Json output\n  \"io.7mind.izumi\" %% \"logstage-rendering-circe\" % izumi_version,\n  // Router from Slf4j to LogStage\n  \"io.7mind.izumi\" %% \"logstage-adapter-slf4j\" % izumi_version,    \n  // Configure LogStage with Typesafe Config\n  \"io.7mind.izumi\" %% \"logstage-config\" % izumi_version,\n  // LogStage integration with DIStage \n  \"io.7mind.izumi\" %% \"logstage-di\" % izumi_version,\n  // Router from LogStage to Slf4J\n  \"io.7mind.izumi\" %% \"logstage-sink-slf4j \" % izumi_version,\n)\nIf you’re not using sbt-izumi-deps plugin.","title":"Dependencies"},{"location":"/logstage/index.html#basic-setup","text":"import logstage._\nimport logstage.circe._\n\nval jsonSink = ConsoleSink.json(prettyPrint = true)\nval textSink = ConsoleSink.text(colored = true)\n\nval sinks = List(jsonSink, textSink)\n\nval logger: IzLogger = IzLogger(Trace, sinks)\nval contextLogger: IzLogger = logger(Map(\"key\" -> \"value\"))\n\nlogger.info(\"Hey\")\n\ncontextLogger.info(s\"Hey\")","title":"Basic setup"},{"location":"/logstage/index.html#log-algebras","text":"LogIO and LogBIO algebras provide a purely-functional API for one- and two-parameter effect types respectively:\nimport logstage._\nimport cats.effect.IO\n\nval logger = IzLogger()\n// logger: IzLogger = izumi.logstage.api.IzLogger@2503b073\n\nval log = LogIO.fromLogger[IO](logger)\n// log: LogIO[IO] = logstage.LogIO$$anon$1@2d083643\n\nlog.info(s\"Hey! I'm logging with ${log}stage!\").unsafeRunSync()\nI 2019-03-29T23:21:48.693Z[Europe/Dublin] r.S.App7.res8 ...main-12:5384  (00_logstage.md:92) Hey! I'm logging with log=logstage.LogIO$$anon$1@72736f25stage!\nLogstageZIO.withFiberId provides a LogBIO instance that logs the current ZIO FiberId in addition to the thread id:\nExample:\nimport logstage.LogstageZIO\nimport zio.{IO, DefaultRuntime}\n\nval log: LogBIO[IO] = LogstageZIO.withFiberId(logger)\n// log: LogBIO[IO] = logstage.LogstageZIO$$anon$1@bf44a2\n\nval rts = new DefaultRuntime {}\n// rts: AnyRef with DefaultRuntime = repl.Session$App9$$anon$1@335bc7e\nrts.unsafeRun {\n  log.info(s\"Hey! I'm logging with ${log}stage!\")\n}\nI 2019-03-29T23:21:48.760Z[Europe/Dublin] r.S.App9.res10 ...main-12:5384  (00_logstage.md:123) {fiberId=0} Hey! I'm logging with log=logstage.LogstageZIO$$anon$1@c39104astage!\nLogIO/LogBIO algebras can be extended with custom context, same as IzLogger:\nimport cats.effect.IO\nimport cats.implicits._\nimport logstage._\nimport io.circe.Printer\nimport io.circe.syntax._\n\ndef importEntity(entity: Entity)(implicit log: LogIO[IO]): IO[Unit] = {\n  val ctxLog = log(\"ID\" -> someEntity.id, \"entityAsJSON\" -> entity.asJson.pretty(Printer.spaces2))\n\n  load(entity).handleErrorWith {\n    case error =>\n      ctxLog.error(s\"Failed to import entity: $error.\").void\n      // JSON message includes `ID` and `entityAsJSON` fields\n  }\n}","title":"Log algebras"},{"location":"/logstage/index.html#slf4j-router","text":"When not configured, logstage-adapter-slf4j will log messages with level >= Info to stdout.\nDue to the global mutable nature of slf4j to configure slf4j logging you’ll have to mutate a global singleton. To change its settings, replace its LogRouter with the same one you use elsewhere in your application.\nimport logstage._\nimport izumi.logstage.api.routing.StaticLogRouter\n\nval myLogger = IzLogger()\n// myLogger: IzLogger = izumi.logstage.api.IzLogger@26a426a3\n\n// configure SLF4j to use the same router that `myLogger` uses\nStaticLogRouter.instance.setup(myLogger.router)","title":"SLF4J Router"},{"location":"/logstage/policy.html","text":"","title":"Rendering policy ? Izumi Project"},{"location":"/logstage/policy.html#rendering-policy","text":"Rendering policy is defined in logstage config section.\nDefault template: ${level}:${ts} ${thread}${location} ${custom-ctx} ${msg}","title":"Rendering policy"},{"location":"/logstage/policy.html#log-units-specification","text":"Unit Aliases Explanation Syntax timestamp ts Timestamp ${timestamp} thread t Thread data (contains thread name and id) ${thread} level lvl Logging level ${lvl} location loc Log message location (hyperlink to filename it’s line number) ${location} message msg Application-supplied message associated with the logging event ${message} custom-ctx context, ctx User’s context (more info here) ${custom-ctx} exception ex Outputs the stack trace of the exception associated with the logging event, if any. Full stack trace will be printed by default. ${ex}","title":"Log units specification"},{"location":"/logstage/policy.html#parameters","text":"Units can be parameterized (with padding, margins, etc). NOTE! Currently there are only common parameters (padding). Parameters enumerates in [ ] braces. For example, ${message[15]}\nUnit Parameter Example ALL padding padding for log unit in result string. Can be ellipsed: [:..14] ${timestamp}[14]","title":"Parameters"},{"location":"/logstage/config.html","text":"","title":"Logstage Config ? Izumi Project"},{"location":"/logstage/config.html#logstage-config","text":"TODO Sorry, this page is not ready yet","title":"Logstage Config"},{"location":"/logstage/config.html#sample","text":"logstage {\n \n  sinks = {\n    \"default\" = {\n      path = \"foo.bar.baz.CustomSink1\"\n      params {\n        policy {\n          path = \"foo.bar.baz.CustomPolicy1\"\n          params {\n            options {\n              withExceptions = false\n              withColors = true\n            }\n          }\n        }\n      }\n    }\n    \"sink1\" = {\n      path = \"foo.bar.baz.CustomSink1\"\n      params {\n        policy {\n          path = \"foo.bar.baz.CustomPolicy1\"\n          params {\n            options {\n              withExceptions = false\n              withColors = true\n            }\n          }\n        }\n      }\n    }\n  }\n\n\n  root {\n    threshold = \"info\"\n    sinks = [\n      \"default\"\n    ]\n  }\n\n  entries = {\n    \"for.bar.*\" = \"warn\"\n    \"for.baz.*\" = {\n      threshold = \"debug\"\n      sinks = [\n        \"sink1\"\n      ]\n    }\n  }\n}","title":"Sample"},{"location":"/logstage/config.html#detailed-info","text":"Section Explanation sinks Defines used log sinks*. This section should contain default log sinks in case of ignore sinks list if you need to use only default sinks** root Defines default settings for logging (e.g., sinks and log threshold) entries Defines log entries settings (threshold and list of sinks)\nNotes:\nFor each sink you need to provide rendering policy mapper. You need to specify case class constructor for defined logsink and implement function for it’s instantiating. In sinks section you can define log sink with label default for it’s further usage on logentries definition for simplify log entries definition. For example, if you need to define only threshold level but sink can be default, you only write next:\nentries = {\n    \"target.path\" = <your_level>\n}\ninstead of common syntax:\nentries = {\n    \"target.path\" = {\n       threshold = <your_level>\n       sinks = [\"default\"]\n    }\n}","title":"Detailed info"},{"location":"/logstage/config.html#basic-setup","text":"There are two libs for logstage config. The second one depends on distage and config LogstageModule which binds logstage config\nSo, what you need to do to use logstage declarative config:\n1) include \"logstage-reference.conf\" in your application config\n2) defined next bootstrap modules :\nLogstageCodecsModule() - it will bind rendering policy and logsinks mappers and all necessary logstage runtime codecs Each RenderingPolicy and LogSink you may bind by calling follow commands inside LogstageCodecsModule:    bindLogSinkMapper[T <: LogSink : ru.TypeTag, C: ru.TypeTag](f: C => T)\n\n   bindRenderingPolicyMapper[T <: RenderingPolicy : ru.TypeTag, C: ru.TypeTag](f: C => T)\n3) defined application modules:\nLoggerConfigModule() - it makes binding of LoggerConfig and you may inject it from locator using next command:\nscala val logstageConfig = locator.get[LoggerConfig]\nLoggerConfig model is next:\n\n   ```scala\n   final case class LoggerPathConfig(threshold: Log.Level, sinks: Seq[LogSink])\n\n   final case class LoggerConfig(root : LoggerPathConfig, entries : Map[String, LoggerPathConfig])\n   ```","title":"Basic setup"},{"location":"/logstage/config.html#example","text":"Let’s define our sinks and policies 1.1 DummyLogSink scala class DummyLogSink(policy: RenderingPolicy) extends LogSink { override def flush(e: Log.Entry): Unit = { // do smth } } 1.2 DummyRenderingPolicy scala class DummyRenderingPolicy(foo: Int, bar: Option[String]) extends RenderingPolicy { override def render(entry: Log.Entry): String = entry.toString } Let’s define out logstage reference config\nlogstage {\n\n   // include izumi sdk settings\n   include \"logstage-reference.conf\"\n\n   // custom overrides \n   \n   sinks = [\n      \"default\" = {\n        path = \"path.to.DummyLogSink\"\n        params {\n          policy {\n            path = \"path.to.DummyRenderingPolicy\"\n            params {\n              foo = 1024\n              bar = \"your_string_parameter\"\n            }\n          }\n        }\n      }\n   ]\n   \n    root {\n       threshold = \"info\"\n       sinks = [\n         \"default\"\n       ]\n     }\n   \n     entries = {\n        \"path.for.debug.only.*\" = debug\n     }\n}\nSo, for now we need to specify case classes constructors for out DummyLogSink and DummyRenderingPolicy for automatic parsing 3.1 DummyRenderingPolicyConstructor scala case class DummyRenderingPolicyConstructor(foo : Int, bar: Option[String]) 3.2 DummyLogSinkConstructor scala case class DummyLogSinkConstructor(policy : RenderingPolicy) now we need to configure out DI for loggerConfigUsage 4.1 Define bootsrap module. Here you can bind all mappers for custom Policies and Logsinks: ```scala val logstageBootstrapModule = new LogstageCodecsModule {    // bind our rendering policy\n\n   bindRenderingPolicyMapper[DummyRenderingPolicy, DummyRenderingPolicyConstructor]{\n     c => \n       new DummyRenderingPolicy(c.foo, c.bar)\n   }\n\n   // bind our logsink\n\n   bindLogSinkMapper[DummyLogSink, DummyLogSinkConstructor] {\n     c =>  new DummyLogSink(c.policy)\n   }\n } val bootstrapModules = Seq(…, logstageBootstrapModule) ``` 4.2 Add LoggerConfigModule to app modules scala val modules = Seq(..., new LoggerConfigModule ()) 4.2 Enjoy! ```scala // Basic locator setup val injector = Injector(bootstapModules: _*) val plan = injector.plan(modules.toList.overrideLeft) val locator = injector.produce(plan) // retrieve binded config val cfg = locator.get[LoggerConfig] ```","title":"Example"},{"location":"/logstage/custom_ctx.html","text":"","title":"Custom Context ? Izumi Project"},{"location":"/logstage/custom_ctx.html#custom-context","text":"TODO Sorry, this page is not ready yet","title":"Custom Context"},{"location":"/sbt/index.html","text":"","title":"SBT Toolkit ? Izumi Project"},{"location":"/sbt/index.html#sbt-toolkit","text":"MOVED Moved to https://github.com/7mind/sbtgen/\nIzumi provides you a bunch of sbt plugins allowing you to significantly reduce size and increase clarity of huge multi-module builds.\nTo start using Izumi plugins add the following into your project/plugins.sbt:\nval izumi_version = \"0.9.10-SNAPSHOT\"\naddSbtPlugin(\"io.7mind.izumi\" % \"sbt-izumi\" % izumi_version)\n// This is Izumi's Bill of Materials, see below\naddSbtPlugin(\"io.7mind.izumi\" % \"sbt-izumi-deps\" % izumi_version)\nWe provide you the following kinds of plugins:\nGlobal plugins: they add some helper sbt tasks, enabled automatically, Environmental plugins: they change some aspects of sbt behavior in an opinionated way, intended to be enabled in the root project, Presets - opinionated sets of environmental plugins, Optional plugins: they provide some convenience sbt tasks, intended to be enabled manually, per-project.\nImportant notes:\nPlease keep in mind no plugins are being enabled automatically, The rest of Izumi plugins are optional. You may use a preset to activate them or combine them manually as you wish (using settings groups), Some plugins can’t be enabled globally due to sbt limitations ? they have to be enabled per-project. You should use Settings Groups in order to enable them.","title":"SBT Toolkit"},{"location":"/sbt/index.html#global-plugins","text":"Plugin Description IzumiImportsPlugin Makes all the Izumi imports visible by default","title":"Global plugins"},{"location":"/sbt/index.html#environmental-plugins","text":"Plugin Description IzumiBuildManifestPlugin Adds build info into jar manifests IzumiConvenienceTasksPlugin Devops/workflow helpers IzumiDslPlugin Compact build definitions IzumiGitStampPlugin Adds GIT status into jar manifests IzumiPropertiesPlugin Convenience helpers for sys.props IzumiResolverPlugin Better defaults for artifact resolution IzumiInheritedTestScopesPlugin Convenience helpers for test scope inheritance","title":"Environmental plugins"},{"location":"/sbt/index.html#presets","text":"Plugin Description IzumiEnvironment All the environmental plugins except of GIT one IzumiGitEnvironment All the environmental plugins with GIT one","title":"Presets"},{"location":"/sbt/index.html#optional-plugins","text":"Plugin Description IzumiExposedTestScopesPlugin Maintains test scope separation IzumiCompilerOptionsPlugin Some linting/optimization presets for scalac/javac IzumiFetchPlugin Allows you to transitively download artifacts from remote repositories IzumiPublishingPlugin Some convenience helpers and improvements for artifact publishing IzumiBuildInfoPlugin Generates sbt-compatible BOMs ? Bills of Materials","title":"Optional plugins"},{"location":"/sbt/index.html#installation","text":"To activate all the plugins add the following statements into your root project:\nenablePlugins(IzumiGitEnvironmentPlugin)\nIf you don’t use git in your project, use this preset instead:\nenablePlugins(IzumiEnvironmentPlugin)\nTo activate Comp\nval GlobalSettings = new DefaultGlobalSettingsGroup {\n  override val plugins = Set(IzumiCompilerOptionsPlugin, IzumiExposedTestScopesPlugin)\n}","title":"Installation"},{"location":"/sbt/index.html#inherited-test-scopes","text":"","title":"Inherited Test Scopes"},{"location":"/sbt/index.html#test-scope-inheritance","text":"IzumiScopesPlugin extends SBT Project with several implicit methods:\ntestOnlyRef - provides you a project reference which is equivalent to % \"test\" dependency, dependsSeq and depends - allow you to add dependencies to your project the way test scopes of your dependencies are visible within test scopes of your project. So, essentially when you use these methods your dependencies are added into your projects with the following qualifier: \"test->compile,test;it->compile,test,it\"\nYou need to activate DefaultItSettingsGroup on your projects (see “Setting Groups” below) in order to make this working on it scope.\nExample:\nlazy val myLibrary = ...\n\nlazy val myProject = (...).depends(myLibrary)\nSo, now you may use classes from the test scope of myLibrary within test scope of myProject","title":"Test Scope Inheritance"},{"location":"/sbt/index.html#test-scope-separation","text":"InheritedTestScopesPlugin works in pair with IzumiScopesPlugin and provides you an unique feature: only the classes you marked with @ExposedTestScope are being exposed to dependant artifacts.\nSo, let’s assume that:\nyou have two artifacts, Library and App, App depends on Library, In the test scope of Library you have a class named TestSuite, In the test scope of Library you have another class named TestUtil, TestUtil is annotated with @ExposedTestScope,\nin that case TestUtil will be visible in App’s test scope, but TestSuite will not be visible.\nA diagram:\n+-----------------------------------------+     +-----------------------------------------+\n| Library                                 |     | App                                     |\n|-----------------------------------------|     |-----------------------------------------|\n| Main scope                              |     | Main scope                              |\n|                                     <---+-----+--                                       |\n| UtilityClass                            |     | AppMain                                 |\n|-----------------------------------------|     |-----------------------------------------+\n| Private Test Scope | Exposed test scope |     | Test scope                              |\n|                    |                <---+-----+--                                       |\n| TestSuite          | TestUtil           |     | Private Test Scope | Exposed test scope |\n+-----------------------------------------+     +-----------------------------------------+\nNotes:\nIntellij IDEA doesn’t support overriden classpaths so when you run your tests under IDEA the whole test scopes are visible in dependencies, At the moment the implementation of @ExposedTestScope (substring presence check) is imperfect and has to be improved, Transitive dependencies are not checked, so in case you expose a class but do not expose it’s dependencies your build will work under IDEA, but you will a classloading exception under sbt. This is going to be improved in the future.","title":"Test Scope Separation"},{"location":"/sbt/index.html#test-scope-publishing","text":"The whole content of test scopes is being published by default with test qualifier. Test scope separation has no effect on test scope publishing.","title":"Test Scope Publishing"},{"location":"/sbt/index.html#settings-dsl","text":"IzumiDslPlugin comes with a DSL intended to simplify definition of complex project layouts.\nTo activate the plugin add the following statement into your root project:\nenablePlugins(IzumiDslPlugin)","title":"Settings DSL"},{"location":"/sbt/index.html#simplified-identifiers","text":"DSL provides syntax to simplify project definitions. A definition such as this:\nlazy val petstoreApp = In(\"app\").as.module\nexpands to\nlazy val petstoreApp = project.in(\"app/petstore-app\")\nYou can attach settings and dependencies to the In part, that way you can apply common settings to all the projects in a directory:\nval ApiSettings = new SettingsGroup {\n  override val plugins = Set(IdealinguaPlugin)\n}\n\nlazy val inApi = In(\"api\").settings(ApiSettings)\n\nlazy val petstoreApi = inApi.as.module\nlazy val todomvcApi = inApi.as.module","title":"Simplified Identifiers"},{"location":"/sbt/index.html#setting-groups","text":"","title":"Setting Groups"},{"location":"/sbt/index.html#global-setting-group","text":"","title":"Global Setting Group"},{"location":"/sbt/index.html#automatic-aggregation","text":"When you use .as.project or .as.module syntax to define a project, that project is stored in a global singleton.\nYou may use transitiveAggregate or transitiveAggregateSeq methods instead of standard aggregate, in that case all the transitive dependencies of the projects provided will be also added into aggregation list. This allows you to simplify your definitions by avoiding specifing all the modules in .aggregate.\nIn case you don’t want your project to be recorded, you shoud use .as.just syntax.\nImportant note: sbt is lazy! We just store project reference in a singleton list, we don’t analyze dependency graph. Though sbt relies on lazy val declarations. So, in fact the singleton initializes at the moment you invoke aggregation. In case you don’t add a project into aggregation list such a project still will be initialized by sbt and added into the singleton, but it would happen later than evaluation of aggregation list so the project will not be aggregated.","title":"Automatic Aggregation"},{"location":"/sbt/index.html#aggregation-safety-check","text":"When you invoke transitiveAggregate or transitiveAggregateSeq on your root project it checks if the accumulated set of known project is the same as the set of all projects loaded by sbt.\nIn case module is missing you’ll get a warning. This makes it unlikely for you to accidentally forget to aggregate a module in multi-module project.","title":"Aggregation Safety Check"},{"location":"/sbt/index.html#build-descriptors","text":"","title":"Build Descriptors"},{"location":"/sbt/index.html#bills-of-materials","text":"Izumi brings Bill of Materials concept to SBT.","title":"Bills of Materials"},{"location":"/sbt/index.html#izumi-bom","text":"You can import Izumi libraries and transitive dependencies without specifying their version or even artifact names. To do that add sbt-izumi-deps SBT plugin:\nval izumi_version = \"0.9.10-SNAPSHOT\"\naddSbtPlugin(\"io.7mind.izumi\" % \"sbt-izumi-deps\" % izumi_version)\nYou can use it like this:\nlibraryDependencies += Izumi.R.distage_core // Import an izumi library\nlibraryDependencies += IzumiDeps.R.cats_effect // Import a dependency of izumi\nlibraryDependencies += IzumiDeps.T.scalatest // Import a dependency of izumi in test scope\nR is for Runtime artifacts and T is for Test scope artifacts","title":"Izumi BOM"},{"location":"/sbt/index.html#create-a-bom-for-your-projects","text":"sbt-izumi-deps allows you to a create BOMs for your own projects. Just add the following snippet into your project settings:\nlazy val myProject = (project in file(\"my-project-bom\"))\n  .settings(withBuildInfo(\"com.mycompany.myproject\", \"MyProjectBOM\"))\nIf you use Izumi SBT DSL, you can use the following syntax:\nlazy val inRoot = In(\".\")\nlazy val myProjectBom = inRoot.as.module\n  .settings(withBuildInfo(\"com.mycompany.myproject\", \"MyProjectBOM\"))\nIf you want to include BOMs of you project, you can use the following syntax:\nimport com.mycompany.myproject.MyProjectBOM\n\nlazy val myLib = In(\"lib\").as.module\n  .settings(\n    libraryDependencies ++= Seq(\n      MyProjectBOM.R.my_project_bom,     // Runtime artifact\n      MyProjectBOM.T.my_project_bom,     // Runtime artifacts for test scope*\n      MyProjectBOM.TSR.my_project_bom,   // Test artifacts\n      MyProjectBOM.TST.my_project_bom,   // Test artifacts for test scope\n    )\n  )","title":"Create a BOM for your projects"},{"location":"/sbt/index.html#build-manifest-entries","text":"","title":"Build Manifest entries"},{"location":"/sbt/index.html#git-manifest-entries","text":"GitStampPlugin adds the following values into MANIFEST.MF of each jar artifact produced:\nManifest Key Description X-Git-Branch The name of branch sbt was invoked on X-Git-Repo-Is-Clean true or false, indicates if GIT repo was in clean state when the build was invoked X-Git-Head-Rev GIT revision on which sbt was invoked\nTo activate the plugin add the following statement into your root project:\nenablePlugins(GitStampPlugin)","title":"Git Manifest entries"},{"location":"/sbt/index.html#convenience-helpers","text":"","title":"Convenience Helpers"},{"location":"/sbt/index.html#stub-generators","text":"ConvenienceTasksPlugin provides you the following commands:\nnewModule <module_path/module_name> [package.suffix]: creates empty project layout at /module_path/module_name. Optional package.suffix may be specified. newStub <module_path/module_name> [stub_name:default]: copies /stubs/${stub_name} into /module_path/module_name. stub_name may be omitted, default value is default\nSetting Description ConvenienceTasksPlugin.Keys.mkJavaDirs Also adds src/*/java directories into generated stubs ConvenienceTasksPlugin.Keys.defaultStubPackage Default stub package. By default same as project’s organization","title":"Stub Generators"},{"location":"/sbt/index.html#version-suffixes","text":"ConvenienceTasksPlugin provides you command\naddVersionSuffix SUFFIX\nThis command updates project version defined in version.sbt with qualifier SUFFIX-SNAPSHOT\nExisting qualifiers will be removed. 1.0.0 would become 1.0.0-SUFFIX-SNAPSHOT 1.0.0-SNAPSHOT would become 1.0.0-SUFFIX-SNAPSHOT\nYou may need this command while setting up a build for feature branches and wish to avoid situation when different branches publishes artifacts with the same names.","title":"Version Suffixes"},{"location":"/sbt/index.html#target-preservation","text":"ConvenienceTasksPlugin provides you command\npreserveTargets SUFFIX\nThis command recursively enumerates all the directories named target and recursively copies them using name target.SUFFIX.\nYou may need this command while setting up a build where you wish to perform clean several times but want to preserve intermediate build artifacts stored in target directories. The most frequent case is coverage build followed by tests and then by production build. In this case you would like to use a command sequence like\n;clean;coverage;test;coverageOff;coverageReport;preserveTargets coverage;clean;publish","title":"target preservation"},{"location":"/sbt/index.html#directory-cleanups","text":"ConvenienceTasksPlugin provides you command\nrmDirs target.coverage\nThis command recursively removes all the directories named target.coverage across the project.\nYou may need this command to cleanup preserved target directories, or destroy some build artifacts, like rmDirs scala-2.11","title":"Directory cleanups"},{"location":"/sbt/index.html#property-readers","text":"IzumiPropertiesPlugin provides you implicit classes allowing you to convert Strings into Integers or Booleans exceptions-safe and do the same for system properties:\n\"true\".asBoolean(default = false) // true\n\"junk\".asBoolean(default = false) // false\n\"123\".asInt(default = 265) // 123\n\"junk\".asInt(default = 265) // 265\nsys.props.asBoolean(\"my.property\", default = false)\nsys.props.asInt(\"my.property\", default = 123)\nYou may activate this plugin with the following statement in root project:","title":"Property Readers"},{"location":"/sbt/index.html#transitive-artifact-downloader","text":"TODO","title":"Transitive Artifact Downloader"},{"location":"/sbt/index.html#optional-settings","text":"","title":"Optional settings"},{"location":"/sbt/index.html#publishing","text":"TODO","title":"Publishing"},{"location":"/sbt/index.html#publishing-settings","text":"TODO","title":"Publishing settings"},{"location":"/sbt/index.html#publishing-credentials-and-targets","text":"TODO","title":"Publishing credentials and targets"},{"location":"/sbt/index.html#compiler-options","text":"CompilerOptionsPlugin provides you some sane compiler option presets (linting, optimizations).\nYou should explicitly enable this plugin in each project you want to use it. When you want to enable it globally, use a settings group:\nval GlobalSettings = new SettingsGroup {\n  override val plugins = Set(\n      IzumiCompilerOptionsPlugin,\n      // ...\n  )\n  // ...\n}","title":"Compiler options"},{"location":"/sbt/index.html#resolvers","text":"ResolverPlugin turns on the following settings which should speedup your dependency resolution:\nupdateOptions := updateOptions\n  .value\n  .withCachedResolution(true)\n  .withGigahorse(true)","title":"Resolvers"},{"location":"/manifesto/index.html","text":"","title":"Productivity and challenges ? Izumi Project"},{"location":"/manifesto/index.html#productivity-and-challenges","text":"TODO Sorry, this page is not ready yet","title":"Productivity and challenges"},{"location":"/pper/index.html","text":"","title":"PPER Pattern ? Izumi Project"},{"location":"/pper/index.html#pper-pattern","text":"“Project Networks and Percept-Plan-Execute-Repeat loop to the rescue” slides: https://github.com/7mind/slides/raw/master/03-pper-basics/target/pper-base.pdf\nTODO Sorry, this page is not ready yet","title":"PPER Pattern"}]}