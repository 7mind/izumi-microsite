{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Izumi Toolkit"},{"location":"/index.html#izumi-toolkit","text":"TODO Sorry, this page is not ready yet\nGithub","title":"Izumi Toolkit"},{"location":"/index.html#dependencies","text":"To use Izumi SBT Toolkit add the follwing into project/build.sbt:\nval izumi_version = \"0.7.0-SNAPSHOT\"\n// sbt toolkit\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-izumi\" % izumi_version)\n\n// This is Izumi's BOM (Bill of Materials), see below\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-izumi-deps\" % izumi_version)\n\n// idealingua compiler (optional)\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-idealingua\" % izumi_version)\nYou can use izumi’s BOM definitions to import (from sbt-izumi-deps plugin). BOM will insert the correct version automatically:\nlibraryDependencies ++= Seq(\n  \n  // distage\n    Izumi.R.distage_core\n  , Izumi.R.distage_config // Typesafe Config support\n  , Izumi.R.distage_cats // Cats Integration\n  , Izumi.R.distage_static // Compile-time checks & reflection-less mode\n  , Izumi.R.distage_plugins // runtime Plugins support\n  , Izumi.R.distage_app  // DiApp\n  , Izumi.R.logstage_di // LogStage integration\n  \n  // LogStage\n  , Izumi.R.logstage_api_logger\n  , Izumi.R.logstage_adapter_slf4j // Route Slf4J logs to logstage\n  , Izumi.R.logstage_rendering_circe // dump structured log as JSON\n  , Izumi.R.logstage_sink_file // write to files with log rotation support\n  , Izumi.R.logstage_sink_slf4j // write to slf4j\n  \n  // Idealingua Runtime Dependencies (for use with Idealingua compiler)\n  , Izumi.R.idealingua_model\n  , Izumi.R.idealingua_runtime_rpc_http4s\n  , Izumi.R.idealingua_runtime_rpc_circe\n  , Izumi.R.idealingua_runtime_rpc_cats\n)\nAlternatively, you can use the following artifact names and versions:\nlibraryDependencies ++= Seq(\n    \"com.github.pshirshov.izumi.r2\" %% \"distage-core\" % \"0.7.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"distage-config \" % \"0.7.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"distage-cats \" % \"0.7.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"distage-static \" % \"0.7.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"distage-plugins \" % \"0.7.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"distage-app  \" % \"0.7.0-SNAPSHOT\"\n  \n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-di \" % \"0.7.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-api-logger\" % \"0.7.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-adapter-slf4j \" % \"0.7.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-rendering-circe \" % \"0.7.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-sink-console \" % \"0.7.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-sink-file \" % \"0.7.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-sink-slf4j \" % \"0.7.0-SNAPSHOT\"\n  \n  , \"com.github.pshirshov.izumi.r2\" %% \"idealingua-model\" % \"0.7.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"idealingua-runtime-rpc-http4s\" % \"0.7.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"idealingua-runtime-rpc-circe\" % \"0.7.0-SNAPSHOT\"\n  , \"com.github.pshirshov.izumi.r2\" %% \"idealingua-runtime-rpc-cats\" % \"0.7.0-SNAPSHOT\"\n)\nYou can find ScalaDoc API docs here\nYou can find Izumi on github here","title":"Dependencies"},{"location":"/idealingua/index.html","text":"","title":"IdeaLingua RPC & Domain Modeling Language ? Izumi Toolkit"},{"location":"/idealingua/index.html#idealingua-rpc-domain-modeling-language","text":"IdeaLingua is an RPC framework & Domain Modeling Language, it’s purpose is to:\nPublish APIs & data definitions in a common format and create idiomatic API clients and servers in any language. Enable remote calls to service via their public API definitions. Abstract irrelevant details such as network protocol and serialization format. Deliver our souls from REST and its brittle boilerplate.","title":"IdeaLingua RPC & Domain Modeling Language"},{"location":"/idealingua/index.html#user-service-example","text":"Example definition of a user database service:\npackage user.api\n\nenum Gender = Male | Female\n\nid EntityID {\n  uuid: uuid\n}\n\nmixin Entity {\n  id: EntityID\n}\n\nmixin Person {\n  name: str\n  surname: str\n  gender: Gender\n}\n\ndata User {\n  & Entity\n  + Person\n  password: str\n}\n\ndata PublicUser {\n  + User\n  - password: str\n}\n\nadt Result = Success | Failure\n\ndata Success {\n  message: str\n}\n\ndata Failure {\n  code: int8\n}\n\nservice UserService {\n  def saveUser(user: User): Result\n  def findUserByName(name: str): list[PublicUser] | Failure\n}","title":"User Service Example"},{"location":"/idealingua/index.html#pet-store-example","text":"See izumi-petstore for examples in Scala, TypeScript, Go, C# and other languages.","title":"Pet Store Example"},{"location":"/idealingua/index.html#installation","text":"","title":"Installation"},{"location":"/idealingua/index.html#using-sbt-plugin","text":"Add the following to your project/plugins.sbt file:\nval izumi_version = \"0.7.0-SNAPSHOT\"\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-idealingua\" % izumi_version)\nPlace your domain definitions into /src/main/izumi directory, then enable the plugin for that project. For the generated code to compile, you will also need to add dependencies on the Idealingua RTS modules:\nizumiProject\n  .enablePlugins(IdealinguaPlugin)\n  .settings(\n    libraryDependencies ++= Seq(\n        Izumi.R.idealingua_model\n      , Izumi.R.idealingua_runtime_rpc\n      , Izumi.R.idealingua_runtime_rpc_http4s\n      , Izumi.R.idealingua_runtime_rpc_circe\n    )\n  )\nYou can depend on the code generated by Idealinguain in your other Scala projects:\nproject.dependsOn(izumiProject)","title":"Using SBT Plugin"},{"location":"/idealingua/index.html#using-the-standalone-compiler","text":"The compiler executable is built as an uberjar and published on Maven Central.\nThe preferred way to install the compiler is with coursier\n# install release executable\ncoursier bootstrap com.github.pshirshov.izumi.r2:idealingua-compiler_2.12:0.7.0-SNAPSHOT -o idlc\n\n./idlc --help\nTo install snapshot:\n# install snapshot\ncoursier bootstrap -r https://oss.sonatype.org/content/repositories/snapshots/ com.github.pshirshov.izumi.r2:idealingua-compiler_2.12:0.6.0-SNAPSHOT -o idlc\n\n./idlc --help\nCommandline examples:\n./idlc -s src -t target -L scala=* -L typescript=*\n./idlc -s src -t target -L scala=-AnyvalExtension -L typescript=*","title":"Using the standalone compiler"},{"location":"/idealingua/index.html#scala-http4s-transport","text":"Most likely you will need to use Kind Projector compiler plugin and enable partial unification:\nscalacOptions += \"-Ypartial-unification\"\n\nresolvers += Resolver.sonatypeRepo(\"releases\")\n\naddCompilerPlugin(\"org.spire-math\" % \"kind-projector\" % \"0.9.6\" cross CrossVersion.binary)\nYou may find a test suite for the whole http4s pipeline here.\nPlease note that service definitons for the test suite are not generated from Idealingua definitions, you can find the Scala sources here.","title":"Scala http4s Transport"},{"location":"/idealingua/language-reference.html","text":"","title":"Idealingua Language Reference ? Izumi Toolkit"},{"location":"/idealingua/language-reference.html#idealingua-language-reference","text":"","title":"Idealingua Language Reference"},{"location":"/idealingua/language-reference.html#keywords-and-aliases","text":"Keyword Aliases Explanation domain package, namespace Namespace containing collection of entities import References a domain by id include Includes *.model file by name alias type, using Type alias enum Enumeration mixin interface Mixin, named collection of fields data dto, struct Data adt choice Algebraic Data Type id Identifier, named collection of scalars service Service interface def fn, func, fun Method","title":"Keywords and aliases"},{"location":"/idealingua/language-reference.html#inheritance-operators","text":"Keyword Aliases Explanation Example + +++, ... Inherit structure (copy fields) + Mixin & &&& Inherit interface & Mixin - --- Drop structure or field (doesn’t work for interfaces) - Mixin, - field: str","title":"Inheritance operators"},{"location":"/idealingua/language-reference.html#built-in-types","text":"","title":"Built-in types"},{"location":"/idealingua/language-reference.html#scalars","text":"Type name Aliases Explanation Scala type str string String String bool boolean, bit Boolean Boolean i08 byte, int8 8-bit integer Byte i16 short, int16 16-bit integer Short i32 int, int32 32-bit integer Int i64 long, int64 64-bit integer Long f32 float, flt Single precision floating point Float f64 double, dbl Double precision floating point Double uid uuid UUID java.util.UUID tsz dtl, datetimel Timestamp with timezone java.time.ZonedDateTime tsl dtz, datetimez Local timestamp java.time.LocalDateTime time time Time java.time.LocalTime date date Date java.time.LocalDate\nNotes:\nWhen the target language lacks a corresponding numeric type, we use the smallest type available that includes the required type. i.e. in TypeScript i08 is number When the target language lacks types for time","title":"Scalars"},{"location":"/idealingua/language-reference.html#collections","text":"Type name Explanation Scala mapping list[T] List List map[K, V] Map (only scalar and id keys are supported) Map opt[T] Optional value Option set[T] Set (unordered) Set","title":"Collections"},{"location":"/idealingua/json.html","text":"","title":"JSON Wire Format ? Izumi Toolkit"},{"location":"/idealingua/json.html#json-wire-format","text":"IdeaLingua employs a simple JSON-based wire format. To interoperate, all the language translators should implement this spec.","title":"JSON Wire Format"},{"location":"/idealingua/json.html#data-data-class","text":"data defined as:\npackage example\n\ndata User {\n  name: str\n  surname: str\n  id: uuid\n}\nShould be rendered as:\n{\n  \"name\": \"Lorem\",\n  \"surname\": \"Ipsum\",\n  \"id\": \"13bee602-521b-47c2-ad81-30527f8b2398\"\n}","title":"data: Data Class"},{"location":"/idealingua/json.html#mixin-mixin","text":"When sent over the wire, mixins include a fully qualified name of their implementation.\nmixins defined as:\npackage example\n\nmixin IntPair {\n  x: i32\n  y: i32\n}\n\ndata NamedIntPair {\n  & IntPair\n  name: str\n}\nShould be rendered as:\n{ \n  \"example.IntPair#Struct\": {\n    \"x\": 256,\n    \"y\": 512\n  }\n}\nfor the default implementation, and:\n{\n  \"example#NamedIntPair\": {\n    \"x\": 256,\n    \"y\": 512,\n    \"name\": \"Vertex\"\n  }\n}\nfor the NamedIntPair implementation.","title":"mixin: Mixin"},{"location":"/idealingua/json.html#adt-algebraic-data-type","text":"adt’s include an unqualified name of their variant.\nadt defined as:\npackage example\n\nadt AB = A | Z as B\n\ndata A {\n  value: i32\n}\n\ndata Z {\n  value: str\n}\nShould be rendered as:\n{\n  \"A\": { \n    \"value\": 1\n  }\n}\nfor the A variant, and:\n{\n  \"B\": {\n    \"value\": \"abc\"\n  }\n}\nfor the Z as B variant","title":"adt: Algebraic Data Type"},{"location":"/idealingua/json.html#id-identifier","text":"Ids are rendered as strings prefixed by type name and separated by : symbol. Field order is preserved.\nid defined as:\npackage example\n\nid UserId {\n  userId: uuid\n  companyName: str\n}\nShould be rendered as:\n\"UserId#837006c8-d070-4cde-a2dd-8999c186ef02:Lightbend\"","title":"id: Identifier"},{"location":"/idealingua/json.html#alias-type-alias","text":"Type Aliases should be rendered directly as their aliased types and should never impact serialization.","title":"alias: Type Alias"},{"location":"/idealingua/json.html#enum-enumeration","text":"Enums are rendered as strings.\nenum defined as:\npackage example\n\nenum Gender = MALE | FEMALE\nShould be rendered as:\n\"FEMALE\"","title":"enum: Enumeration"},{"location":"/idealingua/json.html#service","text":"Service outputs are always wrapped into a JSON object with one field \"value\".\nFor service defined as:\npackage example\n\nservice SayHello {\n  def sayHello(): str\n}\nsayHello method will return a result rendered as:\n{ \"value\": \"hello\" }","title":"Service"},{"location":"/idealingua/cogen.html","text":"","title":"Code generator reference ? Izumi Toolkit"},{"location":"/idealingua/cogen.html#code-generator-reference","text":"We support the following concepts:\nEnumerations Algebraic Data Types Type aliases Mixins Data Classes Identifiers Services","title":"Code generator reference"},{"location":"/idealingua/cogen.html#inheritance","text":"We support two forms of inheritance: interface inheritance (& modifier) and structural mixins (* modifier) The only difference between structural inheritance and interface inheritance is presence/absence of the base interface in the list of supertypes Both Data Classes and Mixins support both forms of inheritance Services, ADTs, Type Aliases, Identifiers and Enumerations does not support inheritance We provide widening narrowing implicit functions as well as copy constructors for all the generated entities","title":"Inheritance"},{"location":"/idealingua/cogen.html#example","text":"mixin IntPair {\n  x: i32\n  y: i32\n}\n\nmixin Metadata {\n  id: str\n  name: str\n}\n\nmixin PointLike {\n  + Metadata\n  * IntPair\n}\n\ndata Point {\n  + Metadata\n  * IntPair\n}","title":"Example"},{"location":"/idealingua/cogen.html#scala-output","text":"trait IntPair {\n  def y: Int\n  def x: Int\n}\n\ntrait Metadata {\n  def name: String\n  def id: String\n}\n\nfinal case class Point(y: Int, name: String, x: Int, id: String) extends Metadata\n\ntrait PointLike extends Metadata {\n  def y: Int\n  def x: Int\n  def name: String\n  def id: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#constructs","text":"Notes:\nAll the examples of generated code are given in minimal form Generated code for codecs, implicit conversions and type info is omitted","title":"Constructs"},{"location":"/idealingua/cogen.html#mixin-mixin","text":"mixin Person {\n   name: str\n   surname: str\n }","title":"mixin: Mixin"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Person {\n  def name: String\n  def surname: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#data-data-class","text":"Differences between Mixins and Data Classes:\nData classes cannot be subclassed Data classes are always rendered as case classes, Mixins are always rendered as pair of Interface and Implementation\ndata HumanUser {\n   + IdentifiedUser\n   * Person\n }","title":"data: Data Class"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class HumanUser(name: String, surname: String, id: UserId) extends IdentifiedUser with Person","title":"Scala output"},{"location":"/idealingua/cogen.html#adt-algebraic-data-type","text":"mixin Success {\n   values: map[str, str]\n }\n \n mixin Failure {\n   message: str\n }\n \n adt Result {\n   Success\n   Failure\n }","title":"adt: Algebraic Data Type"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Failure extends Any { def message: String }\n\ntrait Success extends Any { def values: scala.collection.immutable.Map[String, String] }\n\nsealed trait Result \n\nobject Result {\n  type Element = Result\n  \n  case class Success(value: Success) extends Result\n  case class Failure(value: Failure) extends Result\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#alias-type-alias","text":"alias UserId = str","title":"alias: Type Alias"},{"location":"/idealingua/cogen.html#scala-output","text":"package object domain01 {\ntype UserId = String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#enum-enumeration","text":"enum Gender {\n  MALE\n  FEMALE\n}","title":"enum: Enumeration"},{"location":"/idealingua/cogen.html#scala-output","text":"sealed trait Gender\n\nobject Gender {\n  type Element = Gender\n  def all: Seq[Gender] = Seq(MALE, FEMALE)\n  def parse(value: String) = value match {\n    case \"MALE\" => MALE\n    case \"FEMALE\" => FEMALE\n  }\n  case object MALE extends Gender { override def toString: String = \"MALE\" }\n  case object FEMALE extends Gender { override def toString: String = \"FEMALE\" }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#id-identifier","text":"Notes:\nYou can use only scalar builtin types for identifier fields We provide both parser and sane .toString implementation .toString uses the following format: Name#urlencoded(part1):urlencoded(part2):... Fields are sorted by name before using in parser and .toString\nid UserId {\n  value: uid\n  company: uid\n}","title":"id: Identifier"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class UserId(value: java.util.UUID, company: java.util.UUID) {\n  override def toString: String = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.company, this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"UserId#$suffix\"\n  }\n}\n\nobject UserId {\n  def parse(s: String): UserId = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    UserId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]), parsePart[java.util.UUID](parts(1), classOf[java.util.UUID]))\n  }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#service-service","text":"id RecordId {\n  value: uid\n}\n\nmixin WithRecordId {\n  id: RecordId\n}\n\nmixin WithResult {\n  result: shared.rpc#Result\n}\n\nmixin UserData {\n  email: str\n}\n\nmixin PrivateUserData {\n  balance: f64\n}\n\nservice UserService {\n  def deleteUser(WithRecordId): (WithResult)\n  def createUser(UserData, PrivateUserData): (WithRecordId, WithResult)\n}\nNotes:\nService signature cannot accept anything except of Mixins (improvements planned) ServerDispatcher allows you to route wrapped result type to an appropriate method of an abstract implementation ClientDispatcher just passes input to an abstract receiver ClientWrapper allows you to transform unwrapped method signatures into wrapping instances ServerWrapped provides you an unwrapping service implementation ServiceUnwrapped provides you a way to implement services with signatures unwrapped","title":"service: Service"},{"location":"/idealingua/cogen.html#scala-output","text":"import _root_.com.github.pshirshov.izumi.idealingua.model._\nimport _root_.com.github.pshirshov.izumi.idealingua.runtime._\n\nclass UserServiceServerDispatcher[R[+_], S <: UserService[R]](val service: S) extends transport.AbstractServerDispatcher[R, S] {\n  import UserService._\n  override def dispatch(input: UserService.InUserService): R[UserService.OutUserService] = input match {\n    case value: UserService.InDeleteUser =>\n      service.deleteUser(value)\n    case value: UserService.InCreateUser =>\n      service.createUser(value)\n  }\n}\n\nclass UserServiceClientDispatcher[R[+_], S <: UserService[R]](dispatcher: transport.AbstractClientDispatcher[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = dispatcher.dispatch(input, classOf[UserService.OutDeleteUser])\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = dispatcher.dispatch(input, classOf[UserService.OutCreateUser])\n}\n\nclass UserServiceClientWrapper[R[+_], S <: UserService[R]](val service: S) extends model.IDLClientWrapper[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser] = {\n    service.deleteUser(UserService.InDeleteUser(id = id))\n  }\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser] = {\n    service.createUser(UserService.InCreateUser(balance = balance, email = email))\n  }\n}\n\ntrait UserServiceUnwrapped[R[+_], S <: UserService[R]] extends model.IDLServiceExploded[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser]\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser]\n}\n\nclass UserServiceServerWrapper[R[+_], S <: UserService[R]](val service: UserServiceUnwrapped[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = service.deleteUser(id = input.id)\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = service.createUser(balance = input.balance, email = input.email)\n}\n\ntrait UserService[R[_]] extends com.github.pshirshov.izumi.idealingua.runtime.model.IDLService[R] {\n  import UserService._\n  override type InputType = UserService.InUserService\n  override type OutputType = UserService.OutUserService\n  \n  override def inputClass: Class[UserService.InUserService] = classOf[UserService.InUserService]\n  override def outputClass: Class[UserService.OutUserService] = classOf[UserService.OutUserService]\n  \n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser]\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser]\n}\n\nobject UserService {\n  sealed trait InUserService extends Any \n  sealed trait OutUserService extends Any\n\n  case class InDeleteUser(id: RecordId) extends UserService.InUserService with WithRecordId\n  case class OutDeleteUser(result: shared.rpc.Result) extends AnyVal with UserService.OutUserService with WithResult\n  case class InCreateUser(balance: Double, email: String) extends UserService.InUserService with UserData with PrivateUserData\n  case class OutCreateUser(result: shared.rpc.Result, id: RecordId) extends UserService.OutUserService with WithRecordId with WithResult\n}","title":"Scala output"},{"location":"/idealingua/cogen-circe.html","text":"","title":"Circe serialization reference ? Izumi Toolkit"},{"location":"/idealingua/cogen-circe.html#circe-serialization-reference","text":"","title":"Circe serialization reference"},{"location":"/idealingua/cogen-circe.html#polymorphism-and-time","text":"Notes:\nData classes cannot be polymorphic\nThe following example demonstrates how polymorphism and time values are handled:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\ntrait Polymorphic\n\nfinal case class TestPayload(\n                        zonedDateTime: ZonedDateTime = ZonedDateTime.now()\n                        , utcZonedDateTime: ZonedDateTime = ZonedDateTime.now(ZoneId.of(\"UTC\"))\n                        , localDateTime: LocalDateTime = LocalDateTime.now()\n                        , localTime: LocalTime = LocalTime.now()\n                        , localDate: LocalDate = LocalDate.now()\n                      ) extends Polymorphic\n\nobject TestPayload {\n  implicit val encodeTestPayload: Encoder[TestPayload] = deriveEncoder[TestPayload]\n  implicit val decodeTestPayload: Decoder[TestPayload] = deriveDecoder[TestPayload]\n}\n\nfinal case class AnotherPayload(message: String) extends Polymorphic\n\nobject AnotherPayload {\n  implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n  implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n}\n\nobject Polymorphic {\n    implicit val encodePolymorphic: Encoder[Polymorphic] = Encoder.instance { c =>\n    c match {\n      case v: TestPayload =>\n        Map(\"com.test#TestPayload\" -> v).asJson\n      case v: AnotherPayload =>\n        Map(\"com.test#RealPayload\" -> v).asJson\n    }\n  }\n  implicit val decodePolymorphic: Decoder[Polymorphic] = Decoder.instance(c => {\n    val fname = c.keys.flatMap(_.headOption).toSeq.head\n    val value = c.downField(fname)\n    fname match {\n      case \"com.test#TestPayload\" =>\n        value.as[TestPayload]\n      case \"com.test#RealPayload\" =>\n        value.as[AnotherPayload]\n    }\n  })\n}\n\ndef test(t: Polymorphic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Polymorphic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(TestPayload())\ntest(AnotherPayload(\"hi\"))\nThis example produces the following output:\nTestPayload:\nEncoded:\n{\"TestPayload\":{\"zonedDateTime\":\"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\"utcZonedDateTime\":\"2018-04-02T21:34:31.367744Z[UTC]\",\"localDateTime\":\"2018-04-02T22:34:31.36778\",\"localTime\":\"22:34:31.367813\",\"localDate\":\"2018-04-02\"}}\n\nParsed:\nRight({\n  \"TestPayload\" : {\n    \"zonedDateTime\" : \"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\n    \"utcZonedDateTime\" : \"2018-04-02T21:34:31.367744Z[UTC]\",\n    \"localDateTime\" : \"2018-04-02T22:34:31.36778\",\n    \"localTime\" : \"22:34:31.367813\",\n    \"localDate\" : \"2018-04-02\"\n  }\n})\n\nRestored:\nRight(Right(TestPayload(2018-04-02T22:34:31.367649+01:00[Europe/Dublin],2018-04-02T21:34:31.367744Z[UTC],2018-04-02T22:34:31.367780,22:34:31.367813,2018-04-02)))\n\n\nAnotherPayload:\nEncoded:\n{\"RealPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"RealPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Polymorphism and time"},{"location":"/idealingua/cogen-circe.html#algebraic-types","text":"Notes:\nWorks same way as polymorphic types Use short names instead of fully qualified names You may introduce a local alias for an algebraic type member: adt MyAdt { domain1.A as A1 | A}. This allows you to resolve name conflicts\nCogen example for ADTs:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\nsealed trait Algebraic\n\nobject NS1 {\n\n  case class Payload(localTime: LocalTime = LocalTime.now()) extends Algebraic\n\n  object Payload {\n    implicit val encodeTestPayload: Encoder[Payload] = deriveEncoder[Payload]\n    implicit val decodeTestPayload: Decoder[Payload] = deriveDecoder[Payload]\n  }\n\n}\n\nobject NS2 {\n\n  case class AnotherPayload(message: String) extends Algebraic\n\n  object AnotherPayload {\n    implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n    implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n  }\n\n}\nobject Algebraic {\n  implicit val encodePolymorphic: Encoder[Algebraic] = deriveEncoder[Algebraic]\n  implicit val decodePolymorphic: Decoder[Algebraic] = deriveDecoder[Algebraic]\n}\n\ndef test(t: Algebraic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Algebraic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(NS1.Payload())\ntest(NS2.AnotherPayload(\"hi\"))\nOutput:\nEncoded:\n{\"Payload\":{\"localTime\":\"18:13:31.942072\"}}\n\nParsed:\nRight({\n  \"Payload\" : {\n    \"localTime\" : \"18:13:31.942072\"\n  }\n})\n\nRestored:\nRight(Right(Payload(18:13:31.942072)))\n\nEncoded:\n{\"AnotherPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"AnotherPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Algebraic types"},{"location":"/idealingua/cogen-circe.html#identifiers","text":"Identifiers codec just invokes .toString and .parse to serialize/deserialize Identifiers.\nPlease check identifier codegen example for additional details.\nFull example:\nfinal case class CompanyId(value: java.util.UUID) {\n  override def toString: String = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"CompanyId#$suffix\"\n  }\n}\n\ntrait CompanyIdCirce {\n  import _root_.io.circe.{ Encoder, Decoder }\n  implicit val encodeCompanyId: Encoder[CompanyId] = Encoder.encodeString.contramap(_.toString)\n  implicit val decodeCompanyId: Decoder[CompanyId] = Decoder.decodeString.map(CompanyId.parse)\n}\n\nobject CompanyId extends CompanyIdCirce {\n  def parse(s: String): CompanyId = {\n    import com.github.pshirshov.izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    CompanyId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]))\n  }\n  implicit class CompanyIdExtensions(_value: CompanyId)\n}","title":"Identifiers"},{"location":"/idealingua/cogen-circe.html#enumerations","text":"Identifiers codec just invokes .toString and .parse same way as it implemented for Identifiers.","title":"Enumerations"},{"location":"/distage/index.html","text":"","title":"distage Staged Dependency Injection ? Izumi Toolkit"},{"location":"/distage/index.html#distage-staged-dependency-injection","text":"distage is a pragmatic module system for Scala that combines safety and reliability of pure FP with late binding and flexibility of runtime dependency injection frameworks such as Guice.","title":"distage Staged Dependency Injection"},{"location":"/distage/index.html#hello-world","text":"Let’s start with a simple Hello app:\nimport distage._\n\nclass Hello {\n  def hello(name: String) = println(s\"Hello $name!\")\n}\n\nobject HelloModule extends ModuleDef {\n  make[Hello]\n}\n\nobject Main extends App {\n  val injector: Injector = Injector()\n  val plan: OrderedPlan  = injector.plan(HelloModule)\n  val classes: Locator   = injector.produce(plan)\n\n  println(\"What's your name?\")\n  val name = readLine()\n  \n  classes.get[Hello].hello(name)\n}\nWe’ll break it down line-by-line:\nobject HelloModule extends ModuleDef {\n  make[Hello]\n}\nHere we define a Module for our application. A module specifies what classes to instantiate and how to instantiate them.\nBy default, distage will just call the constructor.\nIf a class’s constructor requires arguments, distage will first instantiate the arguments, then call the constructor with its dependencies fulfilled. All classes in distage are instantiated exactly once, even if multiple different classes depend on them, i.e. they’re Singletons.\nA module can be combined with another to produce a larger module via ++ and overridenBy operators. We can create a ByeModule and join it with our HelloModule:\nobject ByeModule extends ModuleDef {\n  make[Bye]\n}\n\nclass Bye {\n  def bye(name: String) = println(s\"Bye $name!\")\n}\n\nval helloBye: Module = HelloModule ++ ByeModule\nWe can override the implementation of Hello class by overriding our HelloModule with an alternative implementation:\nval uppercaseHello: Hello = \n  new Hello { \n    def hello(name: String) = s\"HELLO ${name.toUpperCase}\"\n  }\n\nobject UppercaseHelloModule extends ModuleDef {\n  make[Hello].from(uppercaseHello)  \n}\n\nval uppercaseHelloBye: Module = helloBye overridenBy uppercaseHello\nCombining modules with ++ is the main way to assemble your app together. For scenarios requiring extreme late-binding across multiple modules, you can use the Plugins mechanism to automatically discover modules from the classpath.\ndistage can check at compile-time if your app is wired correctly, If the modules typecheck, the app is guaranteed to start. See Compile-Time Checks for more details.\nLet’s go back to the code:\nobject Main extends App {\n  val injector: Injector = Injector()\n  val plan: OrderedPlan  = injector.plan(HelloModule)\nHere we create an instantation plan from the module definition. distage is staged, so instead of instantiating our definitions right away, distage first builds a pure representation of all the operations it will do and returns it back to us.\nThis allows us to easily implement additional functionality on top of distage without modifying the library. Features such as Plugins and Configurations are separate libraries, built on transforming modules and plans\nval classes: Locator   = injector.produce(plan)\n\n  println(\"What's your name?\")\n  val name = readLine()\n  \n  classes.get[Hello].hello(name)\nExecuting the plan yields us a Locator, that holds all the instantiated classes. This is where distage ends, and app’s main logic begins.\nGiven a Locator we can retrieve instances by type, call methods on them or summon them with a function:\nimport scala.util.Random\n\nclasses.run {\n  (hello: Hello, bye: Bye) =>\n    val names = Array(\"Snow\", \"Marisa\", \"Shelby\")\n    val rnd = Random.nextInt(3)\n    hello(names(rnd))\n    bye(names(rnd))\n}\nclasses.runOption {\n  i: Int => i + 10\n}.fold(println(\"I thought I had Int!\"))(println(_))","title":"Hello World"},{"location":"/distage/index.html#provider-bindings","text":"To bind a function instead of constructor use .from method in ModuleDef DSL:\ncase class HostPort(host: String, port: Int)\n\nclass HttpServer(hostPort: HostPort)\n\ntrait HttpServerModule extends ModuleDef {\n  make[HttpServer].from {\n    hostPort: HostPort =>\n      val modifiedPort = hostPort.port + 1000\n      new HttpServer(hostPort.host, modifiedPort)\n  }\n}\nTo inject named instances or config values, add annotations to lambda arguments’ types:\ntrait HostPortModule extends ModuleDef {\n  make[HostPort].from {\n    (configHost: String @ConfPath(\"http.host\"), configPort: Int @ConfPath(\"http.port\")) =>\n      HostPort(configHost, configPort)\n  }\n}\nFor further details, see scaladoc for ProviderMagnet","title":"Provider Bindings"},{"location":"/distage/index.html#multibindings-set-bindings","text":"Multibindings are useful for implementing event listeners, plugins, hooks, http routes, etc.\nTo define a multibinding use .many and .add methods in ModuleDef DSL:\nimport cats.effect._, org.http4s._, org.http4s.dsl.io._\nimport scala.concurrent.ExecutionContext.Implicits.global\nimport distage._\n\nobject HomeRouteModule extends ModuleDef {\n  many[HttpRoutes[IO]].add {\n    HttpRoutes.of[IO] { \n      case GET -> Root / \"home\" => Ok(s\"Home page!\") \n    }\n  }\n}\nMultibindings defined in different modules will be merged together into a single Set. You can summon a multibinding by type Set[_]:\nimport cats.implicits._, import org.http4s.server.blaze._, import org.http4s.implicits._\n\nobject BlogRouteModule extends ModuleDef {\n  many[HttpRoutes[IO]].add {\n    HttpRoutes.of[IO] { \n      case GET -> Root / \"blog\" / post => Ok(\"Blog post ``$post''!\") \n    }\n  }\n}\n\nclass HttpServer(routes: Set[HttpRoutes[IO]]) {\n  val router = routes.foldK\n\n  def serve = BlazeBuilder[IO]\n    .bindHttp(8080, \"localhost\")\n    .mountService(router, \"/\")\n    .start\n}\n\nval context = Injector().produce(HomeRouteModule ++ BlogRouteModule)\nval server = context.get[HttpServer]\n\nval testRouter = server.router.orNotFound\n\ntestRouter.run(Request[IO](uri = uri(\"/home\"))).flatMap(_.as[String]).unsafeRunSync\n// Home page!\n\ntestRouter.run(Request[IO](uri = uri(\"/blog/1\"))).flatMap(_.as[String]).unsafeRunSync\n// Blog post ``1''!\nFor further detail see Guice wiki on Multibindings.","title":"Multibindings / Set Bindings"},{"location":"/distage/index.html#tagless-final-style-with-distage","text":"distage works well with tagless final style. As an example, let’s take freestyle’s tagless example and make it safer and more flexible by replacing fragile wiring import ._’s with explicit modules.\nFirst, the program we want to write:\nimport cats._\nimport cats.implicits._\nimport cats.tagless._\n\nimport distage._\n\nclass Program[F[_]: TagK: Monad] extends ModuleDef {\n  make[TaglessProgram[F]]\n\n  addImplicit[Monad[F]]\n}\n\n@finalAlg\ntrait Validation[F[_]] {\n  def minSize(s: String, n: Int): F[Boolean]\n  def hasNumber(s: String): F[Boolean]\n}\n\n@finalAlg\ntrait Interaction[F[_]] {\n  def tell(msg: String): F[Unit]\n  def ask(prompt: String): F[String]\n}\n\nclass TaglessProgram[F[_]: Monad: Validation: Interaction] {\n  def program: F[Unit] = for {\n    userInput <- Interaction[F].ask(\"Give me something with at least 3 chars and a number on it\")\n    valid     <- (Validation[F].minSize(userInput, 3), Validation[F].hasNumber(userInput)).mapN(_ && _)\n    _         <- if (valid) \n                    Interaction[F].tell(\"awesomesauce!\")\n                 else \n                    Interaction[F].tell(s\"$userInput is not valid\")\n  } yield ()\n}\nTagK is distage’s analogue of TypeTag for higher-kinded types such as F[_], it allows preserving type-information at runtime for types that aren’t yet known at definition. You’ll need to add a TagK context bound to create a module parameterized by an abstract F[_]. Use Tag to create modules parameterized by non-higher-kineded types.\nInterpreters:\nimport scala.util.Try\n\nobject TryInterpreters extends ModuleDef {\n  make[Validation.Handler[Try]].from(tryValidationHandler)\n  make[Interaction.Handler[Try]].from(tryInteractionHandler)\n  \n  def tryValidationHandler = new Validation.Handler[Try] {\n    override def minSize(s: String, n: Int): Try[Boolean] = Try(s.size >= n)\n    override def hasNumber(s: String): Try[Boolean] = Try(s.exists(c => \"0123456789\".contains(c)))\n  }\n  \n  def tryInteractionHandler = new Interaction.Handler[Try] {\n    override def tell(s: String): Try[Unit] = Try(println(s))\n    override def ask(s: String): Try[String] = Try(\"This could have been user input 1\")\n  }\n}\n\nobject App extends App {\n  import cats.instances.try_._\n  // Combine modules into a full program\n  val TryProgram: Module = new Program[Try] ++ TryInterpreters\n  // run\n  Injector().produce(TryProgram).get[TaglessProgram[Try]]\n    .program\n}\nThe program module is polymorphic and abstracted from its eventual monad, we can easily parameterize it with a different monad:\nimport cats.effect.IO\n\ndef IOInterpreters = ???\nval IOProgram = new Program[IO] ++ IOInterpreters\nWe can leave it polymorphic as well:\nimport cats.effect.Sync\n\ndef SyncInterpreters[F[_]: Sync] = ???\ndef SyncProgram[F[_]: Sync] = new Program[F] ++ SyncInterpreters[F]\nOr choose different interpreters at runtime:\ndef chooseInterpreters(default: Boolean) = new Program[Try] ++ (if (default) TryInterpreters else DifferentTryInterpreters)\nModules can abstract over arbitrary kinds - use TagKK to abstract over bifunctors:\nclass BIOModule[F[_, _]: TagKK] extends ModuleDef\nUse Tag.auto.T to abstract polymorphically over any kind:\nclass MonadTransModule[F[_[_], _]: Tag.auto.T] extends ModuleDef\nclass TrifunctorModule[F[_, _, _]: Tag.auto.T] extends ModuleDef\nclass EldritchModule[F[_, _[_, _], _[_[_, _], _], _, _[_[_[_]]], _, _]: Tag.auto.T] extends ModuleDef\nconsult HKTag docs for more details","title":"Tagless Final Style with distage"},{"location":"/distage/index.html#plugins","text":"Plugins are a distage extension that allows you to automatically pick up all Plugin modules that are defined in specified package on the classpath.\nPlugins are especially useful in scenarios with extreme late-binding, when the list of loaded application modules is not known ahead of time. Plugins are compatible with compile-time checks as long as they’re defined in a separate module.\nTo use plugins add distage-plugins library:\nlibraryDependencies += Izumi.R.distage_plugins\nor\nlibraryDependencies += \"com.github.pshirshov.izumi.r2\" %% \"distage-plugins\" % \"0.7.0-SNAPSHOT\"\nIf you’re not using sbt-izumi-deps plugin.\nCreate a module extending the PluginDef trait instead of ModuleDef:\npackage com.example.petstore\n\nimport distage._\nimport distage.plugins._\n\ntrait PetStorePlugin extends PluginDef {\n  make[PetRepository]\n  make[PetStoreService]\n  make[PetStoreController]\n}\nAt your app entry point use a plugin loader to discover all PluginDefs:\nval pluginLoader = new PluginLoaderDefaultImpl(\n  PluginConfig(\n    debug = true\n    , packagesEnabled = Seq(\"com.example.petstore\") // packages to scan\n    , packagesDisabled = Seq.empty         // packages to ignore\n  )\n)\n\nval appModules: Seq[PluginBase] = pluginLoader.load()\nval app: ModuleBase = appModules.merge\nLaunch as normal with the loaded modules:\nInjector().produce(app).get[PetStoreController].run\nPlugins also allow a program to extend itself at runtime by adding new Plugin classes to the classpath via java -cp","title":"Plugins"},{"location":"/distage/index.html#compile-time-checks","text":"TODO Sorry, this page is not ready yet Relevant ticket: https://github.com/pshirshov/izumi-r2/issues/51\nAs of now, an experimental plugin-checking API is available in distage-app module.\nTo use it add distage-app library:\nlibraryDependencies += Izumi.R.distage_app\nor\nlibraryDependencies += \"com.github.pshirshov.izumi.r2\" %% \"distage-app\" % \"0.7.0-SNAPSHOT\"\nYou can participate in this ticket at https://github.com/pshirshov/izumi-r2/issues/51\nIf you’re not using sbt-izumi-deps plugin.\nOnly plugins defined in a different module can be checked at compile-time, test scope counts as a different module.","title":"Compile-Time Checks"},{"location":"/distage/index.html#example-","text":"In main scope:\n// src/main/scala/com/example/AppPlugin.scala\npackage com.example\nimport distage._\nimport distage.plugins._\nimport distage.config._\nimport com.github.pshirshov.izumi.distage.app.ModuleRequirements\n\nfinal case class HostPort(host: String, port: Int)\n\nfinal case class Config(hostPort: HostPort)\n\nfinal class Service(conf: Config @ConfPath(\"config\"), otherService: OtherService)\n\n// OtherService class is not defined here, even though Service depends on it\nfinal class AppPlugin extends PluginDef {\n  make[Service]\n}\n\n// Declare OtherService as an external dependency\nfinal class AppRequirements extends ModuleRequirements(\n  // If we remove this line, compilation will rightfully break\n  Set(DIKey.get[OtherService])\n)\nIn config:\n// src/main/resources/application.conf\n// We are going to check if our starting configuration is correct as well.\nconfig {\n  // If we remove these, the compilation will rightfully break, as the `HostPort` case class won't deserialize from the config\n  host = localhost\n  port = 8080\n}\nIn test scope:\n// src/test/scala/com/example/test/AppPluginTest.scala\npackage com.example.test\n\nimport com.example._\nimport org.scalatest.WordSpec\nimport com.github.pshirshov.izumi.distage.app.StaticPluginChecker\n\nfinal class AppPluginTest extends WordSpec {\n  \n  \"App plugin will work (if OtherService will be provided later)\" in {\n    StaticPluginChecker.checkWithConfig[AppPlugin, AppRequirements](disableTags = \"\", configFileRegex = \"*.application.conf\")   \n  }\n\n}\ncheckWithConfig will run at compile-time, every time that AppPluginTest is recompiled.\nYou can participate in this ticket at https://github.com/pshirshov/izumi-r2/issues/51","title":"Example:"},{"location":"/distage/index.html#compile-time-instantiation","text":"TODO Sorry, this page is not ready yet\n…","title":"Compile-Time Instantiation"},{"location":"/distage/index.html#config-files","text":"distage-config library parses typesafe-config into arbitrary case classes or sealed traits and makes them available for summoning as a class dependency.\nTo use it, add distage-config library:\nlibraryDependencies += Izumi.R.distage_config\nor\nlibraryDependencies += \"com.github.pshirshov.izumi.r2\" %% \"distage-config\" % \"0.7.0-SNAPSHOT\"\nIf you’re not using sbt-izumi-deps plugin.\nWrite a config in HOCON format:\n# resources/application.conf\nprogram {\n    config {\n        different = true\n    }\n}\nAdd ConfigModule into your injector:\nimport distage.config._\nimport com.typesafe.config.ConfigFactory\n\nval config = ConfigFactory.load()\n\nval injector = Injector(new ConfigModule(AppConfig(config)))\nNow you can automatically parse config entries into case classes and can summon them from any class:\nfinal case class Config(different: Boolean)\n\nclass ConfiguredTaglessProgram[F](\n  @ConfPath(\"program.config\") config: Config,\n  @Id(\"primary\") primaryProgram: TaglessProgram[F],\n  @Id(\"different\") differentProgram: TaglessProgram[F]) {\n\n    val program = if (config.different) differentProgram else primaryProgram\n}\n\nclass ConfiguredTryProgram[F[_]: TagK: Monad] extends ModuleDef {\n  make[ConfiguredProgram[F]]\n  make[TaglessProgram[F]].named(\"primary\")\n  make[TaglessProgram[F]].named(\"different\")\n}","title":"Config files"},{"location":"/distage/index.html#inner-classes-and-path-dependent-types","text":"To instantiate path-dependent types via constructor, their prefix type has to be present in DI context:\ntrait Path {\n  class A\n  class B\n}\n\nval path = new Path {}\n\nval module = new ModuleDef {\n  make[path.A]\n  make[path.type].from(path.type: path.type)\n}\nThe same applies to type projections:\nval module1 = new ModuleDef {\n  make[Path#B]\n  make[Path].from(new Path {})\n}\nProvider and instance bindings and also compile-time mode in distage-static module do not require the singleton type prefix to be present in DI context:\nval module2 = new ModuleDef {\n  make[Path#B].from {\n    val path = new Path {}\n    new path.B\n  }\n}","title":"Inner Classes and Path-Dependent Types"},{"location":"/distage/index.html#implicits-injection","text":"TODO Sorry, this page is not ready yet Relevant ticket: https://github.com/pshirshov/izumi-r2/issues/230\nImplicits are managed like any other class, to make them available for summoning, declare them inside a module:\nimport cats.Monad\nimport distage._\nimport scalaz.zio.IO\nimport scalaz.zio.interop.catz._\n\nobject IOMonad extends ModuleDef {\n  addImplicit[Monad[IO[Throwable, ?]]]\n  // same as make[Monad[IO[Throwable, ?]]].from(implicitly[Monad[IO[Throwable, ?]]])\n}\nImplicits for wired classes are injected from DI context, not from surrounding lexical scope. If they were captured from lexical scope when the module is defined, then any binding of a class that depends on an implicit, would have to import an implementation of that implicit. Depending on implementations is unmodular and directly contradicts the idea of using a dedicated module system in the first place:\nimport cats._\nimport distage._\n\nclass KVStore[F[_]: Monad, V] {\n  def fetch(key: String): F[V]\n}\n\nval kvstoreModule = new ModuleDef {\n  // We DON'T want this import to be necessary\n  // import cats.instances.either._\n\n  make[KVStore[Either[Error, ?]].from[KVStoreEitherImpl]\n}\n\n// Instead, specify implicits explicitly\nval eitherMonadModule = new ModuleDef {\n  // Ok to import here\n  import cats.instances.either._\n  \n  addImplicit[Monad[Either[Error, ?]]]\n}\n\nval all = kvstoreMOdule ++ eitherMonadModule\nImplicits obey the usual lexical scope outside of modules managed by distage.\nYou can participate in this ticket at https://github.com/pshirshov/izumi-r2/issues/230","title":"Implicits Injection"},{"location":"/distage/index.html#monadic-effects-instantiation","text":"TODO Sorry, this page is not ready yet Relevant ticket: https://github.com/pshirshov/izumi-r2/issues/331\nExample of explicitly splitting effectful and pure instantiations:\nimport cats._\nimport cats.implicits._\nimport distage._\nimport distage.config._\nimport com.typesafe.config.ConfigFactory\n\nimport scala.concurrent.{Await, Future}\nimport scala.concurrent.duration.Duration\nimport scala.concurrent.ExecutionContext.global\n\ncase class DbConf()\ncase class MsgQueueConf()\ncase class RegistryConf()\n\nclass DBService[F[_]]\nclass MsgQueueService[F[_]]\nclass RegistryService[F[_]]\n\nclass DomainService[F[_]: Monad]\n( dbService: DBService[F]\n, msgQueueService: MsgQueueService[F]\n, registryService: RegistryService[F]\n) {\n  def run: F[Unit] = Monad[F].unit\n}\n\nclass ExternalInitializers[F[_]: TagK: Monad] extends ModuleDef {\n  make[F[DBService[F]]].from { \n    dbConf: DbConf @ConfPath(\"network-service.db\") => new DBService[F]().pure[F] \n  }\n  make[F[MsgQueueService[F]]].from { \n    msgQueueConf: MsgQueueConf @ConfPath(\"network-service.msg-queue\") => new MsgQueueService[F]().pure[F] \n  }\n  make[F[RegistryService[F]]].from { \n    registryConf: RegistryConf @ConfPath(\"network-service.registry\") => new RegistryService[F]().pure[F]\n  }\n}\n\nval injector = Injector(new ConfigModule(AppConfig(ConfigFactory.load())))\nval monadicActionsLocator = injector.produce(new ExternalInitializers[Future])\n\nval main: Future[Unit] = monadicActionsLocator.run {\n  ( dbF: Future[DBService[Future]]\n  , msgF: Future[MsgQueueService[Future]]\n  , regF: Future[RegistryService[Future]]\n  ) => for {\n    db <- dbF\n    msg <- msgF\n    reg <- regF\n\n    externalServicesModule = new ModuleDef {\n      make[DBService[Future]].from(db)\n      make[MsgQueueService[Future]].from(msg)\n      make[RegistryService[Future]].from(reg)\n    }\n\n    domainServiceModule = new ModuleDef {\n      make[DomainService[Future]]\n    }\n\n    allServices = injector.produce(externalServicesModule ++ domainServiceModule)\n\n    _ <- allServices.get[DomainService[Future]].run\n  } yield ()\n}\n\nAwait.result(main, Duration.Inf)\nSide-effecting instantiation is not recommended in general ? ideally, resources and lifetimes should be managed outside of distage. A rule of thumb is: if a class and its dependencies are stateless, and can be replaced by a global object, it’s ok to inject them with distage. However, distage does provide helpers to help manage lifecycle, see: Auto-Sets, closing all AutoCloseables\nYou can participate in this ticket at https://github.com/pshirshov/izumi-r2/issues/331","title":"Monadic effects instantiation"},{"location":"/distage/index.html#auto-traits-auto-factories","text":"TODO Sorry, this page is not ready yet\n…","title":"Auto-Traits & Auto-Factories"},{"location":"/distage/index.html#import-materialization","text":"TODO Sorry, this page is not ready yet\n…","title":"Import Materialization"},{"location":"/distage/index.html#depending-on-locator","text":"Classes can depend on the Locator:\nimport distage._\n\nclass A(all: LocatorRef) {\n  def c = all.get.get[C]\n}\nclass B\nclass C\n\nval module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n\nval locator = Injector().produce(module)\n\nassert(locator.get[A].c eq locator.get[C])\nIt’s recommended to avoid this if possible, doing so is often a sign of broken application design.","title":"Depending on Locator"},{"location":"/distage/index.html#ensuring-service-boundaries-using-api-modules","text":"…","title":"Ensuring service boundaries using API modules"},{"location":"/distage/index.html#roles","text":"TODO Sorry, this page is not ready yet\n“Roles” are a pattern of multi-tenant applications, in which multiple separate microservices all reside within a single .jar. This strategy helps cut down development, maintenance and operations costs associated with maintaining fully separate code bases and binaries. The apps that should be launched are chosen by command-line parameters: ./launcher app1 app2 app3. When launching less apps than are available in the launcher - ./launcher app1, redundant components will be collected by the garbage collector and won’t be started.\nRoles: a viable alternative to Microservices:\nhttps://github.com/7mind/slides/blob/master/02-roles/target/roles.pdf","title":"Roles"},{"location":"/distage/index.html#test-kit","text":"distage-testkit module provides integration with scalatest:\nlibraryDependencies += Izumi.R.distage_testkit\nor\nlibraryDependencies += \"com.github.pshirshov.izumi.r2\" %% \"distage-plugins\" % \"0.7.0-SNAPSHOT\"\nIf you’re not using sbt-izumi-deps plugin.\nExample usage:\nimport distage._\nimport com.github.pshirshov.izumi.distage.testkit.DistageSpec\n\nclass TestClass {\n  def hello: String = \"Hello World!\"\n}\n\nclass Test extends DistageSpec {\n  override protected def makeBindings: ModuleBase = new ModuleDef {\n    make[TestClass]\n  }\n\n  \"TestClass\" should {\n\n    \"Say hello\" in di {\n      testClass: TestClass =>\n        assert(testClass.hello == \"Hello World!\")\n    }\n\n  }\n}","title":"Test Kit"},{"location":"/distage/index.html#using-garbage-collector","text":"A garbage collector is included in distage, but has to be enabled explicitly:\nimport distage._\n\nclass Main\n\n// Designate `Main` class as the garbage collection root\nval roots = Seq(DIKey.get[Main])\n\n// Enable GC\nval gcModule = new TracingGCModule(roots)\nval injector = Injector(gcModule)\nGC will remove all bindings that aren’t transitive dependencies of the chosen GC root keys from the plan - they will never be instantiated.\nIn the following example:\nimport distage._\n\ncase class A(b: B)\ncase class B()\ncase class C() {\n  println(\"C!\")\n}\n\nval module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n\nval roots = Seq(DIKey.get[A])\n\nval locator = Injector(new TracingGCModule(roots)).produce(module)\n\nlocator.find[A]\n// res0: Option[A] = Some(A(B()))\nlocator.find[B]\n// res1: Option[B] = Some(B())\nlocator.find[C]\n// res2: Option[C] = None\nClass C is removed because it wasn’t dependent on by classes B or A. It’s not present in the Locator and the \"C!\" message was never printed. If class B were to depend on C as in case class B(c: C), it would’ve been retained, because A which is the GC root, would’ve depended on B which in turns depends on C.\nGC serves two important purposes: * it enables faster tests by omitting unneeded instantiations, * and it enables multiple separate applications, “Roles” to be hosted within a single .jar.","title":"Using Garbage Collector"},{"location":"/distage/index.html#circular-dependencies-support","text":"distage automatically resolves circular dependencies, including self-reference:\nimport distage._\n\ncase class A(b: B)\ncase class B(a: A) \ncase class C(c: C)\n\nval locator = Injector().produce(new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n})\n\nlocator.get[A] eq locator.get[B].a\n// res0: Boolean = true\nlocator.get[B] eq locator.get[A].b\n// res1: Boolean = true\nlocator.get[C] eq locator.get[C].c\n// res2: Boolean = true","title":"Circular Dependencies support"},{"location":"/distage/index.html#automatic-resolution-with-generated-proxies","text":"The above strategy depends on distage-proxy-cglib module which is brought in by default with distage-core.\nIt’s enabled by default. If you want to disable it, use noCogen bootstrap environment:\nimport com.github.pshirshov.izumi.distage.bootstrap.DefaultBootstrapContext\nimport distage._\n\nInjector(DefaultBootstrapContext.noCogen)","title":"Automatic Resolution with generated proxies"},{"location":"/distage/index.html#manual-resolution-with-by-name-parameters","text":"Most cycles can also be resolved manually when identified, using by-name parameters.\nCircular dependencies in the following example are all resolved via Scala’s native by-name’s, without any proxy generation:\nimport com.github.pshirshov.izumi.distage.bootstrap.DefaultBootstrapContext.noCogen\nimport distage._\n\nclass A(b0: => B) {\n  def b: B = b0\n}\n\nclass B(a0: => A) {\n  def a: A = a0\n}\n\nclass C(self: => C) {\n  def c: C = self\n}\n\nval module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n\nval locator = Injector(noCogen).produce(module)\n\nassert(locator.get[A].b eq locator.get[B])\nassert(locator.get[B].a eq locator.get[A])\nassert(locator.get[C].c eq locator.get[C])\nThe proxy generation via cglib is still enabled by default, because in scenarios with extreme late-binding, cycles can emerge unexpectedly, outside of control of the origin module.","title":"Manual Resolution with by-name parameters"},{"location":"/distage/index.html#auto-sets-collecting-bindings-by-predicate","text":"AutoSet Planner Hooks traverse the class graph and collect all classes matching a predicate.\nUsing Auto-Sets, one can, for example, collect all AutoCloseable classes and .close() them after the application has finished work.\nNote: it’s not generally recommended to construct stateful, effectful or resource-allocating classes with distage, a general rule of thumb is: if a class and its dependencies are stateless and can be replaced by a global object, it’s ok to inject them with distage. However, an example is given anyway, as a lot of real applications depend on global resources, such as JDBC connections, ExecutionContext thread pools, Akka Systems, etc. that should be closed properly at exit.\nimport java.util.concurrent.{ExecutorService, Executors}\n\nimport com.github.pshirshov.izumi.distage.model.planning.PlanningHook\nimport com.github.pshirshov.izumi.distage.planning.AssignableFromAutoSetHook\nimport distage._\n\nval threadPoolModule = new ModuleDef {\n  make[ExecutorService].from(Executors.newWorkStealingPool())\n  make[ExecutionContext].from {\n    es: ExecutorService =>\n      ExecutionContext.fromExecutorService(es)\n  }\n}\n\n// A hook that collects every instance of a subtype of a given type\nval collectAllExecutorServicesHook = new AssignableFromAutoSetHook[ExecutorService]\n\nval bootstrapModule = new BootstrapModuleDef {\n  many[PlanningHook]\n    .add(collectAllExecutorServicesHook)\n}\n\nval injector = Injector(bootstrapModule)\n\nval locator = injector.produce(threadPoolModule)\n\ntry {\n  // run the app\n  ???\n} finally {\n  // when done, close thread pools\n  val allExecutors = locator.get[Set[ExecutorService]]\n  // Auto-set return ordered Set, in order of dependency\n  // To start resources, execute actions in order\n  // To close resources, execute actions in *reverse* order\n  allExecutors.reverse.foreach(_.shutdownNow())\n}\nAuto-Sets preserve ordering, they use ListSet under the hood, unlike user-defined Sets. Calling .foreach on an auto-set is safe; the actions will be executed in order of dependencies: i.e. if C depends on B depends on A, autoset order is: A, B, C, to start: A -> B -> C, to close: C -> B -> A When you use auto-sets for finalization, you must .reverse the autoset\ntrait PrintResource(name: String) {\n  def start(): Unit = println(s\"$name started\")\n  def stop(): Unit = println(s\"$name stopped\")\n}\nclass A extends Resource(\"A\")\nclass B(val a: A) extends Resource(\"B\")\nclass C(val b: B) extends Resource(\"C\")\n\nval resources = Injector(new BootstraModuleDef {\n  many[PlanningHook]\n    .add(new AssignableFromAutoSetHook[Resource])\n}).produce(new ModuleDef {\n  make[C]\n  make[B]\n  make[A]\n}).get[Set[Resource]]\n\nresources.foreach(_.start())\nresources.reverse.foreach(_.stop())\n\n// Will print:\n// A started\n// B started\n// C started\n// C stopped\n// B stopped\n// A stopped\nNB: Auto-Sets are NOT subject to Garbage Collection, they are assembled after garbage collection is done, as such they can’t contain garbage by construction.","title":"Auto-Sets: Collecting Bindings By Predicate"},{"location":"/distage/index.html#weak-sets","text":"Sets (aka Multibindings) can contain weak references. Elements designated as weak will not be retained by the Garbage Collector if they are not referenced outside of the set.\nExample:\nimport distage._\n\nsealed trait SetElem\n\nfinal class Strong extends SetElem {\n  println(\"Strong constructed\")\n}\n\nfinal class Weak extends SetElem {\n  println(\"Weak constructed\")\n}\n\nval module = new ModuleDef {\n  make[Strong]\n  make[Weak]\n  \n  many[SetElem]\n    .ref[Strong]\n    .weak[Weak]\n}\n\n// Designate Set[SetElem] as the garbage collection root,\n// everything that Set[SetElem] does not strongly depend on will be garbage collected\n// and will not be constructed. \nval roots = Seq(DIKey.get[Set[SetElem]])\n\n// Enable GC\nval gcModule = new TracingGCModule(roots)\nval injector = Injector(gcModule)\n\nval locator = injector.produce(roots)\n// Strong constructed!\n\nassert(locator.get[Set[SetElem]].size == 1)\nThe Weak class was not required in any dependency of Set[SetElem], so it was pruned. The Strong class remained, because the reference to it was strong, therefore it was counted as a dependency of Set[SetElem]\nHad we changed Strong to depend on the Weak, the Weak would be retained:\nfinal class Strong(weak: Weak) {\n  println(\"Strong constructed\")\n}\n\nassert(locator.get[Set[SetElem]].size == 2)","title":"Weak Sets"},{"location":"/distage/index.html#debugging-introspection-diagnostics-and-hooks","text":"You can print a plan to get detailed info on what will happen during instantiation. The printout includes file:line info so your IDE can show you where the binding was defined!\nSystem.err.println(plan: OrderedPlan)\nYou can also query a plan to see the dependencies and reverse dependencies of a class and their instantiation:\n// Print dependencies\nSystem.err.println(plan.topology.dependencies.tree(DIKey.get[Circular1]))\n// Print reverse dependencies\nSystem.err.println(plan.topology.dependees.tree(DIKey.get[Circular1]))\nThe printer highlights circular dependencies.\nDistage also uses some macros, macros are currently used to create TagKs and provider bindings. If you think they’ve gone awry, you can turn macro debug output during compilation by setting -Dizumi.distage.debug.macro=true java property:\nsbt -Dizumi.distage.debug.macro=true compile\nMacros power distage-static module, an alternative backend that does not use JVM runtime reflection to instantiate classes and auto-traits.","title":"Debugging, Introspection, Diagnostics and Hooks"},{"location":"/distage/index.html#extensions-and-plan-rewriting-writing-a-distage-extension","text":"…","title":"Extensions and Plan Rewriting - writing a distage extension"},{"location":"/distage/index.html#migrating-from-guice","text":"…","title":"Migrating from Guice"},{"location":"/distage/index.html#migrating-from-macwire","text":"…","title":"Migrating from MacWire"},{"location":"/distage/index.html#integrations","text":"…","title":"Integrations"},{"location":"/distage/index.html#cats","text":"To import cats integration add distage-cats library:\nlibraryDependencies += Izumi.R.distage_cats\nor\nlibraryDependencies += \"com.github.pshirshov.izumi.r2\" %% \"distage-cats\" % \"0.7.0-SNAPSHOT\"\nIf you’re not using sbt-izumi-deps plugin.\nUsage:\nimport cats.implicits._\nimport cats.effect._\nimport distage._\nimport distage.interop.cats._\nimport com.example.{DBConnection, AppEntrypoint}\n\nobject Main extends IOApp {\n  def run(args: List[String]): IO[Unit] = {\n    val myModules = module1 |+| module2 // Monoid instance for ModuleDef is available now\n    \n    for {\n      plan <- myModules.resolveImportsF[IO] { // resolveImportsF is now available\n        case i if i.target == DIKey.get[DBConnection] =>\n           DBConnection.create[IO]\n      } \n      classes <- Injector().produceIO[IO](plan) // produceIO is now available\n      _ <- classes.get[AppEntrypoint].run\n    } yield ()\n  }\n}","title":"Cats"},{"location":"/distage/index.html#scalaz","text":"","title":"Scalaz"},{"location":"/distage/index.html#zio","text":"","title":"ZIO"},{"location":"/distage/index.html#freestyle","text":"","title":"Freestyle"},{"location":"/distage/index.html#eff","text":"","title":"Eff"},{"location":"/distage/index.html#pper","text":"See PPER Overview","title":"PPER"},{"location":"/logstage/index.html","text":"","title":"LogStage ? Izumi Toolkit"},{"location":"/logstage/index.html#logstage","text":"LogStage is a zero-cost structural logging framework.\nKey features:\nLogStage extracts structure from ordinary string interpolations in your log messages with zero changes to code. LogStage uses macros to extract log structure, its faster at runtime than typical reflective structural logging frameworks, Log contexts Console, File and SLF4J sinks included, File sink supports log rotation, Human-readable output and JSON output included, Method-level logging granularity. Can configure methods com.example.Service.start and com.example.Service.doSomething independently, Slf4J adapters: route legacy Slf4J logs into LogStage router","title":"LogStage"},{"location":"/logstage/index.html#overview","text":"The following snippet:\nclass ExampleService(logger: IzLogger) {\n  val justAnArg = \"example\"\n  val justAList = List[Any](10, \"green\", \"bottles\")\n\n  logger.trace(s\"Argument: $justAnArg, another arg: $justAList\")\n  logger.info(s\"Named expression: ${Random.nextInt() -> \"random number\"}\")\n  logger.warn(s\"Invisible argument: ${Random.nextInt() -> \"random number\" -> null}\")\n\n  val ctxLogger = logger(\"userId\" -> \"user@google.com\", \"company\" -> \"acme\")\n  val delta = Random.nextInt(1000)\n\n  ctxLogger.info(s\"Processing time: $delta\")\n}\nWill look like this in string form:\nAnd like this in JSON:\nNote:\nJSON formatter is type aware! Each JSON message contains @class field with holds a unique event class identifier. All events produced by the same source code line will share the same event class.","title":"Overview"},{"location":"/logstage/index.html#dependencies","text":"libraryDependencies += Izumi.R.logstage_core\n\nlibraryDependencies ++= Seq(\n  // file sink\n  Izumi.R.logstage_sink_file\n  // json output\n  , Izumi.R.logstage_rendering_circe\n  // router from Slf4j to LogStage\n  , Izumi.R.logstage_adapter-slf4j\n)\nor\nval izumi_version = \"0.7.0-SNAPSHOT\"\n// LogStage API, you need it to use the logger\nlibraryDependencies += \"com.github.pshirshov.izumi.r2\" %% \"logstage-core\" % izumi_version\n\n// LogStage machinery\nlibraryDependencies ++= Seq(\n  // file sink\n  \"com.github.pshirshov.izumi.r2\" %% \"logstage-sink-file\" % izumi_version\n  // json output\n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-rendering-circe\" % izumi_version\n  // router from Slf4j to LogStage\n  , \"com.github.pshirshov.izumi.r2\" %% \"logstage-adapter-slf4j\" % izumi_version    \n)\nIf you’re not using sbt-izumi-deps plugin.","title":"Dependencies"},{"location":"/logstage/index.html#basic-setup","text":"import logstage._\nimport logstage.circe._\n\nval jsonSink = ConsoleSink.json(prettyPrint = true)\nval textSink = ConsoleSink.text(colored = true)\n\nval sinks = List(jsonSink, textSink)\n\nval logger: IzLogger = IzLogger(Trace, sinks)\nval contextLogger: IzLogger = logger(Map(\"key\" -> \"value\"))\n\nlogger.info(\"Hey\")\n// Hey; @type=const\n\ncontextLogger.info(s\"Hey\")\n// {key=value} Hey","title":"Basic setup"},{"location":"/logstage/policy.html","text":"","title":"Rendering policy ? Izumi Toolkit"},{"location":"/logstage/policy.html#rendering-policy","text":"Rendering policy is defined in logstage config section.\nDefault template: ${level}:${ts} ${thread}${location} ${custom-ctx} ${msg}","title":"Rendering policy"},{"location":"/logstage/policy.html#log-units-specification","text":"Unit Aliases Explanation Syntax timestamp ts Timestamp ${timestamp} thread t Thread data (contains thread name and id) ${thread} level lvl Logging level ${lvl} location loc Log message location (hyperlink to filename it’s line number) ${location} message msg Application-supplied message associated with the logging event ${message} custom-ctx context, ctx User’s context (more info here) ${custom-ctx} exception ex Outputs the stack trace of the exception associated with the logging event, if any. Full stack trace will be printed by default. ${ex}","title":"Log units specification"},{"location":"/logstage/policy.html#parameters","text":"Units can be parameterized (with padding, margins, etc). NOTE! Currently there are only common parameters (padding). Parameters enumerates in [ ] braces. For example, ${message[15]}\nUnit Parameter Example ALL padding padding for log unit in result string. Can be ellipsed: [:..14] ${timestamp}[14]","title":"Parameters"},{"location":"/logstage/config.html","text":"","title":"Logstage Config ? Izumi Toolkit"},{"location":"/logstage/config.html#logstage-config","text":"TODO Sorry, this page is not ready yet","title":"Logstage Config"},{"location":"/logstage/config.html#sample","text":"logstage {\n \n  sinks = {\n    \"default\" = {\n      path = \"foo.bar.baz.CustomSink1\"\n      params {\n        policy {\n          path = \"foo.bar.baz.CustomPolicy1\"\n          params {\n            options {\n              withExceptions = false\n              withColors = true\n            }\n          }\n        }\n      }\n    }\n    \"sink1\" = {\n      path = \"foo.bar.baz.CustomSink1\"\n      params {\n        policy {\n          path = \"foo.bar.baz.CustomPolicy1\"\n          params {\n            options {\n              withExceptions = false\n              withColors = true\n            }\n          }\n        }\n      }\n    }\n  }\n\n\n  root {\n    threshold = \"info\"\n    sinks = [\n      \"default\"\n    ]\n  }\n\n  entries = {\n    \"for.bar.*\" = \"warn\"\n    \"for.baz.*\" = {\n      threshold = \"debug\"\n      sinks = [\n        \"sink1\"\n      ]\n    }\n  }\n}","title":"Sample"},{"location":"/logstage/config.html#detailed-info","text":"Section Explanation sinks Defines used log sinks*. This section should contain default log sinks in case of ignore sinks list if you need to use only default sinks** root Defines default settings for logging (i.e., sinks and log threshold) entries Defines log entries settings (threshold and list of sinks)\nNotes:\nFor each sink you need to provide rendering policy mapper. You need to specify case class constructor for defined logsink and implement function for it’s instantiating. In sinks section you can define log sink with label default for it’s further usage on logentries definition for simplify log entries definition. For example, if you need to define only threshold level but sink can be default, you only write next:\nentries = {\n    \"target.path\" = <your_level>\n}\ninstead of common syntax:\nentries = {\n    \"target.path\" = {\n       threshold = <your_level>\n       sinks = [\"default\"]\n    }\n}","title":"Detailed info"},{"location":"/logstage/config.html#basic-setup","text":"There are two libs for logstage config. The second one depends on distage and config LogstageModule which binds logstage config\nSo, what you need to do to use logstage declarative config:\n1) include \"logstage-reference.conf\" in your application config\n2) defined next bootstrap modules :\n- `LogstageCodecsModule()` - it will bind rendering policy and logsinks mappers and all necessary logstage runtime codecs\n\nEach `RenderingPolicy` and `LogSink` you may bind by calling follow commands inside LogstageCodecsModule:\n\n    bindLogSinkMapper[T <: LogSink : ru.TypeTag, C: ru.TypeTag](f: C => T)\n\n    bindRenderingPolicyMapper[T <: RenderingPolicy : ru.TypeTag, C: ru.TypeTag](f: C => T)\n3) defined application modules:\n- `LoggerConfigModule()` - it makes binding of LoggerConfig and you may inject it from locator using next command:\n\n```scala\nval logstageConfig = locator.get[LoggerConfig]\n```\n\nLoggerConfig model is next:\n\n```scala\nfinal case class LoggerPathConfig(threshold: Log.Level, sinks: Seq[LogSink])\n\nfinal case class LoggerConfig(root : LoggerPathConfig, entries : Map[String, LoggerPathConfig])\n```","title":"Basic setup"},{"location":"/logstage/config.html#example","text":"Let’s define our sinks and policies 1.1 DummyLogSink class DummyLogSink(policy: RenderingPolicy) extends LogSink {\n   override def flush(e: Log.Entry): Unit = {\n     // do smth\n   }\n}\n 1.2 DummyRenderingPolicy class DummyRenderingPolicy(foo: Int, bar: Option[String]) extends RenderingPolicy {\n  override def render(entry: Log.Entry): String = entry.toString\n}\n Let’s define out logstage reference config\nlogstage {\n\n   // include izumi sdk settings\n   include \"logstage-reference.conf\"\n\n   // custom overrides \n   \n   sinks = [\n      \"default\" = {\n        path = \"path.to.DummyLogSink\"\n        params {\n          policy {\n            path = \"path.to.DummyRenderingPolicy\"\n            params {\n              foo = 1024\n              bar = \"your_string_parameter\"\n            }\n          }\n        }\n      }\n   ]\n   \n    root {\n       threshold = \"info\"\n       sinks = [\n         \"default\"\n       ]\n     }\n   \n     entries = {\n        \"path.for.debug.only.*\" = debug\n     }\n}\nSo, for now we need to specify case classes constructors for out DummyLogSink and DummyRenderingPolicy for automatic parsing 3.1 DummyRenderingPolicyConstructor case class DummyRenderingPolicyConstructor(foo : Int, bar: Option[String])\n 3.2 DummyLogSinkConstructor case class DummyLogSinkConstructor(policy : RenderingPolicy)\n now we need to configure out DI for loggerConfigUsage 4.1 Define bootsrap module. Here you can bind all mappers for custom Policies and Logsinks: val logstageBootstrapModule = new LogstageCodecsModule {\n\n    // bind our rendering policy\n\n    bindRenderingPolicyMapper[DummyRenderingPolicy, DummyRenderingPolicyConstructor]{\n      c => \n        new DummyRenderingPolicy(c.foo, c.bar)\n    }\n\n    // bind our logsink\n\n    bindLogSinkMapper[DummyLogSink, DummyLogSinkConstructor] {\n      c =>  new DummyLogSink(c.policy)\n    }\n}\n\nval bootstrapModules = Seq(..., logstageBootstrapModule)\n\n 4.2 Add LoggerConfigModule to app modules val modules = Seq(..., new LoggerConfigModule ())\n 4.2 Enjoy! // Basic locator setup\n\nval injector = Injector(bootstapModules: _*)\nval plan = injector.plan(modules.toList.overrideLeft)\nval locator = injector.produce(plan)\n\n// retrieve binded config\nval cfg = locator.get[LoggerConfig]","title":"Example"},{"location":"/logstage/custom_ctx.html","text":"","title":"Custom Context ? Izumi Toolkit"},{"location":"/logstage/custom_ctx.html#custom-context","text":"TODO Sorry, this page is not ready yet","title":"Custom Context"},{"location":"/sbt/index.html","text":"","title":"SBT Toolkit ? Izumi Toolkit"},{"location":"/sbt/index.html#sbt-toolkit","text":"Izumi provides you a bunch of sbt plugins allowing you to significantly reduce size and increase clarity of huge multi-module builds.\nTo start using Izumi plugins add the following into your project/plugins.sbt:\nval izumi_version = \"0.7.0-SNAPSHOT\"\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-izumi\" % izumi_version)\n// This is Izumi's Bill of Materials, see below\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-izumi-deps\" % izumi_version)\nWe provide you the following kinds of plugins:\nGlobal plugins: they add some helper sbt tasks, enabled automatically, Environmental plugins: they change some aspects of sbt behavior in an opinionated way, intended to be enabled in the root project, Presets - opinionated sets of environmental plugins, Optional plugins: they provide some convenience sbt tasks, intended to be enabled manually, per-project.\nImportant notes:\nPlease keep in mind no plugins are being enabled automatically, The rest of Izumi plugins are optional. You may use a preset to activate them or combine them manually as you wish (using settings groups), Some plugins can’t be enabled globally due to sbt limitations ? they have to be enabled per-project. You should use Settings Groups in order to enable them.","title":"SBT Toolkit"},{"location":"/sbt/index.html#global-plugins","text":"Plugin Description IzumiImportsPlugin Makes all the Izumi imports visible by default","title":"Global plugins"},{"location":"/sbt/index.html#environmental-plugins","text":"Plugin Description IzumiBuildManifestPlugin Adds build info into jar manifests IzumiConvenienceTasksPlugin Devops/workflow helpers IzumiDslPlugin Compact build definitions IzumiGitStampPlugin Adds GIT status into jar manifests IzumiPropertiesPlugin Convenience helpers for sys.props IzumiResolverPlugin Better defaults for artifact resolution IzumiInheritedTestScopesPlugin Convenience helpers for test scope inheritance","title":"Environmental plugins"},{"location":"/sbt/index.html#presets","text":"Plugin Description IzumiEnvironment All the environmental plugins except of GIT one IzumiGitEnvironment All the environmental plugins with GIT one","title":"Presets"},{"location":"/sbt/index.html#optional-plugins","text":"Plugin Description IzumiExposedTestScopesPlugin Maintains test scope separation IzumiCompilerOptionsPlugin Some linting/optimization presets for scalac/javac IzumiFetchPlugin Allows you to transitively download artifacts from remote repositories IzumiPublishingPlugin Some convenience helpers and improvements for artifact publishing IzumiBuildInfoPlugin Generates sbt-compatible BOMs ? Bills of Materials","title":"Optional plugins"},{"location":"/sbt/index.html#installation","text":"To activate all the plugins add the following statements into your root project:\nenablePlugins(IzumiGitEnvironmentPlugin)\nIf you don’t use git in your project, use this preset instead:\nenablePlugins(IzumiEnvironmentPlugin)\nTo activate Comp\nval GlobalSettings = new DefaultGlobalSettingsGroup {\n  override val plugins = Set(IzumiCompilerOptionsPlugin, IzumiExposedTestScopesPlugin)\n}","title":"Installation"},{"location":"/sbt/index.html#inherited-test-scopes","text":"","title":"Inherited Test Scopes"},{"location":"/sbt/index.html#test-scope-inheritance","text":"IzumiScopesPlugin extends SBT Project with several implicit methods:\ntestOnlyRef - provides you a project reference which is equivalent to % \"test\" dependency, dependsSeq and depends - allow you to add dependencies to your project the way test scopes of your dependencies are visible within test scopes of your project. So, essentially when you use these methods your dependencies are added into your projects with the following qualifier: \"test->compile,test;it->compile,test,it\"\nYou need to activate DefaultItSettingsGroup on your projects (see “Setting Groups” below) in order to make this working on it scope.\nExample:\nlazy val myLibrary = ...\n\nlazy val myProject = (...).depends(myLibrary)\nSo, now you may use classes from the test scope of myLibrary within test scope of myProject","title":"Test Scope Inheritance"},{"location":"/sbt/index.html#test-scope-separation","text":"InheritedTestScopesPlugin works in pair with IzumiScopesPlugin and provides you an unique feature: only the classes you marked with @ExposedTestScope are being exposed to dependant artifacts.\nSo, let’s assume that:\nyou have two artifacts, Library and App, App depends on Library, In the test scope of Library you have a class named TestSuite, In the test scope of Library you have another class named TestUtil, TestUtil is annotated with @ExposedTestScope,\nin that case TestUtil will be visible in App’s test scope, but TestSuite will not be visible.\nA diagram:\n+-----------------------------------------+     +-----------------------------------------+\n| Library                                 |     | App                                     |\n|-----------------------------------------|     |-----------------------------------------|\n| Main scope                              |     | Main scope                              |\n|                                     <---+-----+--                                       |\n| UtilityClass                            |     | AppMain                                 |\n|-----------------------------------------|     |-----------------------------------------+\n| Private Test Scope | Exposed test scope |     | Test scope                              |\n|                    |                <---+-----+--                                       |\n| TestSuite          | TestUtil           |     | Private Test Scope | Exposed test scope |\n+-----------------------------------------+     +-----------------------------------------+\nNotes:\nIntellij IDEA doesn’t support overriden classpaths so when you run your tests under IDEA the whole test scopes are visible in dependencies, At the moment the implementation of @ExposedTestScope (substring presence check) is imperfect and has to be improved, Transitive dependencies are not checked, so in case you expose a class but do not expose it’s dependencies your build will work under IDEA, but you will a classloading exception under sbt. This is going to be improved in the future.","title":"Test Scope Separation"},{"location":"/sbt/index.html#test-scope-publishing","text":"The whole content of test scopes is being published by default with test qualifier. Test scope separation has no effect on test scope publishing.","title":"Test Scope Publishing"},{"location":"/sbt/index.html#settings-dsl","text":"IzumiDslPlugin comes with a DSL intended to simplify definition of complex project layouts.\nTo activate the plugin add the following statement into your root project:\nenablePlugins(IzumiDslPlugin)","title":"Settings DSL"},{"location":"/sbt/index.html#simplified-identifiers","text":"DSL provides syntax to simplify project definitions. A definition such as this:\nlazy val petstoreApp = In(\"app\").as.module\nexpands to\nlazy val petstoreApp = project.in(\"app/petstore-app\")\nYou can attach settings and dependencies to the In part, that way you can apply common settings to all the projects in a directory:\nval ApiSettings = new SettingsGroup {\n  override val plugins = Set(IdealinguaPlugin)\n}\n\nlazy val inApi = In(\"api\").settings(ApiSettings)\n\nlazy val petstoreApi = inApi.as.module\nlazy val todomvcApi = inApi.as.module","title":"Simplified Identifiers"},{"location":"/sbt/index.html#setting-groups","text":"","title":"Setting Groups"},{"location":"/sbt/index.html#global-setting-group","text":"","title":"Global Setting Group"},{"location":"/sbt/index.html#automatic-aggregation","text":"When you use .as.project or .as.module syntax to define a project, that project is stored in a global singleton.\nYou may use transitiveAggregate or transitiveAggregateSeq methods instead of standard aggregate, in that case all the transitive dependencies of the projects provided will be also added into aggregation list. This allows you to simplify your definitions by avoiding specifing all the modules in .aggregate.\nIn case you don’t want your project to be recorded, you shoud use .as.just syntax.\nImportant note: sbt is lazy! We just store project reference in a singleton list, we don’t analyze dependency graph. Though sbt relies on lazy val declarations. So, in fact the singleton initializes at the moment you invoke aggregation. In case you don’t add a project into aggregation list such a project still will be initialized by sbt and added into the singleton, but it would happen later than evaluation of aggregation list so the project will not be aggregated.","title":"Automatic Aggregation"},{"location":"/sbt/index.html#aggregation-safety-check","text":"When you invoke transitiveAggregate or transitiveAggregateSeq on your root project it checks if the accumulated set of known project is the same as the set of all projects loaded by sbt.\nIn case module is missing you’ll get a warning. This makes it unlikely for you to accidentally forget to aggregate a module in multi-module project.","title":"Aggregation Safety Check"},{"location":"/sbt/index.html#build-descriptors","text":"","title":"Build Descriptors"},{"location":"/sbt/index.html#bills-of-materials","text":"Izumi brings Bill of Materials concept to SBT.","title":"Bills of Materials"},{"location":"/sbt/index.html#izumi-bom","text":"You can import Izumi libraries and transitive dependencies without specifying their version or even artifact names. To do that add sbt-izumi-deps SBT plugin:\nval izumi_version = \"0.7.0-SNAPSHOT\"\naddSbtPlugin(\"com.github.pshirshov.izumi.r2\" % \"sbt-izumi-deps\" % izumi_version)\nYou can use it like this:\nlibraryDependencies += Izumi.R.distage_core // Import an izumi library\nlibraryDependencies += IzumiDeps.R.cats_effect // Import a dependency of izumi\nlibraryDependencies += IzumiDeps.T.scalatest // Import a dependency of izumi in test scope\nR is for Runtime artifacts and T is for Test scope artifacts","title":"Izumi BOM"},{"location":"/sbt/index.html#create-a-bom-for-your-projects","text":"sbt-izumi-deps allows you to a create BOMs for your own projects. Just add the following snippet into your project settings:\nlazy val myProject = (project in file(\"my-project-bom\"))\n  .settings(withBuildInfo(\"com.mycompany.myproject\", \"MyProjectBOM\"))\nIf you use Izumi SBT DSL, you can use the following syntax:\nlazy val inRoot = In(\".\")\nlazy val myProjectBom = inRoot.as.module\n  .settings(withBuildInfo(\"com.mycompany.myproject\", \"MyProjectBOM\"))\nIf you want to include BOMs of you project, you can use the following syntax:\nimport com.mycompany.myproject.MyProjectBOM\n\nlazy val myLib = In(\"lib\").as.module\n  .settings(\n    libraryDependencies ++= Seq(\n      MyProjectBOM.R.my_project_bom,     // Runtime artifact\n      MyProjectBOM.T.my_project_bom,     // Runtime artifacts for test scope*\n      MyProjectBOM.TSR.my_project_bom,   // Test artifacts\n      MyProjectBOM.TST.my_project_bom,   // Test artifacts for test scope\n    )\n  )","title":"Create a BOM for your projects"},{"location":"/sbt/index.html#build-manifest-entries","text":"","title":"Build Manifest entries"},{"location":"/sbt/index.html#git-manifest-entries","text":"GitStampPlugin adds the following values into MANIFEST.MF of each jar artifact produced:\nManifest Key Description X-Git-Branch The name of branch sbt was invoked on X-Git-Repo-Is-Clean true or false, indicates if GIT repo was in clean state when the build was invoked X-Git-Head-Rev GIT revision on which sbt was invoked\nTo activate the plugin add the following statement into your root project:\nenablePlugins(GitStampPlugin)","title":"Git Manifest entries"},{"location":"/sbt/index.html#convenience-helpers","text":"","title":"Convenience Helpers"},{"location":"/sbt/index.html#stub-generators","text":"ConvenienceTasksPlugin provides you the following commands:\nnewModule <module_path/module_name> [package.suffix]: creates empty project layout at /module_path/module_name. Optional package.suffix may be specified. newStub <module_path/module_name> [stub_name:default]: copies /stubs/${stub_name} into /module_path/module_name. stub_name may be omitted, default value is default\nSetting Description ConvenienceTasksPlugin.Keys.mkJavaDirs Also adds src/*/java directories into generated stubs ConvenienceTasksPlugin.Keys.defaultStubPackage Default stub package. By default same as project’s organization","title":"Stub Generators"},{"location":"/sbt/index.html#version-suffixes","text":"ConvenienceTasksPlugin provides you command\naddVersionSuffix SUFFIX\nThis command updates project version defined in version.sbt with qualifier SUFFIX-SNAPSHOT\nExisting qualifiers will be removed. 1.0.0 would become 1.0.0-SUFFIX-SNAPSHOT 1.0.0-SNAPSHOT would become 1.0.0-SUFFIX-SNAPSHOT\nYou may need this command while setting up a build for feature branches and wish to avoid situation when different branches publishes artifacts with the same names.","title":"Version Suffixes"},{"location":"/sbt/index.html#target-preservation","text":"ConvenienceTasksPlugin provides you command\npreserveTargets SUFFIX\nThis command recursively enumerates all the directories named target and recursively copies them using name target.SUFFIX.\nYou may need this command while setting up a build where you wish to perform clean several times but want to preserve intermediate build artifacts stored in target directories. The most frequent case is coverage build followed by tests and then by production build. In this case you would like to use a command sequence like\n;clean;coverage;test;coverageOff;coverageReport;preserveTargets coverage;clean;publish","title":"target preservation"},{"location":"/sbt/index.html#directory-cleanups","text":"ConvenienceTasksPlugin provides you command\nrmDirs target.coverage\nThis command recursively removes all the directories named target.coverage across the project.\nYou may need this command to cleanup preserved target directories, or destroy some build artifacts, like rmDirs scala-2.11","title":"Directory cleanups"},{"location":"/sbt/index.html#property-readers","text":"IzumiPropertiesPlugin provides you implicit classes allowing you to convert Strings into Integers or Booleans exceptions-safe and do the same for system properties:\n\"true\".asBoolean(default = false) // true\n\"junk\".asBoolean(default = false) // false\n\"123\".asInt(default = 265) // 123\n\"junk\".asInt(default = 265) // 265\nsys.props.asBoolean(\"my.property\", default = false)\nsys.props.asInt(\"my.property\", default = 123)\nYou may activate this plugin with the following statement in root project:","title":"Property Readers"},{"location":"/sbt/index.html#transitive-artifact-downloader","text":"TODO","title":"Transitive Artifact Downloader"},{"location":"/sbt/index.html#optional-settings","text":"","title":"Optional settings"},{"location":"/sbt/index.html#publishing","text":"TODO","title":"Publishing"},{"location":"/sbt/index.html#publishing-settings","text":"TODO","title":"Publishing settings"},{"location":"/sbt/index.html#publishing-credentials-and-targets","text":"TODO","title":"Publishing credentials and targets"},{"location":"/sbt/index.html#compiler-options","text":"CompilerOptionsPlugin provides you some sane compiler option presets (linting, optimizations).\nYou should explicitly enable this plugin in each project you want to use it. When you want to enable it globally, use a settings group:\nval GlobalSettings = new SettingsGroup {\n  override val plugins = Set(\n      IzumiCompilerOptionsPlugin,\n      // ...\n  )\n  // ...\n}","title":"Compiler options"},{"location":"/sbt/index.html#resolvers","text":"ResolverPlugin turns on the following settings which should speedup your dependency resolution:\nupdateOptions := updateOptions\n      .value\n      .withCachedResolution(true)\n      .withGigahorse(true)","title":"Resolvers"},{"location":"/manifesto/index.html","text":"","title":"Productivity and challenges ? Izumi Toolkit"},{"location":"/manifesto/index.html#productivity-and-challenges","text":"TODO Sorry, this page is not ready yet","title":"Productivity and challenges"},{"location":"/pper/index.html","text":"","title":"PPER Pattern ? Izumi Toolkit"},{"location":"/pper/index.html#pper-pattern","text":"“Project Networks and Percept-Plan-Execute-Repeat loop to the rescue” slides: https://github.com/7mind/slides/raw/master/03-pper-basics/target/pper-base.pdf\nTODO Sorry, this page is not ready yet","title":"PPER Pattern"}]}