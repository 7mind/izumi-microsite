{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Izumi Project"},{"location":"/index.html#izumi-project","text":"Izumi (*jp. ??, spring*) is a set of independent libraries and frameworks allowing you to significantly increase productivity of your Scala development.\nincluding the following components:\ndistage ? Staged, transparent and debuggable runtime & compile-time Dependency Injection Framework, logstage ? Automatic structural logs from Scala string interpolations, idealingua ? API Definition, Data Modeling and RPC Language, optimized for fast prototyping ? like gRPC, but with a human face. Currently generates servers and clients for Go, TypeScript, C# and Scala, Opinionated SBT plugins ? Reduces verbosity of SBT builds and introduces new features ? inter-project shared test scopes and BOM plugins (from Maven), Percept-Plan-Execute-Repeat (PPER) ? a pattern that enables modeling very complex domains and orchestrate deadly complex processes a lot easier than you’re used to.","title":"Izumi Project"},{"location":"/index.html#dependencies","text":"To use, add the following into project/build.sbt,\nlibraryDependencies ++= Seq(\n  // Core distage library\n  \"io.7mind.izumi\" %% \"distage-core\" % \"0.10.0-SNAPSHOT\",\n  // distage-testkit for ScalaTest\n  \"io.7mind.izumi\" %% \"distage-testkit-scalatest\" % \"0.10.0-SNAPSHOT\" % Test,\n  // distage-framework: Roles, Entrypoints, Effect modules\n  \"io.7mind.izumi\" %% \"distage-framework\" % \"0.10.0-SNAPSHOT\",\n  // Typesafe Config support\n  \"io.7mind.izumi\" %% \"distage-extension-config\" % \"0.10.0-SNAPSHOT\",\n  // Classpath discovery support\n  \"io.7mind.izumi\" %% \"distage-extension-plugins\" % \"0.10.0-SNAPSHOT\",\n  \n  // Core LogStage library\n  \"io.7mind.izumi\" %% \"logstage-core\" % \"0.10.0-SNAPSHOT\",\n  // Configure LogStage with Typesafe Config\n  \"io.7mind.izumi\" %% \"logstage-config\" % \"0.10.0-SNAPSHOT\",\n  // LogStage integration with DIStage\n  \"io.7mind.izumi\" %% \"logstage-di\" % \"0.10.0-SNAPSHOT\",\n  // Write logs as JSON\n  \"io.7mind.izumi\" %% \"logstage-rendering-circe \" % \"0.10.0-SNAPSHOT\",\n  // Route Slf4J logs to LogStage\n  \"io.7mind.izumi\" %% \"logstage-adapter-slf4j \" % \"0.10.0-SNAPSHOT\",\n  // Route LogStage logs to Slf4J\n  \"io.7mind.izumi\" %% \"logstage-sink-slf4j \" % \"0.10.0-SNAPSHOT\",\n  \n  // Idealingua Runtime Dependencies (for use with the Idealingua compiler)\n  \"io.7mind.izumi\" %% \"idealingua-v1-runtime-rpc-http4s\" % \"0.10.0-SNAPSHOT\",\n)\nScaladoc\nIzumi on GitHub\nLatest SNAPSHOT documentation","title":"Dependencies"},{"location":"/index.html#credits","text":"YourKit supports open source projects with innovative and intelligent tools for monitoring and profiling Java and .NET applications. YourKit is the creator of YourKit Java Profiler YourKit .NET Profiler and YourKit YouMonitor.","title":"Credits"},{"location":"/idealingua/index.html","text":"","title":"IdeaLingua RPC & Domain Modeling Language ? Izumi Project"},{"location":"/idealingua/index.html#idealingua-rpc-domain-modeling-language","text":"IdeaLingua is an RPC framework & Domain Modeling Language, it’s purpose is to:\nShare & publish APIs and data models in a common concise format Allow remote calls to services given their public API definitions. Create idiomatic API clients and servers for all programming languages ? currently Scala, TypeScript, C# & Go. Support frontend-to-backend and backend-to-frontend calls (ala push notifications, via buzzer definitions) Abstract away details such as the network protocol or the serialization format. Save developers from untyped and brittle REST.","title":"IdeaLingua RPC & Domain Modeling Language"},{"location":"/idealingua/index.html#user-service-example","text":"package user.api\n\nenum Gender = Male | Female\n\nid EntityID {\n  uuid: uuid\n}\n\nmixin Entity {\n  id: EntityID\n}\n\nmixin Person {\n  name: str\n  surname: str\n  gender: Gender\n}\n\ndata User {\n  & Entity\n  + Person\n  password: str\n}\n\ndata PublicUser {\n  + User\n  - password: str\n}\n\nadt Result = Success | Failure\n\ndata Success {\n  message: str\n}\n\ndata Failure {\n  code: int8\n}\n\nservice UserService {\n  def saveUser(user: User): Result\n  def findUserByName(name: str): list[PublicUser] | Failure\n}","title":"User Service Example"},{"location":"/idealingua/index.html#quick-start","text":"You may use our preconfigured Docker environment to experiment with Izumi IDL compiler:\ndocker run -ti --rm septimalmind/izumi-env\nThen try this snippet:\nexport COMPILER=\"io.7mind.izumi:idealingua-v1-compiler_2.12:$izumi.version$\"\nexport S_REPOSITORY=https://oss.sonatype.org/content/repositories/snapshots \nexport R_REPOSITORY=https://oss.sonatype.org/content/repositories/releases\n\n# create sample project in `testproject` directory\ncoursier launch -r $S_REPOSITORY -r $R_REPOSITORY $COMPILER -- :init testproject \n\ncd testproject \n\n# compile Scala and Typescript projects using all the defaults\ncoursier launch -r $S_REPOSITORY -r $R_REPOSITORY $COMPILER -- :scala :typescript\n\n# Run SBT on generated Scala project\npushd .\ncd target/scala\nsbt package\npopd\n\n# Run tsc on generated Typescript project\npushd .\ncd target/typescript\nyarn install\ntsc\npopd\n\napt install -y mc\nmc","title":"Quick start"},{"location":"/idealingua/index.html#example-project","text":"See idealingua-example for examples for Scala, TypeScript, Go, C# and other languages.","title":"Example Project"},{"location":"/idealingua/index.html#installation","text":"","title":"Installation"},{"location":"/idealingua/index.html#using-sbt-plugin","text":"Add the following to your project/plugins.sbt file:\nval izumi_version = \"0.10.0-SNAPSHOT\"\naddSbtPlugin(\"io.7mind.izumi\" % \"sbt-idealingua\" % izumi_version)\nPlace your domain definitions into /src/main/izumi directory, then enable the plugin for that project. For the generated code to compile, you will also need to add dependencies on the Idealingua RTS modules:\nval izumi = prop\n\nizumiProject\n  .enablePlugins(IdealinguaPlugin)\n  .settings(\n    libraryDependencies ++= Seq(\n        Izumi.R.idealingua_model\n      , Izumi.R.idealingua_runtime_rpc\n      , Izumi.R.idealingua_runtime_rpc_http4s\n      , Izumi.R.idealingua_runtime_rpc_circe\n    )\n  )\nYou can depend on the code generated by Idealinguain in your other Scala projects:\nproject.dependsOn(izumiProject)","title":"Using SBT Plugin"},{"location":"/idealingua/index.html#using-the-standalone-compiler","text":"The compiler is built as an uberjar and published to Maven Central.\nThe preferred way to install the compiler is via coursier\nTo install current release version:\n# install release executable\ncoursier bootstrap izumi.r2:idealingua-compiler_2.12:0.10.0-SNAPSHOT -o idlc\n\n./idlc --help\nTo install development snapshot:\n# install snapshot\ncoursier bootstrap -r https://oss.sonatype.org/content/repositories/snapshots/ izumi.r2:idealingua-compiler_2.12:0.7.0-SNAPSHOT -o idlc\n\n./idlc --help\nCommandline examples:\n# compile sources in ./src and output generated code to ./target/scala and ./target/typescript \n# all compiler plugins for Scala and TypeScript are enabled by * pattern\n\n./idlc -s src -t target -L scala=* -L typescript=*\n# compile with `AnyValExtension` compiler plugin for Scala disabled\n\n./idlc -s src -t target -L scala=-AnyvalExtension -L typescript=*","title":"Using the standalone compiler"},{"location":"/idealingua/index.html#scala-http4s-transport","text":"Most likely you’ll need to use Kind Projector and enable partial unification:\nscalacOptions += \"-Ypartial-unification\"\n\nresolvers += Resolver.sonatypeRepo(\"releases\")\n\naddCompilerPlugin(\"org.spire-math\" % \"kind-projector\" % \"0.9.8\" cross CrossVersion.binary)\nYou may find the test suite for the http4s backend here.","title":"Scala http4s Transport"},{"location":"/idealingua/language-reference.html","text":"","title":"Idealingua Language Reference ? Izumi Project"},{"location":"/idealingua/language-reference.html#idealingua-language-reference","text":"","title":"Idealingua Language Reference"},{"location":"/idealingua/language-reference.html#keywords-and-aliases","text":"Keyword Aliases Explanation domain package, namespace Namespace containing collection of entities import References a domain by id include Includes *.model file by name alias type, using Type alias enum Enumeration mixin interface Mixin, named collection of fields data dto, struct Data adt choice Algebraic Data Type id Identifier, named collection of scalars service Service interface def fn, func, fun Method","title":"Keywords and aliases"},{"location":"/idealingua/language-reference.html#inheritance-operators","text":"Keyword Aliases Explanation Example + +++, ... Inherit structure (copy fields) + Mixin & &&& Inherit interface & Mixin - --- Drop structure or field (doesn’t work for interfaces) - Mixin, - field: str","title":"Inheritance operators"},{"location":"/idealingua/language-reference.html#built-in-types","text":"","title":"Built-in types"},{"location":"/idealingua/language-reference.html#scalars","text":"Type name Aliases Explanation Scala type str string String String bool boolean, bit Boolean Boolean i08 byte, int8 8-bit integer Byte i16 short, int16 16-bit integer Short i32 int, int32 32-bit integer Int i64 long, int64 64-bit integer Long f32 float, flt Single precision floating point Float f64 double, dbl Double precision floating point Double uid uuid UUID java.util.UUID tsz dtl, datetimel Timestamp with timezone java.time.ZonedDateTime tsl dtz, datetimez Local timestamp java.time.LocalDateTime time time Time java.time.LocalTime date date Date java.time.LocalDate\nNotes:\nWhen the target language lacks a corresponding numeric type, we use the smallest type available that includes the required type. e.g. in TypeScript i08 is number When the target language lacks types for time","title":"Scalars"},{"location":"/idealingua/language-reference.html#collections","text":"Type name Explanation Scala mapping list[T] List List map[K, V] Map (only scalar and id keys are supported) Map opt[T] Optional value Option set[T] Set (unordered) Set","title":"Collections"},{"location":"/idealingua/json.html","text":"","title":"JSON Wire Format ? Izumi Project"},{"location":"/idealingua/json.html#json-wire-format","text":"IdeaLingua employs a simple JSON-based wire format. To interoperate, all the language translators should implement this spec.","title":"JSON Wire Format"},{"location":"/idealingua/json.html#data-data-class","text":"data defined as:\npackage example\n\ndata User {\n  name: str\n  surname: str\n  id: uuid\n}\nShould be rendered as:\n{\n  \"name\": \"Lorem\",\n  \"surname\": \"Ipsum\",\n  \"id\": \"13bee602-521b-47c2-ad81-30527f8b2398\"\n}","title":"data: Data Class"},{"location":"/idealingua/json.html#mixin-mixin","text":"When sent over the wire, mixins include a fully qualified name of their implementation.\nmixins defined as:\npackage example\n\nmixin IntPair {\n  x: i32\n  y: i32\n}\n\ndata NamedIntPair {\n  & IntPair\n  name: str\n}\nShould be rendered as:\n{ \n  \"example.IntPair#Struct\": {\n    \"x\": 256,\n    \"y\": 512\n  }\n}\nfor the default implementation, and:\n{\n  \"example#NamedIntPair\": {\n    \"x\": 256,\n    \"y\": 512,\n    \"name\": \"Vertex\"\n  }\n}\nfor the NamedIntPair implementation.","title":"mixin: Mixin"},{"location":"/idealingua/json.html#adt-algebraic-data-type","text":"adt’s include an unqualified name of their variant.\nadt defined as:\npackage example\n\nadt AB = A | Z as B\n\ndata A {\n  value: i32\n}\n\ndata Z {\n  value: str\n}\nShould be rendered as:\n{\n  \"A\": { \n    \"value\": 1\n  }\n}\nfor the A variant, and:\n{\n  \"B\": {\n    \"value\": \"abc\"\n  }\n}\nfor the Z as B variant","title":"adt: Algebraic Data Type"},{"location":"/idealingua/json.html#id-identifier","text":"Ids are rendered as strings prefixed by type name and separated by : symbol. Field order is preserved.\nid defined as:\npackage example\n\nid UserId {\n  userId: uuid\n  companyName: str\n}\nShould be rendered as:\n\"UserId#837006c8-d070-4cde-a2dd-8999c186ef02:Lightbend\"","title":"id: Identifier"},{"location":"/idealingua/json.html#alias-type-alias","text":"Type Aliases should be rendered directly as their aliased types and should never impact serialization.","title":"alias: Type Alias"},{"location":"/idealingua/json.html#enum-enumeration","text":"Enums are rendered as strings.\nenum defined as:\npackage example\n\nenum Gender = MALE | FEMALE\nShould be rendered as:\n\"FEMALE\"","title":"enum: Enumeration"},{"location":"/idealingua/json.html#service","text":"Service outputs are always wrapped into a JSON object with one field \"value\".\nFor service defined as:\npackage example\n\nservice SayHello {\n  def sayHello(): str\n}\nsayHello method will return a result rendered as:\n{ \"value\": \"hello\" }","title":"Service"},{"location":"/idealingua/cogen.html","text":"","title":"Code generator reference ? Izumi Project"},{"location":"/idealingua/cogen.html#code-generator-reference","text":"We support the following concepts:\nEnumerations Algebraic Data Types Type aliases Mixins Data Classes Identifiers Services","title":"Code generator reference"},{"location":"/idealingua/cogen.html#inheritance","text":"We support two forms of inheritance: interface inheritance (& modifier) and structural mixins (* modifier) The only difference between structural inheritance and interface inheritance is presence/absence of the base interface in the list of supertypes Both Data Classes and Mixins support both forms of inheritance Services, ADTs, Type Aliases, Identifiers and Enumerations does not support inheritance We provide widening narrowing implicit functions as well as copy constructors for all the generated entities","title":"Inheritance"},{"location":"/idealingua/cogen.html#example","text":"mixin IntPair {\n  x: i32\n  y: i32\n}\n\nmixin Metadata {\n  id: str\n  name: str\n}\n\nmixin PointLike {\n  + Metadata\n  * IntPair\n}\n\ndata Point {\n  + Metadata\n  * IntPair\n}","title":"Example"},{"location":"/idealingua/cogen.html#scala-output","text":"trait IntPair {\n  def y: Int\n  def x: Int\n}\n\ntrait Metadata {\n  def name: String\n  def id: String\n}\n\nfinal case class Point(y: Int, name: String, x: Int, id: String) extends Metadata\n\ntrait PointLike extends Metadata {\n  def y: Int\n  def x: Int\n  def name: String\n  def id: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#constructs","text":"Notes:\nAll the examples of generated code are given in minimal form Generated code for codecs, implicit conversions and type info is omitted","title":"Constructs"},{"location":"/idealingua/cogen.html#mixin-mixin","text":"mixin Person {\n   name: str\n   surname: str\n }","title":"mixin: Mixin"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Person {\n  def name: String\n  def surname: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#data-data-class","text":"Differences between Mixins and Data Classes:\nData classes cannot be subclassed Data classes are always rendered as case classes, Mixins are always rendered as pair of Interface and Implementation\ndata HumanUser {\n   + IdentifiedUser\n   * Person\n }","title":"data: Data Class"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class HumanUser(name: String, surname: String, id: UserId) extends IdentifiedUser with Person","title":"Scala output"},{"location":"/idealingua/cogen.html#adt-algebraic-data-type","text":"mixin Success {\n   values: map[str, str]\n }\n \n mixin Failure {\n   message: str\n }\n \n adt Result {\n   Success\n   Failure\n }","title":"adt: Algebraic Data Type"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Failure extends Any { def message: String }\n\ntrait Success extends Any { def values: scala.collection.immutable.Map[String, String] }\n\nsealed trait Result \n\nobject Result {\n  type Element = Result\n  \n  case class Success(value: Success) extends Result\n  case class Failure(value: Failure) extends Result\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#alias-type-alias","text":"alias UserId = str","title":"alias: Type Alias"},{"location":"/idealingua/cogen.html#scala-output","text":"package object domain01 {\ntype UserId = String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#enum-enumeration","text":"enum Gender {\n  MALE\n  FEMALE\n}","title":"enum: Enumeration"},{"location":"/idealingua/cogen.html#scala-output","text":"sealed trait Gender\n\nobject Gender {\n  type Element = Gender\n  def all: Seq[Gender] = Seq(MALE, FEMALE)\n  def parse(value: String) = value match {\n    case \"MALE\" => MALE\n    case \"FEMALE\" => FEMALE\n  }\n  case object MALE extends Gender { override def toString: String = \"MALE\" }\n  case object FEMALE extends Gender { override def toString: String = \"FEMALE\" }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#id-identifier","text":"Notes:\nYou can use only scalar builtin types for identifier fields We provide both parser and sane .toString implementation .toString uses the following format: Name#urlencoded(part1):urlencoded(part2):... Fields are sorted by name before using in parser and .toString\nid UserId {\n  value: uid\n  company: uid\n}","title":"id: Identifier"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class UserId(value: java.util.UUID, company: java.util.UUID) {\n  override def toString: String = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.company, this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"UserId#$suffix\"\n  }\n}\n\nobject UserId {\n  def parse(s: String): UserId = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    UserId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]), parsePart[java.util.UUID](parts(1), classOf[java.util.UUID]))\n  }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#service-service","text":"id RecordId {\n  value: uid\n}\n\nmixin WithRecordId {\n  id: RecordId\n}\n\nmixin WithResult {\n  result: shared.rpc#Result\n}\n\nmixin UserData {\n  email: str\n}\n\nmixin PrivateUserData {\n  balance: f64\n}\n\nservice UserService {\n  def deleteUser(WithRecordId): (WithResult)\n  def createUser(UserData, PrivateUserData): (WithRecordId, WithResult)\n}\nNotes:\nService signature cannot accept anything except of Mixins (improvements planned) ServerDispatcher allows you to route wrapped result type to an appropriate method of an abstract implementation ClientDispatcher just passes input to an abstract receiver ClientWrapper allows you to transform unwrapped method signatures into wrapping instances ServerWrapped provides you an unwrapping service implementation ServiceUnwrapped provides you a way to implement services with signatures unwrapped","title":"service: Service"},{"location":"/idealingua/cogen.html#scala-output","text":"import _root_.izumi.idealingua.model._\nimport _root_.izumi.idealingua.runtime._\n\nclass UserServiceServerDispatcher[R[+_], S <: UserService[R]](val service: S) extends transport.AbstractServerDispatcher[R, S] {\n  import UserService._\n  override def dispatch(input: UserService.InUserService): R[UserService.OutUserService] = input match {\n    case value: UserService.InDeleteUser =>\n      service.deleteUser(value)\n    case value: UserService.InCreateUser =>\n      service.createUser(value)\n  }\n}\n\nclass UserServiceClientDispatcher[R[+_], S <: UserService[R]](dispatcher: transport.AbstractClientDispatcher[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = dispatcher.dispatch(input, classOf[UserService.OutDeleteUser])\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = dispatcher.dispatch(input, classOf[UserService.OutCreateUser])\n}\n\nclass UserServiceClientWrapper[R[+_], S <: UserService[R]](val service: S) extends model.IDLClientWrapper[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser] = {\n    service.deleteUser(UserService.InDeleteUser(id = id))\n  }\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser] = {\n    service.createUser(UserService.InCreateUser(balance = balance, email = email))\n  }\n}\n\ntrait UserServiceUnwrapped[R[+_], S <: UserService[R]] extends model.IDLServiceExploded[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser]\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser]\n}\n\nclass UserServiceServerWrapper[R[+_], S <: UserService[R]](val service: UserServiceUnwrapped[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = service.deleteUser(id = input.id)\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = service.createUser(balance = input.balance, email = input.email)\n}\n\ntrait UserService[R[_]] extends izumi.idealingua.runtime.model.IDLService[R] {\n  import UserService._\n  override type InputType = UserService.InUserService\n  override type OutputType = UserService.OutUserService\n  \n  override def inputClass: Class[UserService.InUserService] = classOf[UserService.InUserService]\n  override def outputClass: Class[UserService.OutUserService] = classOf[UserService.OutUserService]\n  \n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser]\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser]\n}\n\nobject UserService {\n  sealed trait InUserService extends Any \n  sealed trait OutUserService extends Any\n\n  case class InDeleteUser(id: RecordId) extends UserService.InUserService with WithRecordId\n  case class OutDeleteUser(result: shared.rpc.Result) extends AnyVal with UserService.OutUserService with WithResult\n  case class InCreateUser(balance: Double, email: String) extends UserService.InUserService with UserData with PrivateUserData\n  case class OutCreateUser(result: shared.rpc.Result, id: RecordId) extends UserService.OutUserService with WithRecordId with WithResult\n}","title":"Scala output"},{"location":"/idealingua/cogen-circe.html","text":"","title":"Circe serialization reference ? Izumi Project"},{"location":"/idealingua/cogen-circe.html#circe-serialization-reference","text":"","title":"Circe serialization reference"},{"location":"/idealingua/cogen-circe.html#polymorphism-and-time","text":"Notes:\nData classes cannot be polymorphic\nThe following example demonstrates how polymorphism and time values are handled:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\ntrait Polymorphic\n\nfinal case class TestPayload(\n                        zonedDateTime: ZonedDateTime = ZonedDateTime.now()\n                        , utcZonedDateTime: ZonedDateTime = ZonedDateTime.now(ZoneId.of(\"UTC\"))\n                        , localDateTime: LocalDateTime = LocalDateTime.now()\n                        , localTime: LocalTime = LocalTime.now()\n                        , localDate: LocalDate = LocalDate.now()\n                      ) extends Polymorphic\n\nobject TestPayload {\n  implicit val encodeTestPayload: Encoder[TestPayload] = deriveEncoder[TestPayload]\n  implicit val decodeTestPayload: Decoder[TestPayload] = deriveDecoder[TestPayload]\n}\n\nfinal case class AnotherPayload(message: String) extends Polymorphic\n\nobject AnotherPayload {\n  implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n  implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n}\n\nobject Polymorphic {\n    implicit val encodePolymorphic: Encoder[Polymorphic] = Encoder.instance { c =>\n    c match {\n      case v: TestPayload =>\n        Map(\"com.test#TestPayload\" -> v).asJson\n      case v: AnotherPayload =>\n        Map(\"com.test#RealPayload\" -> v).asJson\n    }\n  }\n  implicit val decodePolymorphic: Decoder[Polymorphic] = Decoder.instance(c => {\n    val fname = c.keys.flatMap(_.headOption).toSeq.head\n    val value = c.downField(fname)\n    fname match {\n      case \"com.test#TestPayload\" =>\n        value.as[TestPayload]\n      case \"com.test#RealPayload\" =>\n        value.as[AnotherPayload]\n    }\n  })\n}\n\ndef test(t: Polymorphic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Polymorphic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(TestPayload())\ntest(AnotherPayload(\"hi\"))\nThis example produces the following output:\nTestPayload:\nEncoded:\n{\"TestPayload\":{\"zonedDateTime\":\"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\"utcZonedDateTime\":\"2018-04-02T21:34:31.367744Z[UTC]\",\"localDateTime\":\"2018-04-02T22:34:31.36778\",\"localTime\":\"22:34:31.367813\",\"localDate\":\"2018-04-02\"}}\n\nParsed:\nRight({\n  \"TestPayload\" : {\n    \"zonedDateTime\" : \"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\n    \"utcZonedDateTime\" : \"2018-04-02T21:34:31.367744Z[UTC]\",\n    \"localDateTime\" : \"2018-04-02T22:34:31.36778\",\n    \"localTime\" : \"22:34:31.367813\",\n    \"localDate\" : \"2018-04-02\"\n  }\n})\n\nRestored:\nRight(Right(TestPayload(2018-04-02T22:34:31.367649+01:00[Europe/Dublin],2018-04-02T21:34:31.367744Z[UTC],2018-04-02T22:34:31.367780,22:34:31.367813,2018-04-02)))\n\n\nAnotherPayload:\nEncoded:\n{\"RealPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"RealPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Polymorphism and time"},{"location":"/idealingua/cogen-circe.html#algebraic-types","text":"Notes:\nWorks same way as polymorphic types Use short names instead of fully qualified names You may introduce a local alias for an algebraic type member: adt MyAdt { domain1.A as A1 | A}. This allows you to resolve name conflicts\nCogen example for ADTs:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\nsealed trait Algebraic\n\nobject NS1 {\n\n  case class Payload(localTime: LocalTime = LocalTime.now()) extends Algebraic\n\n  object Payload {\n    implicit val encodeTestPayload: Encoder[Payload] = deriveEncoder[Payload]\n    implicit val decodeTestPayload: Decoder[Payload] = deriveDecoder[Payload]\n  }\n\n}\n\nobject NS2 {\n\n  case class AnotherPayload(message: String) extends Algebraic\n\n  object AnotherPayload {\n    implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n    implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n  }\n\n}\nobject Algebraic {\n  implicit val encodePolymorphic: Encoder[Algebraic] = deriveEncoder[Algebraic]\n  implicit val decodePolymorphic: Decoder[Algebraic] = deriveDecoder[Algebraic]\n}\n\ndef test(t: Algebraic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Algebraic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(NS1.Payload())\ntest(NS2.AnotherPayload(\"hi\"))\nOutput:\nEncoded:\n{\"Payload\":{\"localTime\":\"18:13:31.942072\"}}\n\nParsed:\nRight({\n  \"Payload\" : {\n    \"localTime\" : \"18:13:31.942072\"\n  }\n})\n\nRestored:\nRight(Right(Payload(18:13:31.942072)))\n\nEncoded:\n{\"AnotherPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"AnotherPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Algebraic types"},{"location":"/idealingua/cogen-circe.html#identifiers","text":"Identifiers codec just invokes .toString and .parse to serialize/deserialize Identifiers.\nPlease check identifier codegen example for additional details.\nFull example:\nfinal case class CompanyId(value: java.util.UUID) {\n  override def toString: String = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"CompanyId#$suffix\"\n  }\n}\n\ntrait CompanyIdCirce {\n  import _root_.io.circe.{ Encoder, Decoder }\n  implicit val encodeCompanyId: Encoder[CompanyId] = Encoder.encodeString.contramap(_.toString)\n  implicit val decodeCompanyId: Decoder[CompanyId] = Decoder.decodeString.map(CompanyId.parse)\n}\n\nobject CompanyId extends CompanyIdCirce {\n  def parse(s: String): CompanyId = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    CompanyId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]))\n  }\n  implicit class CompanyIdExtensions(_value: CompanyId)\n}","title":"Identifiers"},{"location":"/idealingua/cogen-circe.html#enumerations","text":"Identifiers codec just invokes .toString and .parse same way as it implemented for Identifiers.","title":"Enumerations"},{"location":"/distage/index.html","text":"","title":"distage: Staged Dependency Injection ? Izumi Project"},{"location":"/distage/index.html#distage-staged-dependency-injection","text":"distage is a pragmatic module system for functional Scala, it aims to combine simplicity and expressivity of pure FP with the flexibility and extreme late-binding that’s traditionally associated with object-oriented dependency injection frameworks, such as Guice.\ndistage is suitable for structuring applications in Tagless Final Style, with ZIO Environment, or in imperative Scala style.","title":"distage: Staged Dependency Injection"},{"location":"/distage/index.html#why-use-distage-","text":"Faster applications and tests: distage guarantees that no unnecessary instantiations will happen during your tests or application startup. Quick failure detection: distage performs all the integration checks for your application and tests even before any instantiations happened. Simple tests: distage eliminates all the hard work of setting up your test environments, especially configurable ones. Better integration tests: distage provides you great memoization support for your tests so you may reuse expensive resources (like database connections) across multiple integration tests, gaining performance and without sacrificing correctness. Simple development workflow: distage-framework module allows you to develop Role-Based Applications – a fusion of Microservices and Monoliths. You may run all your services in one process for development purposes (and even switch to mock implementations with a single commandline argument). Fast compile times and low mental overhead: Unlike fully compile-time DIs, distage does not impose a compile time penalty. distage extensions are simple to write and do not require type-level programming. Simple debugging: distage provides you important insights about your application and allows you to introspect and modify it on the fly, before any instantiations happen. High Correctness: distage supports resources and lifecycle natively and guarantees proper cleanups even when something went wrong. No reflection: distage generates all constructors and type info at compile-time and does not use Scala reflection. As such, it’s compatible with Graal Native Image and (soon) Scala.js. Non-invasive: distage is designed to not impact the way your Scala code is written. It just removes all the initialization boilerplate. You don’t need to learn magic tricks to write components in a distage application.\ndistage is recommended by industry leaders:\nGiven its native support for type classes and higher-kinded types – both features indispensable to functional programming – distage is one of the leading dependency injection libraries out there. Bonus points for being built by a wicked-smart team that contributes to ZIO! -? John A. De Goes","title":"Why use distage?"},{"location":"/distage/index.html#faq","text":"Q: How to pronounce distage?\nA: ‘Dee-stage’\nQ: Isn’t it unsafe to use runtime dependency injection?\nA: distage is split into two stages, first a wiring plan is calculated, only afterwards it is executed. This Plan value can be tested for errors in an ordinary test suite ? if it is well-formed, the wiring will succeed at runtime. This test can also be performed at compile-time ? distage-framework module contains macros for aborting compilation in case of erroneous wiring.","title":"FAQ"},{"location":"/distage/index.html#further-reading","text":"Example Project ScalaUA Presentation Basics Advanced features Debugging distage-framework distage-framework-docker distage-testkit Syntax summary","title":"Further reading"},{"location":"/distage/basics.html","text":"","title":"Basics ? Izumi Project"},{"location":"/distage/basics.html#basics","text":"Quick Start Activation Axis Resource Bindings, Lifecycle Set Bindings Effect Bindings Auto-Traits Auto-Factories Tagless Final Style Cats & ZIO Integration","title":"Basics"},{"location":"/distage/basics.html#quick-start","text":"Suppose we have an abstract Greeter component and some other components that depend on it:\nimport distage.{ModuleDef, Injector, GCMode}\n\ntrait Greeter {\n  def hello(name: String): Unit\n}\n\nfinal class PrintGreeter extends Greeter {\n  override def hello(name: String) = println(s\"Hello $name!\") \n}\n\ntrait Byer {\n  def bye(name: String): Unit\n}\n\nfinal class PrintByer extends Byer {  \n  override def bye(name: String) = println(s\"Bye $name!\")\n}\n\nfinal class HelloByeApp(greeter: Greeter, byer: Byer) {\n  def run(): Unit = {\n    println(\"What's your name?\")\n    val name = readLine()\n    \n    greeter.hello(name)\n    byer.bye(name)\n  }\n}\nTo actually run the HelloByeApp, we have to wire implementations of Greeter and Byer into it. We will not do it directly. First we’ll only declare the component interfaces we have and the implementations we want for them:\nval HelloByeModule = new ModuleDef {\n  make[Greeter].from[PrintGreeter]\n  make[Byer].from[PrintByer]\n  make[HelloByeApp] // `.from` is not required for concrete classes \n}\n// HelloByeModule: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Byer}].from(call(<function1>(): repl.Session::repl.Session.App0::repl.Session.App0.PrintByer)) ((basics.md:67)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.HelloByeApp}].from(call(<function1>(repl.Session::repl.Session.App0::repl.Session.App0.Greeter, repl.Session::repl.Session.App0::repl.Session.App0.Byer): repl.Session::repl.Session.App0::repl.Session.App0.HelloByeApp)) ((basics.md:68)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Greeter}].from(call(<function1>(): repl.Session::repl.Session.App0::repl.Session.App0.PrintGreeter)) ((basics.md:66)))\nModuleDef merely contains a description of the desired object graph, let’s transform that high-level description into an actionable series of steps - an OrderedPlan, a datatype we can inspect, test or verify at compile-time ? without actually creating any objects or executing any effects.\nval plan = Injector().plan(HelloByeModule, GCMode.NoGC)\n// plan: izumi.distage.model.plan.OrderedPlan = {type.Session::App0::Byer} (basics.md:67) := call(<function1>(): Session::App0::PrintByer) {}\n// {type.Session::App0::Greeter} (basics.md:66) := call(<function1>(): Session::App0::PrintGreeter) {}\n// {type.Session::App0::HelloByeApp} (basics.md:68) := call(<function1>(Session::App0::Greeter, Session::App0::Byer): Session::App0::HelloByeApp) {\n//   arg greeter: Session::App0::Greeter = lookup({type.Session::App0::Greeter})\n//   arg byer: Session::App0::Byer = lookup({type.Session::App0::Byer})\n// }\nThe series of steps must be executed to produce the object graph. Injector.produce will interpret the steps into a Resource value, that holds the lifecycle of the object graph:\n// Interpret into DIResource\n\nval resource = Injector().produce(plan)\n// resource: izumi.distage.model.definition.DIResource.DIResourceBase[izumi.fundamentals.platform.functional.package.Identity, izumi.distage.model.Locator] = izumi.distage.model.definition.DIResource$$anon$10@fee29b4\n\n// Use the object graph:\n// After `.use` exits, all objects will be deallocated,\n// and all allocated resources will be freed.\n\nresource.use {\n  objects =>\n    objects.get[HelloByeApp].run()\n}\n// What's your name?\n// > izumi\n// Hello izumi!\n// Bye izumi!\n// res1: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\ndistage always creates components exactly once, even if multiple other objects depend on them. There is only a “Singleton” scope. It’s impossible to create non-singletons in distage. If you need multiple singleton instances of the same type, you can create named instances and disambiguate between them using @Id annotation.\nimport distage.Id\n\nnew ModuleDef {\n  make[Byer].named(\"byer-1\").from[PrintByer]\n  make[Byer].named(\"byer-2\").from {\n    otherByer: Byer @Id(\"byer-1\") =>\n      new Byer {\n        def bye(name: String) = otherByer.bye(s\"NOT-$name\")\n      }\n  }\n}\n// res2: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Byer@byer-2}].from(call(<function1>(repl.Session::repl.Session.App0::repl.Session.App0.Byer): {java.lang.Object & repl.Session::repl.Session.App0::repl.Session.App0.Byer})) ((basics.md:98)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Byer@byer-1}].from(call(<function1>(): repl.Session::repl.Session.App0::repl.Session.App0.PrintByer)) ((basics.md:97)))\nFor true non-singleton semantics, you must create explicit factory classes or generate them (see Auto-Factories)","title":"Quick Start"},{"location":"/distage/basics.html#activation-axis","text":"You can choose between different implementations of a component using Axis tags:\nimport distage.{Axis, Activation, ModuleDef, Injector, GCMode}\n\nclass AllCapsGreeter extends Greeter {\n  def hello(name: String) = println(s\"HELLO ${name.toUpperCase}\")\n}\n\n// declare the configuration axis for our components\n\nobject Style extends Axis {\n  case object AllCaps extends AxisValueDef\n  case object Normal extends AxisValueDef\n}\n\n// Declare a module with several implementations of Greeter\n// but in different environments\n\nval TwoImplsModule = new ModuleDef {\n  make[Greeter].tagged(Style.Normal)\n    .from[PrintGreeter]\n  \n  make[Greeter].tagged(Style.AllCaps)\n    .from[AllCapsGreeter]\n}\n// TwoImplsModule: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Greeter}].from(call(<function1>(): repl.Session::repl.Session.App0::repl.Session.App0.AllCapsGreeter)).tagged(Set(AxisTag(style:allcaps))) ((basics.md:128)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Greeter}].from(call(<function1>(): repl.Session::repl.Session.App0::repl.Session.App0.PrintGreeter)).tagged(Set(AxisTag(style:normal))) ((basics.md:125)))\n\n// Combine previous `HelloByeModule` with our new module\n// While overriding `make[Greeter]` bindings from the first module \n\nval CombinedModule = HelloByeModule overridenBy TwoImplsModule\n// CombinedModule: izumi.distage.model.definition.Module = Module(make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Byer}].from(call(<function1>(): repl.Session::repl.Session.App0::repl.Session.App0.PrintByer)) ((basics.md:67)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.HelloByeApp}].from(call(<function1>(repl.Session::repl.Session.App0::repl.Session.App0.Greeter, repl.Session::repl.Session.App0::repl.Session.App0.Byer): repl.Session::repl.Session.App0::repl.Session.App0.HelloByeApp)) ((basics.md:68)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Greeter}].from(call(<function1>(): repl.Session::repl.Session.App0::repl.Session.App0.AllCapsGreeter)).tagged(Set(AxisTag(style:allcaps))) ((basics.md:128)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Greeter}].from(call(<function1>(): repl.Session::repl.Session.App0::repl.Session.App0.PrintGreeter)).tagged(Set(AxisTag(style:normal))) ((basics.md:125)))\n\n// Choose component configuration when making an Injector:\n\nval capsInjector = Injector(Activation(Style -> Style.AllCaps))\n// capsInjector: Injector = izumi.distage.InjectorDefaultImpl@657d5daf\n\n// Check the result:\n\ncapsInjector\n  .produce(CombinedModule, GCMode.NoGC)\n  .use(_.get[HelloByeApp].run())\n// What's your name?\n// > kai\n// HELLO KAI\n// Bye kai!\n// res3: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\n\n// Check that result changes with a different configuration:\n\nInjector(Activation(Style -> Style.Normal))\n  .produce(CombinedModule, GCMode.NoGC)\n  .use(_.get[HelloByeApp].run())\n// What's your name?\n// > Pavel\n// Hello Pavel!\n// Bye Pavel!\n// res4: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\nIn distage.StandardAxis there are three example Axes for back-end development: Repo.Prod/Dummy, Env.Prod/Test & ExternalApi.Prod/Mock\nIn distage-framework’s RoleAppLauncher, you can choose axes using the -u command-line parameter:\n./launcher -u repo:dummy app1\nIn distage-testkit, specify axes via TestConfig:\nimport distage.StandardAxis.Repo\nimport izumi.distage.testkit.TestConfig\nimport izumi.distage.testkit.scalatest.DistageBIOSpecScalatest\n\nclass AxisTest extends DistageBIOSpecScalatest[zio.IO] {\n  override protected def config: TestConfig = TestConfig(\n    // choose implementations tagged `Repo.Dummy` when multiple implementations with `Repo.*` tags are available\n    activation = Activation(Repo -> Repo.Dummy)\n  )\n}","title":"Activation Axis"},{"location":"/distage/basics.html#resource-bindings-lifecycle","text":"You can specify objects’ lifecycle by injecting cats.effect.Resource, zio.ZManaged or distage.DIResource values that specify the allocation and finalization actions for an object.\nInjector itself only returns a DIResource value that can be used to create and finalize the object graph, this value is pure and can be reused multiple times. A DIResource is consumed using its .use method, the function passed to use will receive an allocated resource and when the function exits the resource will be deallocated.\nExample with cats.effect.Resource:\nimport distage.{GCMode, ModuleDef, Injector}\nimport cats.effect.{Bracket, Resource, IO}\n\nclass DBConnection\nclass MessageQueueConnection\n\nval dbResource = Resource.make(\n  acquire = IO { \n    println(\"Connecting to DB!\")\n    new DBConnection \n})(release = _ => IO(println(\"Disconnecting DB\")))\n// dbResource: Resource[IO, DBConnection] = Allocate(<function1>)\n\nval mqResource = Resource.make(\n  acquire = IO {\n   println(\"Connecting to Message Queue!\")\n   new MessageQueueConnection \n})(release = _ => IO(println(\"Disconnecting Message Queue\")))\n// mqResource: Resource[IO, MessageQueueConnection] = Allocate(<function1>)\n\nclass MyApp(db: DBConnection, mq: MessageQueueConnection) {\n  val run = IO(println(\"Hello World!\"))\n}\n\nval module = new ModuleDef {\n  make[DBConnection].fromResource(dbResource)\n  make[MessageQueueConnection].fromResource(mqResource)\n  addImplicit[Bracket[IO, Throwable]]\n  make[MyApp]\n}\n// module: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App5::repl.Session.App5.MyApp}].from(call(<function1>(repl.Session::repl.Session.App5::repl.Session.App5.DBConnection, repl.Session::repl.Session.App5::repl.Session.App5.MessageQueueConnection): repl.Session::repl.Session.App5::repl.Session.App5.MyApp)) ((basics.md:210)), make[{type.cats.effect.Bracket[=? %1:0 ? IO[+1:0],=Throwable]}].from(value(cats.effect.IOLowPriorityInstances$IOEffect@7a937a5c)) ((basics.md:209)), make[{type.repl.Session::repl.Session.App5::repl.Session.App5.MessageQueueConnection}].from(allocate[? %0 ? cats.effect.IO[+0]](call(izumi.distage.model.reflection.universe.RuntimeDIUniverse.Provider$ProviderImpl$$Lambda$17021/0x0000000844030840@1896a6c5(cats.effect.Bracket[=? %0 ? IO[+0],=Throwable]): izumi.distage.model.definition.DIResource::izumi.distage.model.definition.DIResource.Cats[=? %1:0 ? IO[+1:0],=Session::App5::MessageQueueConnection]))) ((basics.md:208)), make[{type.repl.Session::repl.Session.App5::repl.Session.App5.DBConnection}].from(allocate[? %0 ? cats.effect.IO[+0]](call(izumi.distage.model.reflection.universe.RuntimeDIUniverse.Provider$ProviderImpl$$Lambda$17021/0x0000000844030840@d659696(cats.effect.Bracket[=? %0 ? IO[+0],=Throwable]): izumi.distage.model.definition.DIResource::izumi.distage.model.definition.DIResource.Cats[=? %1:0 ? IO[+1:0],=Session::App5::DBConnection]))) ((basics.md:207)))\nWill produce the following output:\nval objectGraphResource = Injector().produceF[IO](module, GCMode.NoGC)\n// objectGraphResource: izumi.distage.model.definition.DIResource.DIResourceBase[IO, izumi.distage.model.Locator] = izumi.distage.model.definition.DIResource$$anon$10@3f96cc9\n\nobjectGraphResource\n  .use(_.get[MyApp].run)\n  .unsafeRunSync()\n// Connecting to Message Queue!\n// Connecting to DB!\n// Hello World!\n// Disconnecting DB\n// Disconnecting Message Queue\nLifecycle management DIResource is also available without an effect type, via DIResource.Simple and DIResource.Mutable:\nimport distage.{DIResource, GCMode, ModuleDef, Injector}\n\nclass Init {\n  var initialized = false\n}\n\nclass InitResource extends DIResource.Simple[Init] {\n  override def acquire = {\n    val init = new Init\n    init.initialized = true\n    init\n  }\n  override def release(init: Init) = {\n    init.initialized = false\n  }\n}\n\nval module = new ModuleDef {\n  make[Init].fromResource[InitResource]\n}\n// module: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App7::repl.Session.App7.Init}].from(allocate[? %0 ? 0](call(<function1>(): repl.Session::repl.Session.App7::repl.Session.App7.InitResource))) ((basics.md:252)))\n\nval closedInit = Injector().produce(module, GCMode.NoGC).use {\n  objects =>\n    val init = objects.get[Init] \n    println(init.initialized)\n    init\n}\n// true\n// closedInit: izumi.fundamentals.platform.functional.package.Identity[Init] = repl.Session$App7$Init@46caf4c2\n\nprintln(closedInit.initialized)\n// false\nDIResource forms a monad and has the expected .map, .flatMap, .evalMap, .mapK methods.\nYou can convert between DIResource and cats.effect.Resource via .toCats/.fromCats methods, and between zio.ZManaged via .toZIO/.fromZIO.\nYou need to use resource-aware Injector.produce/Injector.produceF, instead of produceUnsafe to be able to deallocate the object graph.","title":"Resource Bindings, Lifecycle"},{"location":"/distage/basics.html#set-bindings","text":"Set bindings are useful for implementing listeners, plugins, hooks, http routes, healthchecks, migrations, etc. Everywhere where a collection of components is required, a Set Binding is appropriate.\nTo define a Set binding use .many and .add methods of the ModuleDef DSL.\nFor example, we may declare many http4s routes and serve them all from a central router:\n// import boilerplate\nimport cats.implicits._\nimport cats.effect.{Bracket, IO, Resource}\nimport distage.{GCMode, ModuleDef, Injector}\nimport org.http4s._\nimport org.http4s.server.Server\nimport org.http4s.client.Client\nimport org.http4s.dsl.io._\nimport org.http4s.implicits._\nimport org.http4s.server.blaze.BlazeServerBuilder\nimport org.http4s.client.blaze.BlazeClientBuilder\n\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nimplicit val contextShift = IO.contextShift(global)\nimplicit val timer = IO.timer(global)\nval homeRoute = HttpRoutes.of[IO] { \n  case GET -> Root / \"home\" => Ok(s\"Home page!\") \n}\n// homeRoute: HttpRoutes[IO] = Kleisli(org.http4s.HttpRoutes$$$Lambda$17060/0x0000000844057840@100d75f7)\n\nobject HomeRouteModule extends ModuleDef {\n  many[HttpRoutes[IO]]\n    .add(homeRoute)\n}\nWe’ve used many method to declare an open Set of http routes and then added one HTTP route into it. When module definitions are combined, Sets for the same binding will be merged together. You can summon a Set Bindings by summoning a scala Set, as in Set[HttpRoutes[IO]].\nLet’s define a new module with another route:\nval blogRoute = HttpRoutes.of[IO] { \n  case GET -> Root / \"blog\" / post => Ok(s\"Blog post ``$post''!\") \n}\n// blogRoute: HttpRoutes[IO] = Kleisli(org.http4s.HttpRoutes$$$Lambda$17060/0x0000000844057840@135911cc)\n\nobject BlogRouteModule extends ModuleDef {  \n  many[HttpRoutes[IO]]\n    .add(blogRoute)\n}\nNow it’s the time to define a Server component to serve all the different routes we have:\ndef makeHttp4sServer(routes: Set[HttpRoutes[IO]]): Resource[IO, Server[IO]] = {\n  // create a top-level router by combining all the routes\n  val router: HttpApp[IO] = routes.toList.foldK.orNotFound\n\n  // return a Resource value that will setup an http4s server \n  BlazeServerBuilder[IO]\n    .bindHttp(8080, \"localhost\")\n    .withHttpApp(router)\n    .resource\n}\n\nobject HttpServerModule extends ModuleDef {\n  make[Server[IO]].fromResource(makeHttp4sServer _)\n  make[Client[IO]].fromResource(BlazeClientBuilder[IO](global).resource)\n  addImplicit[Bracket[IO, Throwable]] // required for cats `Resource` in `fromResource`\n}\n\n// join all the module definitions\nval finalModule = Seq(\n  HomeRouteModule,\n  BlogRouteModule,\n  HttpServerModule,\n).merge\n// finalModule: izumi.distage.model.definition.Module = Module(make[{type.org.http4s.client.Client[=? %1:0 ? IO[+1:0]]}].from(allocate[? %0 ? cats.effect.IO[+0]](call(izumi.distage.model.reflection.universe.RuntimeDIUniverse.Provider$ProviderImpl$$Lambda$17021/0x0000000844030840@287e724e(cats.effect.Bracket[=? %0 ? IO[+0],=Throwable]): izumi.distage.model.definition.DIResource::izumi.distage.model.definition.DIResource.Cats[=? %1:0 ? IO[+1:0],=Client[=? %2:0 ? IO[+2:0]]]))) ((basics.md:357)), make[{type.org.http4s.server.Server[=? %1:0 ? IO[+1:0]]}].from(allocate[? %0 ? cats.effect.IO[+0]](call(izumi.distage.model.reflection.universe.RuntimeDIUniverse.Provider$ProviderImpl$$Lambda$17021/0x0000000844030840@7c2b9e69(scala.collection.immutable.Set[=Kleisli[=? %2:0 ? OptionT[=? %4:0 ? IO[+4:0],=2:0],-Request[=? %3:0 ? IO[+3:0]],=Response[=? %3:0 ? IO[+3:0]]]], cats.effect.Bracket[=? %0 ? IO[+0],=Throwable]): izumi.distage.model.definition.DIResource::izumi.distage.model.definition.DIResource.Cats[=? %1:0 ? IO[+1:0],=Server[=? %2:0 ? IO[+2:0]]]))) ((basics.md:356)), many[{type.scala.collection.immutable.Set[=Kleisli[=? %2:0 ? OptionT[=? %4:0 ? IO[+4:0],=2:0],-Request[=? %3:0 ? IO[+3:0]],=Response[=? %3:0 ? IO[+3:0]]]]}].add[{type.cats.data.Kleisli[=? %1:0 ? OptionT[=? %3:0 ? IO[+3:0],=1:0],-Request[=? %2:0 ? IO[+2:0]],=Response[=? %2:0 ? IO[+2:0]]]}].from(call(izumi.distage.model.providers.ProviderMagnet$$$Lambda$15530/0x0000000843a44040@312f5cf4(): cats.data.Kleisli[=? %1:0 ? OptionT[=? %3:0 ? IO[+3:0],=1:0],-Request[=? %2:0 ? IO[+2:0]],=Response[=? %2:0 ? IO[+2:0]]])) ((basics.md:336)), many[{type.scala.collection.immutable.Set[=Kleisli[=? %2:0 ? OptionT[=? %4:0 ? IO[+4:0],=2:0],-Request[=? %3:0 ? IO[+3:0]],=Response[=? %3:0 ? IO[+3:0]]]]}] ((basics.md:321)), make[{type.cats.effect.Bracket[=? %1:0 ? IO[+1:0],=Throwable]}].from(value(cats.effect.IOInstances$$anon$2@1ad53d96)) ((basics.md:358)), many[{type.scala.collection.immutable.Set[=Kleisli[=? %2:0 ? OptionT[=? %4:0 ? IO[+4:0],=2:0],-Request[=? %3:0 ? IO[+3:0]],=Response[=? %3:0 ? IO[+3:0]]]]}].add[{type.cats.data.Kleisli[=? %1:0 ? OptionT[=? %3:0 ? IO[+3:0],=1:0],-Request[=? %2:0 ? IO[+2:0]],=Response[=? %2:0 ? IO[+2:0]]]}].from(call(izumi.distage.model.providers.ProviderMagnet$$$Lambda$15530/0x0000000843a44040@1d05e394(): cats.data.Kleisli[=? %1:0 ? OptionT[=? %3:0 ? IO[+3:0],=1:0],-Request[=? %2:0 ? IO[+2:0]],=Response[=? %2:0 ? IO[+2:0]]])) ((basics.md:322)))\n\n// wire the graph\nval objects = Injector().produceUnsafeF[IO](finalModule, GCMode.NoGC).unsafeRunSync()\n// objects: izumi.distage.model.Locator = izumi.distage.LocatorDefaultImpl@77d75765\n\nval server = objects.get[Server[IO]]\n// server: Server[IO] = BlazeServer(/127.0.0.1:8080)\nval client = objects.get[Client[IO]]\n// client: Client[IO] = org.http4s.client.Client$$anon$1@66aac1b9\nCheck if it works:\n// check home page\nclient.expect[String](\"http://localhost:8080/home\").unsafeRunSync()\n// res10: String = Home page!\n\n// check blog page\nclient.expect[String](\"http://localhost:8080/blog/1\").unsafeRunSync()\n// res11: String = Blog post ``1''!\nFurther reading: the same concept is called Multibindings in Guice.","title":"Set Bindings"},{"location":"/distage/basics.html#effect-bindings","text":"Sometimes we want to effectfully create a component, but the resulting component or data does not need to be deallocated. An example might be a global Semaphore to limit the parallelism of the entire application based on configuration, or a test implementation of some service made with Refs.\nIn these cases we can use .fromEffect to create a value using an effectful constructor.\nExample with a Ref-based Tagless Final KVStore:\nimport distage.{GCMode, ModuleDef, Injector}\nimport izumi.functional.bio.{BIOMonadError, BIOPrimitives, F}\nimport zio.{Task, IO}\n\ntrait KVStore[F[_, _]] {\n  def get(key: String): F[NoSuchElementException, String]\n  def put(key: String, value: String): F[Nothing, Unit]\n}\n\ndef dummyKVStore[F[+_, +_]: BIOMonadError: BIOPrimitives]: F[Nothing, KVStore[F]] = {\n  for {\n    ref <- F.mkRef(Map.empty[String, String])\n  } yield new KVStore[F] {\n    def put(key: String, value: String): F[Nothing, Unit] = {\n      ref.update_(_ + (key -> value))\n    }\n  \n    def get(key: String): F[NoSuchElementException, String] = {\n      for {\n        map <- ref.get\n        res <- map.get(key) match {\n          case Some(value) => F.pure(value)\n          case None        => F.fail(new NoSuchElementException(key))\n        }\n      } yield res\n    }\n  }\n}\n\nval kvStoreModule = new ModuleDef {\n  make[KVStore[IO]].fromEffect(dummyKVStore[IO])\n}\n// kvStoreModule: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App13::repl.Session.App13.KVStore[=? %1:0,%1:1 ? ZIO[-Any,+1:0,+1:1]]}].from(effect[? %0 ? zio.ZIO[-Any,+Nothing,+0]](value(zio.ZIO$FlatMap@373293a5))) ((basics.md:436)))\n\nval io = Injector()\n  .produceF[Task](kvStoreModule, GCMode.NoGC)\n  .use {\n    objects =>\n      val kv = objects.get[KVStore[IO]]\n      \n      for {\n        _    <- kv.put(\"apple\", \"pie\")\n        res1 <- kv.get(\"apple\")\n        _    <- kv.put(\"apple\", \"ipad\")\n        res2 <- kv.get(\"apple\")\n      } yield res1 + res2\n  }\n// io: Task[String] = zio.ZIO$CheckInterrupt@3b49b34b\n\nnew zio.DefaultRuntime{}.unsafeRun(io)\n// res14: String = pieipad\nYou need to use effect-aware Injector.produceF/Injector.produceUnsafeF methods to use effect bindings.","title":"Effect Bindings"},{"location":"/distage/basics.html#auto-traits","text":"distage can instantiate traits and structural types. All unimplemented fields in a trait or a refinement are filled in from the object graph.\nThis can be used to create ZIO Environment cakes with required dependencies - https://gitter.im/ZIO/Core?at=5dbb06a86570b076740f6db2\nTrait implementations are derived at compile-time by TraitConstructor macro and can be summoned at need. Example:\nimport distage.{DIKey, GCMode, ModuleDef, Injector, ProviderMagnet, Tag}\nimport izumi.distage.constructors.TraitConstructor\nimport zio.console.{Console, putStrLn}\nimport zio.{UIO, URIO, URManaged, ZIO, Ref, Task}\n\ntrait Hello {\n  def hello: UIO[String]\n}\ntrait World {\n  def world: UIO[String]\n}\n\n// Environment forwarders that allow\n// using service functions from everywhere\n\nval hello: URIO[{def hello: Hello}, String] = ZIO.accessM(_.hello.hello)\n// hello: URIO[{def hello: App15.this.Hello}, String] = zio.ZIO$Read@7e121ccf\n\nval world: URIO[{def world: World}, String] = ZIO.accessM(_.world.world)\n// world: URIO[{def world: App15.this.World}, String] = zio.ZIO$Read@6d41b21a\n\n// service implementations\n\nval makeHello = {\n  (for {\n    _     <- putStrLn(\"Creating Enterprise Hellower...\")\n    hello = new Hello { val hello = UIO(\"Hello\") }\n  } yield hello).toManaged { _ =>\n    putStrLn(\"Shutting down Enterprise Hellower\")\n  }\n}\n// makeHello: zio.ZManaged[Console, Nothing, AnyRef with Hello{val hello: zio.UIO[String]}] = zio.ZManaged@13ffd978\n\nval makeWorld = {\n  for {\n    counter <- Ref.make(0)\n  } yield new World {\n    val world = counter.get.map(c => if (c < 1) \"World\" else \"THE World\")\n  }\n}\n// makeWorld: ZIO[Any, Nothing, AnyRef with World{val world: zio.ZIO[Any,Nothing,String]}] = zio.ZIO$FlatMap@2e82e94f\n\n// the main function\n\nval turboFunctionalHelloWorld = {\n  for {\n    hello <- hello\n    world <- world\n    _     <- putStrLn(s\"$hello $world\")\n  } yield ()\n}\n// turboFunctionalHelloWorld: ZIO[AnyRef with AnyRef with Console{def hello: App15.this.Hello;def world: App15.this.World}, Nothing, Unit] = zio.ZIO$FlatMap@d7f0332\n\n// a generic function that creates an `R` trait where all fields are populated from the object graph\n\ndef provideCake[R: TraitConstructor, A: Tag](fn: R => A): ProviderMagnet[A] = {\n  TraitConstructor[R].provider.map(fn)\n}\n\nval definition = new ModuleDef {\n  make[Hello].fromResource(provideCake(makeHello.provide(_)))\n  make[World].fromEffect(makeWorld)\n  make[Console.Service[Any]].fromValue(Console.Live.console)\n  make[UIO[Unit]].from(provideCake(turboFunctionalHelloWorld.provide))\n}\n// definition: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App15::repl.Session.App15.Hello}].from(allocate[? %0 ? zio.ZIO[-Any,+Nothing,+0]](call(izumi.distage.model.reflection.universe.RuntimeDIUniverse.Provider$ProviderImpl$$Lambda$17021/0x0000000844030840@1e814df5(zio.console.Console::zio.console.Console.Service[=Any]): izumi.distage.model.definition.DIResource::izumi.distage.model.definition.DIResource.Zio[=Any,=Nothing,=({Object & Session::App15::Hello} & {def hello(): ZIO[-Any,+Nothing,+String]})]))) ((basics.md:526)), make[{type.zio.ZIO[-Any,+Nothing,+Unit]}].from(call(izumi.distage.model.reflection.universe.RuntimeDIUniverse.Provider$ProviderImpl$$Lambda$17021/0x0000000844030840@614248d4(repl.Session::repl.Session.App15::repl.Session.App15.Hello, repl.Session::repl.Session.App15::repl.Session.App15.World, zio.console.Console::zio.console.Console.Service[=Any]): zio.ZIO[-Any,+Nothing,+Unit])) ((basics.md:529)), make[{type.repl.Session::repl.Session.App15::repl.Session.App15.World}].from(effect[? %0 ? zio.ZIO[-Any,+Nothing,+0]](value(zio.ZIO$FlatMap@2e82e94f))) ((basics.md:527)), make[{type.zio.console.Console::zio.console.Console.Service[=Any]}].from(value(zio.console.Console$Live$$anon$1@3513819c)) ((basics.md:528)))\n\nval main = Injector()\n  .produceF[Task](definition, GCMode(DIKey.get[UIO[Unit]]))\n  .use(_.get[UIO[Unit]])\n// main: Task[Unit] = zio.ZIO$CheckInterrupt@2c2b8539\n\nnew zio.DefaultRuntime{}.unsafeRun(main)\n// Creating Enterprise Hellower...\n// Hello World\n// Shutting down Enterprise Hellower","title":"Auto-Traits"},{"location":"/distage/basics.html#auto-factories","text":"distage can instantiate ‘factory’ classes from suitable traits. This feature is especially useful with Akka. All unimplemented methods with parameters in a trait will be filled by factory methods:\nGiven a class ActorFactory:\nimport distage._\nimport java.util.UUID\n\nclass SessionStorage\n\nclass UserActor(sessionId: UUID, sessionStorage: SessionStorage)\n\ntrait ActorFactory {\n  // UserActor will be created as follows:\n  //   sessionId argument is provided by the user\n  //   sessionStorage argument is wired from the object graph\n  def createActor(sessionId: UUID): UserActor\n}\nAnd a binding of ActorFactory without an implementation\nclass ActorModule extends ModuleDef {\n  make[ActorFactory]\n}\ndistage will derive and bind the following implementation for ActorFactory:\nclass ActorFactoryImpl(sessionStorage: SessionStorage) extends ActorFactory {\n  override def createActor(sessionId: UUID): UserActor = {\n    new UserActor(sessionId, sessionStorage)\n  }\n}\n@With annotation can be used to specify the implementation class, when the factory result is abstract:\ntrait Actor { \n def anyToUnit: Any => Unit = _ => ()\n}\n\nobject Actor {\n  trait Factory {\n    def mkActor(name: String): Actor @With[Actor.Impl]\n  }\n\n  final class Impl(name: String) extends Actor{\n    override def anyToUnit: Any => Unit = msg => println(s\"Actor `$name` received a message: $msg\")\n  }\n}\n\nval factoryModule = new ModuleDef {\n  make[Actor.Factory]\n}\n// factoryModule: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App15::repl.Session.App15.Actor::repl.Session.App15.Actor.Factory}].from(call(<function1>(): repl.Session::repl.Session.App15::repl.Session.App15.Actor::repl.Session.App15.Actor.Factory)) ((basics.md:602)))\n\nInjector()\n  .produce(factoryModule, GCMode.NoGC)\n  .use(_.get[Actor.Factory].mkActor(\"Martin\").anyToUnit(\"ping\"))\n// Actor `Martin` received a message: ping\n// res17: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\nYou can use this feature to concisely provide non-Singleton semantics for some of your components.\nFactory implementations are derived at compile-time by FactoryConstructor macro and can be summoned at need.","title":"Auto-Factories"},{"location":"/distage/basics.html#tagless-final-style","text":"Tagless Final is one of the popular patterns for structuring purely-functional applications. If you’re not familiar with tagless final you can skip this section.\nBrief introduction to tagless final:\nDeferring Commitments: Tagless Final Introduction to Tagless Final\nAdvantages of distage as a driver for TF compared to implicits:\neasy explicit overrides easy effectful instantiation and resource management extremely easy & scalable test context setup due to the above multiple different implementations for a type using disambiguation by @Id\nFor example, let’s take freestyle’s tagless example and make it safer and more flexible by replacing dependencies on global imported implementations from with explicit modules.\nFirst, the program we want to write:\nimport cats.Monad\nimport cats.effect.{ExitCode, Sync, IO}\nimport cats.syntax.all._\nimport distage.{GCMode, Module, ModuleDef, Injector, Tag, TagK, TagKK}\n\ntrait Validation[F[_]] {\n  def minSize(s: String, n: Int): F[Boolean]\n  def hasNumber(s: String): F[Boolean]\n}\ndef Validation[F[_]: Validation]: Validation[F] = implicitly\n\ntrait Interaction[F[_]] {\n  def tell(msg: String): F[Unit]\n  def ask(prompt: String): F[String]\n}\ndef Interaction[F[_]: Interaction]: Interaction[F] = implicitly\n\nclass TaglessProgram[F[_]: Monad: Validation: Interaction] {\n  def program: F[Unit] = for {\n    userInput <- Interaction[F].ask(\"Give me something with at least 3 chars and a number on it\")\n    valid     <- (Validation[F].minSize(userInput, 3), Validation[F].hasNumber(userInput)).mapN(_ && _)\n    _         <- if (valid) Interaction[F].tell(\"awesomesauce!\")\n                 else       Interaction[F].tell(s\"$userInput is not valid\")\n  } yield ()\n}\n\ndef ProgramModule[F[_]: TagK: Monad]: Module = new ModuleDef {\n  make[TaglessProgram[F]]\n  addImplicit[Monad[F]]\n}\nTagK is distage’s analogue of TypeTag for higher-kinded types such as F[_], it allows preserving type-information at runtime for type parameters. You’ll need to add a TagK context bound to create a module parameterized by an abstract F[_]. To parameterize by non-higher-kinded types, use just Tag.\nNow the interpreters for Validation and Interaction:\nfinal class SyncValidation[F[_]](implicit F: Sync[F]) extends Validation[F] {\n  def minSize(s: String, n: Int): F[Boolean] = F.delay(s.size >= n)\n  def hasNumber(s: String): F[Boolean]       = F.delay(s.exists(c => \"0123456789\".contains(c)))\n}\n  \nfinal class SyncInteraction[F[_]](implicit F: Sync[F]) extends Interaction[F] {\n  def tell(s: String): F[Unit]  = F.delay(println(s))\n  def ask(s: String): F[String] = F.delay(\"This could have been user input 1\")\n}\n\ndef SyncInterpreters[F[_]: TagK: Sync] = {\n  new ModuleDef {\n    make[Validation[F]].from[SyncValidation[F]]\n    make[Interaction[F]].from[SyncInteraction[F]]\n    addImplicit[Sync[F]]\n  }\n}\n\n// combine all modules\n\ndef SyncProgram[F[_]: TagK: Sync] = ProgramModule[F] ++ SyncInterpreters[F]\n\n// create object graph Resource\n\nval objectsResource = Injector().produceF[IO](SyncProgram[IO], GCMode.NoGC)\n// objectsResource: izumi.distage.model.definition.DIResource.DIResourceBase[IO, izumi.distage.model.Locator] = izumi.distage.model.definition.DIResource$$anon$10@9f6a142\n\n// run\n\nobjectsResource.use(_.get[TaglessProgram[IO]].program).unsafeRunSync()\n// awesomesauce!\nThe program module is polymorphic over effect type. It can be instantiated by a different effect:\nimport zio.interop.catz._\nimport zio.Task\n\nval ZIOProgram = ProgramModule[Task] ++ SyncInterpreters[Task]\n// ZIOProgram: Module = Module(make[{type.repl.Session::repl.Session.App18::repl.Session.App18.Validation[=? %0 ? ZIO[-Any,+Throwable,+0]]}].from(call(<function1>(cats.effect.Sync[=? %0 ? ZIO[-Any,+Throwable,+0]]): repl.Session::repl.Session.App18::repl.Session.App18.SyncValidation[=? %0 ? ZIO[-Any,+Throwable,+0]])) ((basics.md:680)), make[{type.cats.Monad[=? %0 ? ZIO[-Any,+Throwable,+0]]}].from(value(zio.interop.CatsConcurrent@296c9dfb)) ((basics.md:659)), make[{type.cats.effect.Sync[=? %0 ? ZIO[-Any,+Throwable,+0]]}].from(value(zio.interop.CatsConcurrent@296c9dfb)) ((basics.md:682)), make[{type.repl.Session::repl.Session.App18::repl.Session.App18.TaglessProgram[=? %0 ? ZIO[-Any,+Throwable,+0]]}].from(call(<function1>(cats.Monad[=? %0 ? ZIO[-Any,+Throwable,+0]], repl.Session::repl.Session.App18::repl.Session.App18.Validation[=? %0 ? ZIO[-Any,+Throwable,+0]], repl.Session::repl.Session.App18::repl.Session.App18.Interaction[=? %0 ? ZIO[-Any,+Throwable,+0]]): repl.Session::repl.Session.App18::repl.Session.App18.TaglessProgram[=? %0 ? ZIO[-Any,+Throwable,+0]])) ((basics.md:658)), make[{type.repl.Session::repl.Session.App18::repl.Session.App18.Interaction[=? %0 ? ZIO[-Any,+Throwable,+0]]}].from(call(<function1>(cats.effect.Sync[=? %0 ? ZIO[-Any,+Throwable,+0]]): repl.Session::repl.Session.App18::repl.Session.App18.SyncInteraction[=? %0 ? ZIO[-Any,+Throwable,+0]])) ((basics.md:681)))\nWe may even choose different interpreters at runtime:\nimport zio.RIO\nimport zio.console.{Console, getStrLn, putStrLn}\n\nobject RealInteractionZIO extends Interaction[RIO[Console, ?]] {\n  def tell(s: String): RIO[Console, Unit]  = putStrLn(s)\n  def ask(s: String): RIO[Console, String] = putStrLn(s) *> getStrLn\n}\n\nval RealInterpretersZIO = {\n  SyncInterpreters[RIO[Console, ?]] overridenBy new ModuleDef {\n    make[Interaction[RIO[Console, ?]]].from(RealInteractionZIO)\n  }\n}\n// RealInterpretersZIO: Module = Module(make[{type.repl.Session::repl.Session.App18::repl.Session.App18.Interaction[=? %1:0 ? ZIO[-Console,+Throwable,+1:0]]}].from(call(izumi.distage.model.providers.ProviderMagnet$$$Lambda$15530/0x0000000843a44040@5db2e7c(): repl.Session.App18.RealInteractionZIO)) ((basics.md:725)), make[{type.cats.effect.Sync[=? %0 ? ZIO[-Console,+Throwable,+0]]}].from(value(zio.interop.CatsConcurrent@296c9dfb)) ((basics.md:682)), make[{type.repl.Session::repl.Session.App18::repl.Session.App18.Validation[=? %0 ? ZIO[-Console,+Throwable,+0]]}].from(call(<function1>(cats.effect.Sync[=? %0 ? ZIO[-Console,+Throwable,+0]]): repl.Session::repl.Session.App18::repl.Session.App18.SyncValidation[=? %0 ? ZIO[-Console,+Throwable,+0]])) ((basics.md:680)))\n\ndef chooseInterpreters(isDummy: Boolean) = {\n  val interpreters = if (isDummy) SyncInterpreters[RIO[Console, ?]]\n                     else         RealInterpretersZIO\n  val module = ProgramModule[RIO[Console, ?]] ++ interpreters\n  Injector().produceGetF[RIO[Console, ?], TaglessProgram[RIO[Console, ?]]](module)\n}\n\n// execute\n\nchooseInterpreters(true)\n// res20: izumi.distage.model.definition.DIResource.DIResourceBase[zio.ZIO[Console, Throwable, ?$5$], TaglessProgram[zio.ZIO[Console, Throwable, ?$6$]]] = izumi.distage.model.definition.DIResource$$anon$9@ff217aa\nModules can be polymorphic over arbitrary kinds - use TagKK to abstract over bifunctors:\nclass BifunctorIOModule[F[_, _]: TagKK] extends ModuleDef\nOr use Tag.auto.T to abstract over any kind:\nclass MonadTransModule[F[_[_], _]: Tag.auto.T] extends ModuleDef\nclass TrifunctorModule[F[_, _, _]: Tag.auto.T] extends ModuleDef\nclass EldritchModule[F[+_, -_[_, _], _[_[_, _], _], _]: Tag.auto.T] extends ModuleDef\nconsult HKTag docs for more details.","title":"Tagless Final Style"},{"location":"/distage/basics.html#cats-zio-integration","text":"Cats & ZIO instances and syntax are available automatically without imports, if cats-core, cats-effect or zio are already dependencies of your project. (Note: distage won’t bring cats or zio as a dependency if you don’t already use them. See No More Orphans for description of the technique)\nCats Resource Bindings will also work out of the box without any magic imports.\nExample:\nimport cats.effect.IOApp\nimport distage.DIKey\n\ntrait AppEntrypoint {\n  def run: IO[Unit]\n}\n\nobject Main extends IOApp {\n  def run(args: List[String]): IO[ExitCode] = {\n    // ModuleDef has a Monoid instance\n    val myModules = ProgramModule[IO] |+| SyncInterpreters[IO]\n    val plan = Injector().plan(myModules, GCMode(DIKey.get[AppEntrypoint]))\n\n    for {\n      // resolveImportsF can effectfully add missing instances to an existing plan\n      // (You can also create instances effectfully inside `ModuleDef` via `make[_].fromEffect` bindings)\n      newPlan <- plan.resolveImportsF[IO] {\n        case i if i.target == DIKey.get[DBConnection] =>\n           DBConnection.create[IO]\n      } \n      // `produceF` specifies an Effect to run in.\n      // Effects used in Resource and Effect Bindings \n      // should match the effect in `produceF`\n      _ <- Injector().produceF[IO](newPlan).use {\n        classes =>\n          classes.get[AppEntrypoint].run\n      }\n    } yield ExitCode.Success\n  }\n}","title":"Cats & ZIO Integration"},{"location":"/distage/advanced-features.html","text":"","title":"Advanced Features ? Izumi Project"},{"location":"/distage/advanced-features.html#advanced-features","text":"Garbage Collection Circular Dependencies Support Automatic Resolution with generated proxies Manual Resolution with by-name parameters Auto-Sets Weak Sets Inner Classes and Path-Dependent Types Depending on Locator","title":"Advanced Features"},{"location":"/distage/advanced-features.html#garbage-collection","text":"A garbage collector is included in distage by default. Given a set of GC root keys, GC will remove all bindings that are neither direct nor transitive dependencies of the supplied roots ? these bindings will be thrown out and never instantiated.\nGC serves two important purposes:\nIt enables faster tests by omitting unrequired instantiations and initialization of potentially heavy resources, It enables multiple independent applications, aka “Roles” to be hosted within a single .jar file.\nTo use garbage collector, pass GC roots as an argument to Injector.produce* methods:\nimport distage._\n\ncase class A(b: B)\ncase class B()\ncase class C() {\n  println(\"C!\")\n}\n\nval module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n// module: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App0::repl.Session.App0.C}].from(call(<function1>(): repl.Session::repl.Session.App0::repl.Session.App0.C)) ((advanced-features.md:28)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.A}].from(call(<function1>(repl.Session::repl.Session.App0::repl.Session.App0.B): repl.Session::repl.Session.App0::repl.Session.App0.A)) ((advanced-features.md:26)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.B}].from(call(<function1>(): repl.Session::repl.Session.App0::repl.Session.App0.B)) ((advanced-features.md:27)))\n\n// declare `A` as a GC root\n\nval roots = GCMode.GCRoots(Set[DIKey](DIKey.get[A]))\n// roots: package.GCMode.GCRoots = GCRoots(Set({type.repl.Session::repl.Session.App0::repl.Session.App0.A}))\n\n// create an object graph from description in `module`\n// with `A` as a GC root\n\nval objects = Injector().produceUnsafe(module, roots)\n// objects: Locator = izumi.distage.LocatorDefaultImpl@49c5baad\n\n// A and B are in the object graph\n\nobjects.find[A]\n// res1: Option[A] = Some(A(B()))\nobjects.find[B]\n// res2: Option[B] = Some(B())\n\n// C is missing\n\nobjects.find[C]\n// res3: Option[C] = None\nClass C was removed because neither B nor A depended on it. It’s not present in the Locator and the \"C!\" message was never printed. But, if class B were to depend on C as in case class B(c: C), it would’ve been retained, because A - the GC root, would depend on B which in turns depends on C.","title":"Garbage Collection"},{"location":"/distage/advanced-features.html#circular-dependencies-support","text":"distage automatically resolves arbitrary circular dependencies, including self-references:\nimport distage.{GCMode, ModuleDef, Injector}\n\nclass A(val b: B)\nclass B(val a: A)  \nclass C(val c: C)\n\nval locator = Injector().produceUnsafe(new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}, GCMode.NoGC)\n// locator: izumi.distage.model.Locator = izumi.distage.LocatorDefaultImpl@747162f3\n\nlocator.get[A] eq locator.get[B].a\n// res5: Boolean = true\nlocator.get[B] eq locator.get[A].b\n// res6: Boolean = true\nlocator.get[C] eq locator.get[C].c\n// res7: Boolean = true","title":"Circular Dependencies Support"},{"location":"/distage/advanced-features.html#automatic-resolution-with-generated-proxies","text":"The above strategy depends on distage-core-proxy-cglib module which is a default dependency of distage-core.\nIf you want to disable it, use NoProxies bootstrap configuration:\nInjector.NoProxies()\n// res8: Injector = izumi.distage.InjectorDefaultImpl@5e139789","title":"Automatic Resolution with generated proxies"},{"location":"/distage/advanced-features.html#manual-resolution-with-by-name-parameters","text":"Most cycles can be resolved manually when identified using By Name parameters.\nCircular dependencies in the following example are all resolved via Scala’s native By Name, no proxies are generated:\nimport distage.{GCMode, ModuleDef, Injector}\n\nclass A(b0: => B) {\n  def b: B = b0\n}\n\nclass B(a0: => A) {\n  def a: A = a0\n}\n\nclass C(self: => C) {\n  def c: C = self\n}\n\nval module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n// module: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App9::repl.Session.App9.A}].from(call(<function1>(repl.Session::repl.Session.App9::repl.Session.App9.B): repl.Session::repl.Session.App9::repl.Session.App9.A)) ((advanced-features.md:112)), make[{type.repl.Session::repl.Session.App9::repl.Session.App9.C}].from(call(<function1>(repl.Session::repl.Session.App9::repl.Session.App9.C): repl.Session::repl.Session.App9::repl.Session.App9.C)) ((advanced-features.md:114)), make[{type.repl.Session::repl.Session.App9::repl.Session.App9.B}].from(call(<function1>(repl.Session::repl.Session.App9::repl.Session.App9.A): repl.Session::repl.Session.App9::repl.Session.App9.B)) ((advanced-features.md:113)))\n\n// disable proxies and execute the module\n\nval locator = Injector.NoProxies()\n  .produceUnsafe(module, GCMode.NoGC)\n// locator: izumi.distage.model.Locator = izumi.distage.LocatorDefaultImpl@7f7c9277\n\nlocator.get[A].b eq locator.get[B]\n// res10: Boolean = true\nlocator.get[B].a eq locator.get[A]\n// res11: Boolean = true\nlocator.get[C].c eq locator.get[C]\n// res12: Boolean = true\nThe proxy generation via cglib is currently enabled by default, because in scenarios with extreme late-binding cycles can emerge unexpectedly, out of control of the origin module.\nNB: Currently a limitation applies to by-names - ALL dependencies of a class engaged in a by-name circular dependency must be by-name, otherwise distage will revert to generating proxies.","title":"Manual Resolution with by-name parameters"},{"location":"/distage/advanced-features.html#auto-sets","text":"AutoSet Planner Hooks can traverse the plan and collect all future objects that match a predicate.\nUsing Auto-Sets you can e.g. collect all AutoCloseable classes and .close() them after the application has finished work.\nNOTE: please use Resource bindings for real lifecycle, this is just an example.\nimport distage.{BootstrapModuleDef, ModuleDef, Injector, GCMode}\nimport izumi.distage.model.planning.PlanningHook\nimport izumi.distage.planning.AutoSetHook\n\nclass PrintResource(name: String) {\n  def start(): Unit = println(s\"$name started\")\n  def stop(): Unit = println(s\"$name stopped\")\n}\n\nclass A extends PrintResource(\"A\")\nclass B(val a: A) extends PrintResource(\"B\")\nclass C(val b: B) extends PrintResource(\"C\")\n\nval bootstrapModule = new BootstrapModuleDef {\n  many[PlanningHook].add(new AutoSetHook[PrintResource, PrintResource](identity))\n}\n// bootstrapModule: AnyRef with BootstrapModuleDef = Module(many[{type.scala.collection.immutable.Set[=PlanningHook]}].add[{type.izumi.distage.planning.AutoSetHook[=Session::App13::PrintResource,=Session::App13::PrintResource]}].from(call(izumi.distage.model.providers.ProviderMagnet$$$Lambda$15530/0x0000000843a44040@61df87b8(): izumi.distage.planning.AutoSetHook[=Session::App13::PrintResource,=Session::App13::PrintResource])) ((advanced-features.md:162)), many[{type.scala.collection.immutable.Set[=PlanningHook]}] ((advanced-features.md:162)))\n\nval appModule = new ModuleDef {\n  make[C]\n  make[B]\n  make[A]\n}\n// appModule: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App13::repl.Session.App13.B}].from(call(<function1>(repl.Session::repl.Session.App13::repl.Session.App13.A): repl.Session::repl.Session.App13::repl.Session.App13.B)) ((advanced-features.md:168)), make[{type.repl.Session::repl.Session.App13::repl.Session.App13.A}].from(call(<function1>(): repl.Session::repl.Session.App13::repl.Session.App13.A)) ((advanced-features.md:169)), make[{type.repl.Session::repl.Session.App13::repl.Session.App13.C}].from(call(<function1>(repl.Session::repl.Session.App13::repl.Session.App13.B): repl.Session::repl.Session.App13::repl.Session.App13.C)) ((advanced-features.md:167)))\n\nval resources = Injector(bootstrapModule)\n  .produceUnsafe(appModule, GCMode.NoGC)\n  .get[Set[PrintResource]]\n// resources: Set[PrintResource] = ListSet(repl.Session$App13$A@7d19b761, repl.Session$App13$B@13179c2e, repl.Session$App13$C@409ce344)\n\nresources.foreach(_.start())\n// A started\n// B started\n// C started\nresources.toSeq.reverse.foreach(_.stop())\n// C stopped\n// B stopped\n// A stopped\nCalling .foreach on an auto-set is safe; the actions will be executed in order of dependencies. Auto-Sets preserve ordering, they use ListSet under the hood, unlike user-defined Sets. e.g. If C depends on B depends on A, autoset order is: A, B, C, to start call: A, B, C, to close call: C, B, A. When you use auto-sets for finalization, you must .reverse the autoset.\nNote: Auto-Sets are NOT subject to Garbage Collection, they are assembled after garbage collection is done, as such they can’t contain garbage by construction. Because of that they also cannot be used as GC Roots.\nSee also: same concept in MacWire","title":"Auto-Sets"},{"location":"/distage/advanced-features.html#weak-sets","text":"Set bindings can contain weak references. References designated as weak will be retained only if there are other dependencies on them except for the set addition.\nExample:\nimport distage._\n\nsealed trait Elem\n\nfinal class Strong extends Elem {\n  println(\"Strong constructed\")\n}\n\nfinal class Weak extends Elem {\n  println(\"Weak constructed\")\n}\n\nval module = new ModuleDef {\n  make[Strong]\n  make[Weak]\n  \n  many[Elem]\n    .ref[Strong]\n    .weak[Weak]\n}\n// module: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App16::repl.Session.App16.Strong}].from(call(<function1>(): repl.Session::repl.Session.App16::repl.Session.App16.Strong)) ((advanced-features.md:207)), make[{type.repl.Session::repl.Session.App16::repl.Session.App16.Weak}].from(call(<function1>(): repl.Session::repl.Session.App16::repl.Session.App16.Weak)) ((advanced-features.md:208)), many[{type.scala.collection.immutable.Set[=Session::App16::Elem]}].add[{type.repl.Session::repl.Session.App16::repl.Session.App16.Strong}].from(using[{type.repl.Session::repl.Session.App16::repl.Session.App16.Strong}]) ((advanced-features.md:211)), many[{type.scala.collection.immutable.Set[=Session::App16::Elem]}].add[{type.repl.Session::repl.Session.App16::repl.Session.App16.Weak}].from(weak[{type.repl.Session::repl.Session.App16::repl.Session.App16.Weak}]) ((advanced-features.md:212)), many[{type.scala.collection.immutable.Set[=Session::App16::Elem]}] ((advanced-features.md:210)))\n\n// Designate Set[Elem] as the garbage collection root,\n// everything that Set[Elem] does not strongly depend on will be garbage collected\n// and will not be constructed. \n\nval roots = Set[DIKey](DIKey.get[Set[Elem]])\n// roots: Set[DIKey] = Set({type.scala.collection.immutable.Set[=Session::App16::Elem]})\n\nval locator = Injector().produceUnsafe(PlannerInput(module, roots))\n// Strong constructed\n// locator: Locator = izumi.distage.LocatorDefaultImpl@7682af52\n\nlocator.get[Set[Elem]].size == 1\n// res17: Boolean = true\nThe Weak class was not required by any dependency of Set[Elem], so it was pruned. The Strong class remained, because the reference to it was strong, so it was counted as a dependency of Set[Elem].\nIf we change Strong to depend on the Weak, then Weak will be retained:\nfinal class Strong(weak: Weak) extends Elem {\n  println(\"Strong constructed\")\n}\n\nval locator = Injector().produceUnsafe(PlannerInput(module, roots))\n// Weak constructed\n// Strong constructed\n// locator: Locator = izumi.distage.LocatorDefaultImpl@7f6ccfe4\n\nlocator.get[Set[Elem]].size == 2\n// res19: Boolean = true","title":"Weak Sets"},{"location":"/distage/advanced-features.html#inner-classes-and-path-dependent-types","text":"Path-dependent types with a value prefix will instantiate normally:\nimport distage.{GCMode, ModuleDef, Injector}\n\nclass Path {\n  class A\n}\nval path = new Path\n// path: Path = repl.Session$App20$Path@561010f0\n\nval module = new ModuleDef {\n  make[path.A]\n}\n// module: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App20::repl.Session.App20.Path::repl.Session.App20.Path.A}].from(call(<function1>(): repl.Session::repl.Session.App20::repl.Session.App20.Path::repl.Session.App20.Path.A)) ((advanced-features.md:287)))\n\nInjector()\n  .produceUnsafe(module, GCMode.NoGC)\n  .get[path.A]\n// res21: path.A = repl.Session$App20$Path$A@626be13e\nSince version 0.10, path-dependent types with a type (non-value) prefix are no longer supported, see issue: https://github.com/7mind/izumi/issues/764","title":"Inner Classes and Path-Dependent Types"},{"location":"/distage/advanced-features.html#depending-on-locator","text":"Objects can depend on the Locator (container of the final object graph):\nimport distage._\n\nclass A(all: LocatorRef) {\n  def c = all.get.get[C]\n}\nclass B\nclass C\n\nval module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n// module: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App22::repl.Session.App22.C}].from(call(<function1>(): repl.Session::repl.Session.App22::repl.Session.App22.C)) ((advanced-features.md:319)), make[{type.repl.Session::repl.Session.App22::repl.Session.App22.B}].from(call(<function1>(): repl.Session::repl.Session.App22::repl.Session.App22.B)) ((advanced-features.md:318)), make[{type.repl.Session::repl.Session.App22::repl.Session.App22.A}].from(call(<function1>(izumi.distage.model.Locator::izumi.distage.model.Locator.LocatorRef): repl.Session::repl.Session.App22::repl.Session.App22.A)) ((advanced-features.md:317)))\n\nval locator = Injector().produceUnsafe(module, GCMode.NoGC)\n// locator: Locator = izumi.distage.LocatorDefaultImpl@9af1fe5\n\nassert(locator.get[A].c eq locator.get[C])\nLocator contains metadata about the plan and the bindings from which it was ultimately created:\n// Plan that created this locator\n\nval plan: OrderedPlan = locator.plan\n// plan: OrderedPlan = {type.Locator::LocatorRef} (advanced-features.md:317) := import {type.izumi.distage.model.Locator::izumi.distage.model.Locator.LocatorRef} // required for {type.Session::App22::A}\n// {type.Session::App22::B} (advanced-features.md:318) := call(<function1>(): Session::App22::B) {}\n// {type.Session::App22::C} (advanced-features.md:319) := call(<function1>(): Session::App22::C) {}\n// {type.Session::App22::A} (advanced-features.md:317) := call(<function1>(Locator::LocatorRef): Session::App22::A) {\n//   arg all: Locator::LocatorRef = lookup({type.Locator::LocatorRef})\n// }\n\n// Bindings from which the Plan was built\n\nval moduleDef: ModuleBase = plan.definition\n// moduleDef: ModuleBase = Module(make[{type.repl.Session::repl.Session.App22::repl.Session.App22.B}].from(call(<function1>(): repl.Session::repl.Session.App22::repl.Session.App22.B)) ((advanced-features.md:318)), make[{type.repl.Session::repl.Session.App22::repl.Session.App22.C}].from(call(<function1>(): repl.Session::repl.Session.App22::repl.Session.App22.C)) ((advanced-features.md:319)), make[{type.repl.Session::repl.Session.App22::repl.Session.App22.A}].from(call(<function1>(izumi.distage.model.Locator::izumi.distage.model.Locator.LocatorRef): repl.Session::repl.Session.App22::repl.Session.App22.A)) ((advanced-features.md:317)))","title":"Depending on Locator"},{"location":"/distage/debugging.html","text":"","title":"Debugging ? Izumi Project"},{"location":"/distage/debugging.html#debugging","text":"Testing Plans Pretty-printing plans Graphviz rendering","title":"Debugging"},{"location":"/distage/debugging.html#testing-plans","text":"Use OrderedPlan#assertImportsResolvedOrThrow method to test whether all dependencies in a given plan are present and the plan will execute correctly when passed to Injector#produce.\nimport distage.{DIKey, GCMode, ModuleDef, Injector}\n\nclass A(b: B)\nclass B\n\nval badModule = new ModuleDef {\n  make[A]\n}\n// badModule: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App0::repl.Session.App0.A}].from(call(<function1>(repl.Session::repl.Session.App0::repl.Session.App0.B): repl.Session::repl.Session.App0::repl.Session.App0.A)) ((debugging.md:21)))\n\nval badPlan = Injector().plan(badModule, GCMode.NoGC)\n// badPlan: izumi.distage.model.plan.OrderedPlan = {type.Session::App0::B} (debugging.md:21) := import {type.repl.Session::repl.Session.App0::repl.Session.App0.B} // required for {type.Session::App0::A}\n// {type.Session::App0::A} (debugging.md:21) := call(<function1>(Session::App0::B): Session::App0::A) {\n//   arg b: Session::App0::B = lookup({type.Session::App0::B})\n// }\nbadPlan.assertImportsResolvedOrThrow\n// izumi.distage.model.exceptions.InvalidPlanException: \n// - Instance is not available in the object graph: {type.repl.Session::repl.Session.App0::repl.Session.App0.B}.\n// Required by refs:\n//  - {type.repl.Session::repl.Session.App0::repl.Session.App0.A}\n// \tat izumi.distage.model.plan.impl.OrderedPlanOps.$anonfun$assertImportsResolved$1(OrderedPlanOps.scala:46)\n// \tat scala.util.Either$LeftProjection.map(Either.scala:573)\n// \tat izumi.distage.model.plan.impl.OrderedPlanOps.assertImportsResolved(OrderedPlanOps.scala:45)\n// \tat izumi.distage.model.plan.impl.OrderedPlanOps.assertImportsResolved$(OrderedPlanOps.scala:42)\n// \tat izumi.distage.model.plan.OrderedPlan.assertImportsResolved(AbstractPlan.scala:36)\n// \tat izumi.distage.model.plan.impl.OrderedPlanOps.assertImportsResolvedOrThrow(OrderedPlanOps.scala:56)\n// \tat izumi.distage.model.plan.impl.OrderedPlanOps.assertImportsResolvedOrThrow$(OrderedPlanOps.scala:55)\n// \tat izumi.distage.model.plan.OrderedPlan.assertImportsResolvedOrThrow(AbstractPlan.scala:36)\n// \tat repl.Session$App0$$anonfun$5.apply$mcV$sp(debugging.md:32)\n// \tat repl.Session$App0$$anonfun$5.apply(debugging.md:32)\n// \tat repl.Session$App0$$anonfun$5.apply(debugging.md:32)\nval goodModule = new ModuleDef {\n  make[A]\n  make[B]\n}\n// goodModule: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App0::repl.Session.App0.A}].from(call(<function1>(repl.Session::repl.Session.App0::repl.Session.App0.B): repl.Session::repl.Session.App0::repl.Session.App0.A)) ((debugging.md:40)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.B}].from(call(<function1>(): repl.Session::repl.Session.App0::repl.Session.App0.B)) ((debugging.md:41)))\n\nval plan = Injector().plan(goodModule, GCMode.NoGC)\n// plan: izumi.distage.model.plan.OrderedPlan = {type.Session::App0::B} (debugging.md:41) := call(<function1>(): Session::App0::B) {}\n// {type.Session::App0::A} (debugging.md:40) := call(<function1>(Session::App0::B): Session::App0::A) {\n//   arg b: Session::App0::B = lookup({type.Session::App0::B})\n// }\n\nplan.assertImportsResolvedOrThrow","title":"Testing Plans"},{"location":"/distage/debugging.html#pretty-printing-plans","text":"You can print the output of plan.render() to get detailed info on what will happen during instantiation. The printout includes source and line numbers so your IDE can show you where the binding was defined!\nprintln(plan.render())\n// {type.Session::App0::B} (debugging.md:41) := call(<function1>(): Session::App0::B) {}\n// {type.Session::App0::A} (debugging.md:40) := call(<function1>(Session::App0::B): Session::App0::A) {\n//   arg b: Session::App0::B = lookup({type.Session::App0::B})\n// }\nYou can also query a plan to see the dependencies and reverse dependencies of a specific class and their order of instantiation:\n// Print dependencies\nprintln(plan.topology.dependencies.tree(DIKey.get[A]))\n// DepNode({type.repl.Session::repl.Session.App0::repl.Session.App0.A},DependencyGraph(Map({type.repl.Session::repl.Session.App0::repl.Session.App0.B} -> Set(), {type.repl.Session::repl.Session.App0::repl.Session.App0.A} -> Set({type.repl.Session::repl.Session.App0::repl.Session.App0.B})),Depends),0,None,Set())\n\n// Print reverse dependencies\nprintln(plan.topology.dependees.tree(DIKey.get[B]))\n// DepNode({type.repl.Session::repl.Session.App0::repl.Session.App0.B},DependencyGraph(Map({type.repl.Session::repl.Session.App0::repl.Session.App0.B} -> Set({type.repl.Session::repl.Session.App0::repl.Session.App0.A}), {type.repl.Session::repl.Session.App0::repl.Session.App0.A} -> Set()),Required),0,None,Set())\nThe printer highlights circular dependencies:\nTo debug macros used by distage you may use the following Java Properties:\nsbt -Dizumi.debug.macro.rtti=true compile # fundamentals-reflection & LightTypeTag macros\nsbt -Dizumi.debug.macro.distage.constructors=true compile # izumi.distage.constructors.* macros\nsbt -Dizumi.debug.macro.distage.providermagnet=true compile # ProviderMagnet macro","title":"Pretty-printing plans"},{"location":"/distage/debugging.html#graphviz-rendering","text":"Add GraphDumpBootstrapModule to your Injector’s configuration to enable dumping of graphviz files with a graphical representation of the Plan.\nimport distage.GraphDumpBootstrapModule\n\nval injector = Injector(GraphDumpBootstrapModule())\n// injector: Injector = izumi.distage.InjectorDefaultImpl@279c7b70\nData will be saved dumped to ./target/plan-last-full.gv and ./target/plan-last-nogc.gv in current working directory.\nYou’ll need a GraphViz installation to render these files into a viewable PNG images:\ndot -Tpng target/plan-last-nogc.gv -o out.png","title":"Graphviz rendering"},{"location":"/distage/distage-framework.html","text":"","title":"distage-framework ? Izumi Project"},{"location":"/distage/distage-framework.html#distage-framework","text":"Roles Typesafe Config Plugins Compile-time checks","title":"distage-framework"},{"location":"/distage/distage-framework.html#roles","text":"A “Role” is an entrypoint for a specific application hosted in a larger software suite. Bundling multiple roles in a single .jar file can simplify deployment and operations.\ndistage-framework module contains the distage Role API:\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-framework\" % \"0.10.0-SNAPSHOT\"\nWith default RoleAppLauncherImpl, roles launch are specified on the command-line: ./launcher role1 role2 role3. Only the components required by the specified roles will be created, everything else will be pruned. (see: GC)\nTwo roles are bundled by default: Help and ConfigWriter.\nFurther reading: Roles: a viable alternative to Microservices","title":"Roles"},{"location":"/distage/distage-framework.html#typesafe-config","text":"distage-extension-config library allows summoning case classes and sealed traits from typesafe-config configuration\nTo use it, add distage-extension-config library:\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-extension-config\" % \"0.10.0-SNAPSHOT\"\nAdd a configuration file in HOCON format:\n# resources/application.conf\nconf {\n    name = \"John\"\n    age = 33\n    other = true\n}\nParse it into case classes and summon into your object graph:\nimport distage.{DIKey, GCMode, ModuleDef, Id, Injector}\nimport distage.config.{AppConfigModule, ConfigModuleDef}\nimport com.typesafe.config.ConfigFactory\n\nfinal case class Conf(name: String, age: Int)\n\nfinal case class OtherConf(other: Boolean)\n\nfinal class ConfigPrinter(conf: Conf, otherConf: OtherConf @Id(\"other\")) {\n  def print() = {\n    println(s\"name: ${conf.name}, age: ${conf.age}, other: ${otherConf.other}\")\n  }\n}\n\n// load\nval config = ConfigFactory.defaultApplication()\n// config: com.typesafe.config.Config = Config(SimpleConfigObject({\"conf\":{\"age\":33,\"name\":\"John\",\"other\":true}}))\n\n// declare paths to parse\nval configModule = new ConfigModuleDef {\n  makeConfig[Conf](\"conf\")\n  makeConfig[OtherConf](\"conf\").named(\"other\")\n}\n// configModule: AnyRef with ConfigModuleDef = Module(make[{type.repl.Session::repl.Session.App0::repl.Session.App0.Conf}].from(call(izumi.distage.config.ConfigModuleDef$$Lambda$15619/0x0000000843b0d040@5886c544(izumi.distage.config.model.AppConfig): repl.Session::repl.Session.App0::repl.Session.App0.Conf)).tagged(Set(ConfTag(conf))) ((distage-framework.md:37)), make[{type.repl.Session::repl.Session.App0::repl.Session.App0.OtherConf@other}].from(call(izumi.distage.config.ConfigModuleDef$$Lambda$15619/0x0000000843b0d040@26f52686(izumi.distage.config.model.AppConfig): repl.Session::repl.Session.App0::repl.Session.App0.OtherConf)).tagged(Set(ConfTag(conf))) ((distage-framework.md:38)))\n\n// add config itself to the graph\nval appConfigModule = AppConfigModule(config)\n// appConfigModule: AppConfigModule = Module(make[{type.izumi.distage.config.model.AppConfig}].from(value(AppConfig(Config(SimpleConfigObject({\"conf\":{\"age\":33,\"name\":\"John\",\"other\":true}}))))) ((ConfigModuleDef.scala:19)))\n\nval appModule = new ModuleDef {\n  make[ConfigPrinter]\n}\n// appModule: AnyRef with ModuleDef = Module(make[{type.repl.Session::repl.Session.App0::repl.Session.App0.ConfigPrinter}].from(call(<function1>(repl.Session::repl.Session.App0::repl.Session.App0.Conf, repl.Session::repl.Session.App0::repl.Session.App0.OtherConf): repl.Session::repl.Session.App0::repl.Session.App0.ConfigPrinter)) ((distage-framework.md:46)))\n\nval objects = Injector().produceUnsafe(\n  input = Seq(appModule, configModule, appConfigModule).merge,\n  mode  = GCMode(DIKey.get[ConfigPrinter])\n)\n// objects: izumi.distage.model.Locator = izumi.distage.LocatorDefaultImpl@69362060\n\nobjects.get[ConfigPrinter].print()\n// name: John, age: 33, other: true\nAutomatic derivation of config codecs is based on circe-config & circe-derivation. Circe codecs for a type will be reused if they exist.","title":"Typesafe Config"},{"location":"/distage/distage-framework.html#plugins","text":"distage-extension-plugins module adds classpath discovery for modules that inherit a marker trait PluginBase. Plugins enable extreme late-binding; e.g. they allow a program to extend itself at launch time with new Plugin classes on the classpath. Plugins are compatible with compile-time checks as long as they’re defined in a separate module.\nTo use plugins, first add the distage-extension-plugins library:\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-extension-plugins\" % \"0.10.0-SNAPSHOT\"\nCreate a module extending the PluginDef trait instead of ModuleDef:\n// package com.example.petstore\n\nimport distage._\nimport distage.plugins._\n\nobject PetStorePlugin extends PluginDef {\n  make[PetRepository]\n  make[PetStoreService]\n  make[PetStoreController]\n}\nCollect all PluginDefs in a package:\nval pluginLoader = PluginLoader(\n  PluginConfig(\n    debug = false,\n    packagesEnabled = Seq(\"com.example.petstore\"), // packages to scan\n    packagesDisabled = Seq.empty,                  // packages to ignore\n  )\n)\n// pluginLoader: PluginLoader = izumi.distage.plugins.load.PluginLoaderDefaultImpl@4fa73eed\n\nval appModules = pluginLoader.load()\n// appModules: Seq[PluginBase] = ArrayBuffer(Module(make[{type.com.example.petstore.PetRepository}].from(call(com.example.petstore.PetStorePlugin$$$Lambda$16532/0x0000000843e65040@5505e43b(): com.example.petstore.PetRepository)) ((PetStorePlugin.scala:6)), make[{type.com.example.petstore.PetStoreService}].from(call(com.example.petstore.PetStorePlugin$$$Lambda$16534/0x0000000843e66040@d68fbdb(): com.example.petstore.PetStoreService)) ((PetStorePlugin.scala:7)), make[{type.com.example.petstore.PetStoreController}].from(call(com.example.petstore.PetStorePlugin$$$Lambda$16536/0x0000000843e67040@7b4efccd(): com.example.petstore.PetStoreController)) ((PetStorePlugin.scala:8))))\nExecute collected modules as usual:\n// combine all modules into one\n\nval appModule = appModules.merge\n// appModule: PluginBase = Module(make[{type.com.example.petstore.PetRepository}].from(call(com.example.petstore.PetStorePlugin$$$Lambda$16532/0x0000000843e65040@5505e43b(): com.example.petstore.PetRepository)) ((PetStorePlugin.scala:6)), make[{type.com.example.petstore.PetStoreService}].from(call(com.example.petstore.PetStorePlugin$$$Lambda$16534/0x0000000843e66040@d68fbdb(): com.example.petstore.PetStoreService)) ((PetStorePlugin.scala:7)), make[{type.com.example.petstore.PetStoreController}].from(call(com.example.petstore.PetStorePlugin$$$Lambda$16536/0x0000000843e67040@7b4efccd(): com.example.petstore.PetStoreController)) ((PetStorePlugin.scala:8)))\n\n// launch\n\nInjector().produce(appModule, GCMode.NoGC).use {\n  _.get[PetStoreController].run()\n}\n// PetStoreController: running!\n// res3: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()","title":"Plugins"},{"location":"/distage/distage-framework.html#compile-time-checks","text":"An experimental compile-time verification API is available in the distage-framework module.\nTo use it add distage-framework library:\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-framework\" % \"0.10.0-SNAPSHOT\"\nOnly plugins defined in a different module can be checked at compile-time, test scope counts as a different module.\nExample:\nIn main scope:\n// package com.example\n\nimport distage.DIKey\nimport distage.StandardAxis.Env\nimport distage.config.ConfigModuleDef\nimport distage.plugins.PluginDef\nimport izumi.distage.staticinjector.plugins.ModuleRequirements\n\nfinal case class HostPort(host: String, port: Int)\n\nfinal case class Config(hostPort: HostPort)\n\nfinal class Service(conf: Config, otherService: OtherService)\nfinal class OtherService\n\n// error: OtherService is not bound here, even though Service depends on it\nfinal class AppPlugin extends PluginDef with ConfigModuleDef {\n  tag(Env.Prod)\n  \n  make[Service]\n  makeConfig[Config](\"config\")\n}\n\n// Declare OtherService as an external dependency\nfinal class AppRequirements extends ModuleRequirements(\n  // If we remove this line, compilation will rightfully break\n  Set(DIKey.get[OtherService])\n)\nIn config:\n// src/main/resources/application.conf\nconfig {\n  host = localhost\n  port = 8080\n}\nIn test scope:\n// package com.example.test\n\nimport com.example._\nimport org.scalatest.WordSpec\nimport izumi.distage.staticinjector.plugins.StaticPluginChecker\n\nfinal class AppPluginTest extends WordSpec {\n  \"App plugin will work (if OtherService is provided later)\" in {\n    StaticPluginChecker.checkWithConfig[AppPlugin, AppRequirements](\"env:prod\", \".*.application.conf\")   \n  }\n}\ncheckWithConfig will run at compile-time whenever AppPluginTest is recompiled.\nNote: Since version 0.10.0, configuration files are no longer checked for correctness by the compile-time checker, see: https://github.com/7mind/izumi/issues/763","title":"Compile-time checks"},{"location":"/distage/distage-framework-docker.html","text":"","title":"distage-framework-docker ? Izumi Project"},{"location":"/distage/distage-framework-docker.html#distage-framework-docker","text":"Docker Test Resources","title":"distage-framework-docker"},{"location":"/distage/distage-framework-docker.html#docker-test-resources","text":"There is some documentation in the release notes for 0.9.13 and there’s an example PR showing how to use them.\nFurther documentation TBD: Issue #761\nTo use them, add distage-framework-docker library:\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-framework-docker\" % \"0.10.0-SNAPSHOT\"","title":"Docker Test Resources"},{"location":"/distage/distage-testkit.html","text":"","title":"distage-testkit ? Izumi Project"},{"location":"/distage/distage-testkit.html#distage-testkit","text":"Testkit Integration Checks","title":"distage-testkit"},{"location":"/distage/distage-testkit.html#testkit","text":"distage Livecode project project shows how to use distage-testkit:\npackage livecode\n\nimport distage.{DIKey, ModuleDef}\nimport doobie.util.transactor.Transactor\nimport izumi.distage.model.definition.StandardAxis\nimport izumi.distage.docker.examples.PostgresDocker\nimport izumi.distage.testkit.services.DISyntaxZIOEnv\nimport izumi.distage.testkit.TestConfig\nimport izumi.distage.testkit.scalatest.DistageBIOSpecScalatest\nimport livecode.code._\nimport livecode.zioenv._\nimport zio.{IO, Task, ZIO}\n\nabstract class LivecodeTest extends DistageBIOSpecScalatest[IO] with DISyntaxZIOEnv {\n  override def config = TestConfig(\n    pluginPackages = Some(Seq(\"livecode.plugins\")),\n    activation     = StandardAxis.testProdActivation,\n    moduleOverrides = new ModuleDef {\n      make[Rnd[IO]].from[Rnd.Impl[IO]]\n      include(PostgresDockerModule)\n    },\n    memoizedKeys = Set(\n      DIKey.get[Transactor[Task]],\n      DIKey.get[Ladder[IO]],\n      DIKey.get[Profiles[IO]],\n      DIKey.get[PostgresDocker.Container],\n    ),\n  )\n}\n\ntrait DummyTest extends LivecodeTest {\n  override final def config = super.config.copy(\n    activation = StandardAxis.testDummyActivation,\n  )\n}\n\nfinal class LadderTestDummy extends LadderTest with DummyTest\nfinal class ProfilesTestDummy extends ProfilesTest with DummyTest\nfinal class RanksTestDummy extends RanksTest with DummyTest\n\nclass LadderTest extends LivecodeTest with DummyTest {\n\n  \"Ladder\" should {\n    // this test gets dependencies through arguments\n    \"submit & get\" in {\n      (rnd: Rnd[IO], ladder: Ladder[IO]) =>\n        for {\n          user  <- rnd[UserId]\n          score <- rnd[Score]\n          _     <- ladder.submitScore(user, score)\n          res   <- ladder.getScores.map(_.find(_._1 == user).map(_._2))\n          _     = assert(res contains score)\n        } yield ()\n    }\n\n    // other tests get dependencies via ZIO Env:\n    \"return higher score higher in the list\" in {\n      for {\n        user1  <- rnd[UserId]\n        score1 <- rnd[Score]\n        user2  <- rnd[UserId]\n        score2 <- rnd[Score]\n\n        _      <- ladder.submitScore(user1, score1)\n        _      <- ladder.submitScore(user2, score2)\n        scores <- ladder.getScores\n\n        user1Rank = scores.indexWhere(_._1 == user1)\n        user2Rank = scores.indexWhere(_._1 == user2)\n\n        _ = if (score1 > score2) {\n          assert(user1Rank < user2Rank)\n        } else if (score2 > score1) {\n          assert(user2Rank < user1Rank)\n        }\n      } yield ()\n    }\n  }\n\n}","title":"Testkit"},{"location":"/distage/distage-testkit.html#integration-checks","text":"Implementation classes that inherit from izumi.distage.roles.model.IntegrationCheck can specify a resourceCheck() method that will be called before test instantiation to check if external test dependencies (such as docker containers in distage-framework-docker) are available for the test or role. If not, the test will be canceled/ignored.\nThis feature allows you to e.g. selectively run only the fast in-memory tests that have no external dependencies if you have shut down your test environment.\nIntegration checks are executed only in distage-testkit tests and distage-framework’s Roles.\nUse StartupPlanExecutor to execute the checks manually.","title":"Integration Checks"},{"location":"/distage/reference.html","text":"","title":"Syntax Summary ? Izumi Project"},{"location":"/distage/reference.html#syntax-summary","text":"ModuleDefDSL syntax:\nSingleton bindings:\n  - `make[X]` = create X using its constructor\n  - `make[X].from[XImpl]` = bind X to its subtype XImpl using XImpl's constructor\n  - `make[X].from(myX)` = bind X to an already existing instance `myX`\n  - `make[X].from { y: Y => new X(y) }` = bind X to an instance of X constructed by a given [[izumi.distage.model.providers.ProviderMagnet Provider]] function\n  - `make[X].named(\"special\")` = bind a named instance of X. It can then be summoned using [[Id]] annotation.\n  - `make[X].using[X](\"special\")` = bind X to refer to another already bound named instance at key `[X].named(\"special\")`\n  - `make[X].fromEffect(X.create[F]: F[X])` = create X using a purely-functional effect `X.create` in `F` monad\n  - `make[X].fromResource(X.resource[F]: Resource[F, X])` = create X using a Resource specifying its creation and destruction lifecycle\n\nSet bindings:\n  - `many[X].add[X1].add[X2]` = bind a [[Set]] of X, and add subtypes X1 and X2 created via their constructors to it.\n                                Sets can be bound in multiple different modules. All the elements of the same set in different modules will be joined together.\n  - `many[X].add(x1).add(x2)` = add *instances* x1 and x2 to a `Set[X]`\n  - `many[X].add { y: Y => new X1(y).add { y: Y => X2(y) }` = add instances of X1 and X2 constructed by a given [[izumi.distage.model.providers.ProviderMagnet Provider]] function\n  - `many[X].named(\"special\").add[X1]` = create a named set of X, all the elements of it are added to this named set.\n  - `many[X].ref[XImpl]` = add a reference to an already **existing** binding of XImpl to a set of X's\n  - `many[X].ref[X](\"special\")` = add a reference to an **existing** named binding of X to a set of X's\n\nTags:\n  - `make[X].tagged(\"t1\", \"t2)` = attach tags to X's binding. Tags can be processed in a special way. See [[izumi.distage.roles.model.RoleId]]\n  - `many[X].add[X1].tagged(\"x1tag\")` = Tag a specific element of X. The tags of sets and their elements are separate.\n  - `many[X].tagged(\"xsettag\")` = Tag the binding of empty Set of X with a tag. The tags of sets and their elements are separate.\n\nIncludes:\n  - `include(that: ModuleDef)` = add all bindings in `that` module into `this` module","title":"Syntax Summary"},{"location":"/logstage/index.html","text":"","title":"LogStage ? Izumi Project"},{"location":"/logstage/index.html#logstage","text":"LogStage is a zero-cost structural logging framework for Scala & Scala.js\nKey features:\nLogStage extracts structure from ordinary string interpolations in your log messages with zero changes to code. LogStage uses macros to extract log structure, its faster at runtime than a typical reflective structural logging frameworks, Log contexts Console, File and SLF4J sinks included, File sink supports log rotation, Human-readable output and JSON output included, Method-level logging granularity. Can configure methods com.example.Service.start and com.example.Service.doSomething independently, Slf4J adapters: route legacy Slf4J logs into LogStage router","title":"LogStage"},{"location":"/logstage/index.html#overview","text":"The following snippet:\nimport logstage._\nimport scala.util.Random\n\nval logger = IzLogger()\n\nval justAnArg = \"example\"\nval justAList = List[Any](10, \"green\", \"bottles\")\n\nlogger.trace(s\"Argument: $justAnArg, another arg: $justAList\")\n\n// custom name, not based on `val` name\nlogger.info(s\"Named expression: ${Random.nextInt() -> \"random number\"}\")\n\n// print result without a name\nlogger.warn(s\"Invisible argument: ${Random.nextInt() -> \"random number\" -> null}\")\n\n// add following fields to all messages printed by a new logger value\nval ctxLogger = logger(\"userId\" -> \"user@google.com\", \"company\" -> \"acme\")\nval delta = Random.nextInt(1000)\n\nctxLogger.info(s\"Processing time: $delta\")\nWill look like this in string form:\nAnd like this in JSON:\nNote:\nJSON formatter is type aware! Each JSON message contains @class field with holds a unique event class identifier. All events produced by the same source code line will share the same event class.","title":"Overview"},{"location":"/logstage/index.html#syntax-reference","text":"Simple variable: scala logger.info(s\"My message: $argument\") Chain: scala logger.info(s\"My message: ${call.method} ${access.value}\") Named expression: scala logger.info(s\"My message: ${Some.expression -> \"argname\"}\") Invisible named expression: scala logger.info(s\"My message: ${Some.expression -> \"argname\" -> null}\")\n5) De-camelcased name: scala logger.info(${camelCaseName-> ' '})","title":"Syntax Reference"},{"location":"/logstage/index.html#dependencies","text":"// LogStage core\nlibraryDependencies += Izumi.R.logstage_core\n\n// Optional\nlibraryDependencies ++= Seq(\n  // Json output\n  Izumi.R.logstage_rendering_circe,\n  // Router from Slf4j to LogStage\n  Izumi.R.logstage_adapter-slf4j,\n  // Configure LogStage with Typesafe Config\n  Izumi.R.logstage_config,\n  // LogStage integration with DIStage \n  Izumi.R.logstage_di,\n  // Router from LogStage to Slf4J\n  Izumi.R.logstage_sink_slf4j,\n)\nor\nval izumi_version = \"0.10.0-SNAPSHOT\"\n// LogStage core\nlibraryDependencies += \"io.7mind.izumi\" %% \"logstage-core\" % izumi_version\n\n// Optional\nlibraryDependencies ++= Seq(\n  // Json output\n  \"io.7mind.izumi\" %% \"logstage-rendering-circe\" % izumi_version,\n  // Router from Slf4j to LogStage\n  \"io.7mind.izumi\" %% \"logstage-adapter-slf4j\" % izumi_version,    \n  // Configure LogStage with Typesafe Config\n  \"io.7mind.izumi\" %% \"logstage-config\" % izumi_version,\n  // LogStage integration with DIStage \n  \"io.7mind.izumi\" %% \"logstage-di\" % izumi_version,\n  // Router from LogStage to Slf4J\n  \"io.7mind.izumi\" %% \"logstage-sink-slf4j \" % izumi_version,\n)\nIf you’re not using sbt-izumi-deps plugin.","title":"Dependencies"},{"location":"/logstage/index.html#basic-setup","text":"import logstage._\nimport logstage.circe._\n\nval jsonSink = ConsoleSink.json(prettyPrint = true)\nval textSink = ConsoleSink.text(colored = true)\n\nval sinks = List(jsonSink, textSink)\n\nval logger: IzLogger = IzLogger(Trace, sinks)\nval contextLogger: IzLogger = logger(Map(\"key\" -> \"value\"))\n\nlogger.info(\"Hey\")\n\ncontextLogger.info(s\"Hey\")","title":"Basic setup"},{"location":"/logstage/index.html#log-algebras","text":"LogIO and LogBIO algebras provide a purely-functional API for one- and two-parameter effect types respectively:\nimport logstage._\nimport cats.effect.IO\n\nval logger = IzLogger()\n// logger: IzLogger = izumi.logstage.api.IzLogger@79e52433\n\nval log = LogIO.fromLogger[IO](logger)\n// log: LogIO[IO] = logstage.LogIO$$anon$1@38d45061\n\nlog.info(s\"Hey! I'm logging with ${log}stage!\").unsafeRunSync()\nI 2019-03-29T23:21:48.693Z[Europe/Dublin] r.S.App7.res8 ...main-12:5384  (00_logstage.md:92) Hey! I'm logging with log=logstage.LogIO$$anon$1@72736f25stage!\nLogstageZIO.withFiberId provides a LogBIO instance that logs the current ZIO FiberId in addition to the thread id:\nExample:\nimport logstage.LogstageZIO\nimport zio.{IO, DefaultRuntime}\n\nval log: LogBIO[IO] = LogstageZIO.withFiberId(logger)\n// log: LogBIO[IO] = logstage.LogstageZIO$$anon$1@73d98bc0\n\nval rts = new DefaultRuntime {}\n// rts: AnyRef with DefaultRuntime = repl.Session$App9$$anon$1@5cc09997\nrts.unsafeRun {\n  log.info(s\"Hey! I'm logging with ${log}stage!\")\n}\nI 2019-03-29T23:21:48.760Z[Europe/Dublin] r.S.App9.res10 ...main-12:5384  (00_logstage.md:123) {fiberId=0} Hey! I'm logging with log=logstage.LogstageZIO$$anon$1@c39104astage!\nLogIO/LogBIO algebras can be extended with custom context, same as IzLogger:\nimport cats.effect.IO\nimport cats.implicits._\nimport logstage._\nimport io.circe.Printer\nimport io.circe.syntax._\n\ndef importEntity(entity: Entity)(implicit log: LogIO[IO]): IO[Unit] = {\n  val ctxLog = log(\"ID\" -> someEntity.id, \"entityAsJSON\" -> entity.asJson.pretty(Printer.spaces2))\n\n  load(entity).handleErrorWith {\n    case error =>\n      ctxLog.error(s\"Failed to import entity: $error.\").void\n      // JSON message includes `ID` and `entityAsJSON` fields\n  }\n}","title":"Log algebras"},{"location":"/logstage/index.html#slf4j-router","text":"When not configured, logstage-adapter-slf4j will log messages with level >= Info to stdout.\nDue to the global mutable nature of slf4j, to configure slf4j logging you’ll have to mutate a global singleton StaticLogRouter. Replace its LogRouter with the same one you use elsewhere in your application to use the same configuration for Slf4j.\nimport logstage._\nimport izumi.logstage.api.routing.StaticLogRouter\n\nval myLogger = IzLogger()\n// myLogger: IzLogger = izumi.logstage.api.IzLogger@6c8b89e7\n\n// configure SLF4j to use the same router that `myLogger` uses\nStaticLogRouter.instance.setup(myLogger.router)","title":"SLF4J Router"},{"location":"/logstage/policy.html","text":"","title":"Rendering policy ? Izumi Project"},{"location":"/logstage/policy.html#rendering-policy","text":"Rendering policy is defined in logstage config section.\nDefault template: ${level}:${ts} ${thread}${location} ${custom-ctx} ${msg}","title":"Rendering policy"},{"location":"/logstage/policy.html#log-units-specification","text":"Unit Aliases Explanation Syntax timestamp ts Timestamp ${timestamp} thread t Thread data (contains thread name and id) ${thread} level lvl Logging level ${lvl} location loc Log message location (hyperlink to filename it’s line number) ${location} message msg Application-supplied message associated with the logging event ${message} custom-ctx context, ctx User’s context (more info here) ${custom-ctx} exception ex Outputs the stack trace of the exception associated with the logging event, if any. Full stack trace will be printed by default. ${ex}","title":"Log units specification"},{"location":"/logstage/policy.html#parameters","text":"Units can be parameterized (with padding, margins, etc). NOTE! Currently there are only common parameters (padding). Parameters enumerates in [ ] braces. For example, ${message[15]}\nUnit Parameter Example ALL padding padding for log unit in result string. Can be ellipsed: [:..14] ${timestamp}[14]","title":"Parameters"},{"location":"/logstage/config.html","text":"","title":"Logstage Config ? Izumi Project"},{"location":"/logstage/config.html#logstage-config","text":"TODO Sorry, this page is not ready yet","title":"Logstage Config"},{"location":"/logstage/config.html#sample","text":"logstage {\n \n  sinks = {\n    \"default\" = {\n      path = \"foo.bar.baz.CustomSink1\"\n      params {\n        policy {\n          path = \"foo.bar.baz.CustomPolicy1\"\n          params {\n            options {\n              withExceptions = false\n              withColors = true\n            }\n          }\n        }\n      }\n    }\n    \"sink1\" = {\n      path = \"foo.bar.baz.CustomSink1\"\n      params {\n        policy {\n          path = \"foo.bar.baz.CustomPolicy1\"\n          params {\n            options {\n              withExceptions = false\n              withColors = true\n            }\n          }\n        }\n      }\n    }\n  }\n\n\n  root {\n    threshold = \"info\"\n    sinks = [\n      \"default\"\n    ]\n  }\n\n  entries = {\n    \"for.bar.*\" = \"warn\"\n    \"for.baz.*\" = {\n      threshold = \"debug\"\n      sinks = [\n        \"sink1\"\n      ]\n    }\n  }\n}","title":"Sample"},{"location":"/logstage/config.html#detailed-info","text":"Section Explanation sinks Defines used log sinks*. This section should contain default log sinks in case of ignore sinks list if you need to use only default sinks** root Defines default settings for logging (e.g., sinks and log threshold) entries Defines log entries settings (threshold and list of sinks)\nNotes:\nFor each sink you need to provide rendering policy mapper. You need to specify case class constructor for defined logsink and implement function for it’s instantiating. In sinks section you can define log sink with label default for it’s further usage on logentries definition for simplify log entries definition. For example, if you need to define only threshold level but sink can be default, you only write next:\nentries = {\n    \"target.path\" = <your_level>\n}\ninstead of common syntax:\nentries = {\n    \"target.path\" = {\n       threshold = <your_level>\n       sinks = [\"default\"]\n    }\n}","title":"Detailed info"},{"location":"/logstage/config.html#basic-setup","text":"There are two libs for logstage config. The second one depends on distage and config LogstageModule which binds logstage config\nSo, what you need to do to use logstage declarative config:\n1) include \"logstage-reference.conf\" in your application config\n2) defined next bootstrap modules :\n- `LogstageCodecsModule()` - it will bind rendering policy and logsinks mappers and all necessary logstage runtime codecs\n\nEach `RenderingPolicy` and `LogSink` you may bind by calling follow commands inside LogstageCodecsModule:\n\n    bindLogSinkMapper[T <: LogSink : ru.TypeTag, C: ru.TypeTag](f: C => T)\n\n    bindRenderingPolicyMapper[T <: RenderingPolicy : ru.TypeTag, C: ru.TypeTag](f: C => T)\n3) defined application modules:\n- `LoggerConfigModule()` - it makes binding of LoggerConfig and you may inject it from locator using next command:\n\n```scala\nval logstageConfig = locator.get[LoggerConfig]\n```\n\nLoggerConfig model is next:\n\n```scala\nfinal case class LoggerPathConfig(threshold: Log.Level, sinks: Seq[LogSink])\n\nfinal case class LoggerConfig(root : LoggerPathConfig, entries : Map[String, LoggerPathConfig])\n```","title":"Basic setup"},{"location":"/logstage/config.html#example","text":"Let’s define our sinks and policies 1.1 DummyLogSink class DummyLogSink(policy: RenderingPolicy) extends LogSink {\n   override def flush(e: Log.Entry): Unit = {\n     // do smth\n   }\n}\n 1.2 DummyRenderingPolicy class DummyRenderingPolicy(foo: Int, bar: Option[String]) extends RenderingPolicy {\n  override def render(entry: Log.Entry): String = entry.toString\n}\n Let’s define out logstage reference config\nlogstage {\n\n   // include izumi sdk settings\n   include \"logstage-reference.conf\"\n\n   // custom overrides \n   \n   sinks = [\n      \"default\" = {\n        path = \"path.to.DummyLogSink\"\n        params {\n          policy {\n            path = \"path.to.DummyRenderingPolicy\"\n            params {\n              foo = 1024\n              bar = \"your_string_parameter\"\n            }\n          }\n        }\n      }\n   ]\n   \n    root {\n       threshold = \"info\"\n       sinks = [\n         \"default\"\n       ]\n     }\n   \n     entries = {\n        \"path.for.debug.only.*\" = debug\n     }\n}\nSo, for now we need to specify case classes constructors for out DummyLogSink and DummyRenderingPolicy for automatic parsing 3.1 DummyRenderingPolicyConstructor case class DummyRenderingPolicyConstructor(foo : Int, bar: Option[String])\n 3.2 DummyLogSinkConstructor case class DummyLogSinkConstructor(policy : RenderingPolicy)\n now we need to configure out DI for loggerConfigUsage 4.1 Define bootsrap module. Here you can bind all mappers for custom Policies and Logsinks: val logstageBootstrapModule = new LogstageCodecsModule {\n\n    // bind our rendering policy\n\n    bindRenderingPolicyMapper[DummyRenderingPolicy, DummyRenderingPolicyConstructor]{\n      c => \n        new DummyRenderingPolicy(c.foo, c.bar)\n    }\n\n    // bind our logsink\n\n    bindLogSinkMapper[DummyLogSink, DummyLogSinkConstructor] {\n      c =>  new DummyLogSink(c.policy)\n    }\n}\n\nval bootstrapModules = Seq(..., logstageBootstrapModule)\n\n 4.2 Add LoggerConfigModule to app modules val modules = Seq(..., new LoggerConfigModule ())\n 4.2 Enjoy! // Basic locator setup\n\nval injector = Injector(bootstapModules: _*)\nval plan = injector.plan(modules.toList.overrideLeft)\nval locator = injector.produce(plan)\n\n// retrieve binded config\nval cfg = locator.get[LoggerConfig]","title":"Example"},{"location":"/logstage/custom_ctx.html","text":"","title":"Custom Context ? Izumi Project"},{"location":"/logstage/custom_ctx.html#custom-context","text":"TODO Sorry, this page is not ready yet","title":"Custom Context"},{"location":"/sbt/index.html","text":"","title":"SBT Toolkit ? Izumi Project"},{"location":"/sbt/index.html#sbt-toolkit","text":"MOVED Moved to https://github.com/7mind/sbtgen/\nIzumi provides you a bunch of sbt plugins allowing you to significantly reduce size and increase clarity of huge multi-module builds.\nTo start using Izumi plugins add the following into your project/plugins.sbt:\n// This is Izumi Bill of Materials, see below\naddSbtPlugin(\"io.7mind.izumi\" % \"sbt-izumi-deps\" % \"0.10.0-SNAPSHOT\")\nWe provide you the following kinds of plugins:\nGlobal plugins: they add some helper sbt tasks, enabled automatically, Environmental plugins: they change some aspects of sbt behavior in an opinionated way, intended to be enabled in the root project, Presets - opinionated sets of environmental plugins, Optional plugins: they provide some convenience sbt tasks, intended to be enabled manually, per-project.\nImportant notes:\nPlease keep in mind no plugins are being enabled automatically, The rest of Izumi plugins are optional. You may use a preset to activate them or combine them manually as you wish (using settings groups), Some plugins can’t be enabled globally due to sbt limitations ? they have to be enabled per-project. You should use Settings Groups in order to enable them.","title":"SBT Toolkit"},{"location":"/sbt/index.html#global-plugins","text":"Plugin Description IzumiImportsPlugin Makes all the Izumi imports visible by default","title":"Global plugins"},{"location":"/sbt/index.html#environmental-plugins","text":"Plugin Description IzumiBuildManifestPlugin Adds build info into jar manifests IzumiConvenienceTasksPlugin Devops/workflow helpers IzumiDslPlugin Compact build definitions IzumiGitStampPlugin Adds GIT status into jar manifests IzumiPropertiesPlugin Convenience helpers for sys.props IzumiResolverPlugin Better defaults for artifact resolution IzumiInheritedTestScopesPlugin Convenience helpers for test scope inheritance","title":"Environmental plugins"},{"location":"/sbt/index.html#presets","text":"Plugin Description IzumiEnvironment All the environmental plugins except of GIT one IzumiGitEnvironment All the environmental plugins with GIT one","title":"Presets"},{"location":"/sbt/index.html#optional-plugins","text":"Plugin Description IzumiExposedTestScopesPlugin Maintains test scope separation IzumiCompilerOptionsPlugin Some linting/optimization presets for scalac/javac IzumiFetchPlugin Allows you to transitively download artifacts from remote repositories IzumiPublishingPlugin Some convenience helpers and improvements for artifact publishing IzumiBuildInfoPlugin Generates sbt-compatible BOMs ? Bills of Materials","title":"Optional plugins"},{"location":"/sbt/index.html#installation","text":"To activate all the plugins add the following statements into your root project:\nenablePlugins(IzumiGitEnvironmentPlugin)\nIf you don’t use git in your project, use this preset instead:\nenablePlugins(IzumiEnvironmentPlugin)\nTo activate Comp\nval GlobalSettings = new DefaultGlobalSettingsGroup {\n  override val plugins = Set(IzumiCompilerOptionsPlugin, IzumiExposedTestScopesPlugin)\n}","title":"Installation"},{"location":"/sbt/index.html#inherited-test-scopes","text":"","title":"Inherited Test Scopes"},{"location":"/sbt/index.html#test-scope-inheritance","text":"IzumiScopesPlugin extends SBT Project with several implicit methods:\ntestOnlyRef - provides you a project reference which is equivalent to % \"test\" dependency, dependsSeq and depends - allow you to add dependencies to your project the way test scopes of your dependencies are visible within test scopes of your project. So, essentially when you use these methods your dependencies are added into your projects with the following qualifier: \"test->compile,test;it->compile,test,it\"\nYou need to activate DefaultItSettingsGroup on your projects (see “Setting Groups” below) in order to make this working on it scope.\nExample:\nlazy val myLibrary = ...\n\nlazy val myProject = (...).depends(myLibrary)\nSo, now you may use classes from the test scope of myLibrary within test scope of myProject","title":"Test Scope Inheritance"},{"location":"/sbt/index.html#test-scope-separation","text":"InheritedTestScopesPlugin works in pair with IzumiScopesPlugin and provides you an unique feature: only the classes you marked with @ExposedTestScope are being exposed to dependant artifacts.\nSo, let’s assume that:\nyou have two artifacts, Library and App, App depends on Library, In the test scope of Library you have a class named TestSuite, In the test scope of Library you have another class named TestUtil, TestUtil is annotated with @ExposedTestScope,\nin that case TestUtil will be visible in App’s test scope, but TestSuite will not be visible.\nA diagram:\n+-----------------------------------------+     +-----------------------------------------+\n| Library                                 |     | App                                     |\n|-----------------------------------------|     |-----------------------------------------|\n| Main scope                              |     | Main scope                              |\n|                                     <---+-----+--                                       |\n| UtilityClass                            |     | AppMain                                 |\n|-----------------------------------------|     |-----------------------------------------+\n| Private Test Scope | Exposed test scope |     | Test scope                              |\n|                    |                <---+-----+--                                       |\n| TestSuite          | TestUtil           |     | Private Test Scope | Exposed test scope |\n+-----------------------------------------+     +-----------------------------------------+\nNotes:\nIntellij IDEA doesn’t support overriden classpaths so when you run your tests under IDEA the whole test scopes are visible in dependencies, At the moment the implementation of @ExposedTestScope (substring presence check) is imperfect and has to be improved, Transitive dependencies are not checked, so in case you expose a class but do not expose it’s dependencies your build will work under IDEA, but you will a classloading exception under sbt. This is going to be improved in the future.","title":"Test Scope Separation"},{"location":"/sbt/index.html#test-scope-publishing","text":"The whole content of test scopes is being published by default with test qualifier. Test scope separation has no effect on test scope publishing.","title":"Test Scope Publishing"},{"location":"/sbt/index.html#settings-dsl","text":"IzumiDslPlugin comes with a DSL intended to simplify definition of complex project layouts.\nTo activate the plugin add the following statement into your root project:\nenablePlugins(IzumiDslPlugin)","title":"Settings DSL"},{"location":"/sbt/index.html#simplified-identifiers","text":"DSL provides syntax to simplify project definitions. A definition such as this:\nlazy val petstoreApp = In(\"app\").as.module\nexpands to\nlazy val petstoreApp = project.in(\"app/petstore-app\")\nYou can attach settings and dependencies to the In part, that way you can apply common settings to all the projects in a directory:\nval ApiSettings = new SettingsGroup {\n  override val plugins = Set(IdealinguaPlugin)\n}\n\nlazy val inApi = In(\"api\").settings(ApiSettings)\n\nlazy val petstoreApi = inApi.as.module\nlazy val todomvcApi = inApi.as.module","title":"Simplified Identifiers"},{"location":"/sbt/index.html#setting-groups","text":"","title":"Setting Groups"},{"location":"/sbt/index.html#global-setting-group","text":"","title":"Global Setting Group"},{"location":"/sbt/index.html#automatic-aggregation","text":"When you use .as.project or .as.module syntax to define a project, that project is stored in a global singleton.\nYou may use transitiveAggregate or transitiveAggregateSeq methods instead of standard aggregate, in that case all the transitive dependencies of the projects provided will be also added into aggregation list. This allows you to simplify your definitions by avoiding specifing all the modules in .aggregate.\nIn case you don’t want your project to be recorded, you shoud use .as.just syntax.\nImportant note: sbt is lazy! We just store project reference in a singleton list, we don’t analyze dependency graph. Though sbt relies on lazy val declarations. So, in fact the singleton initializes at the moment you invoke aggregation. In case you don’t add a project into aggregation list such a project still will be initialized by sbt and added into the singleton, but it would happen later than evaluation of aggregation list so the project will not be aggregated.","title":"Automatic Aggregation"},{"location":"/sbt/index.html#aggregation-safety-check","text":"When you invoke transitiveAggregate or transitiveAggregateSeq on your root project it checks if the accumulated set of known project is the same as the set of all projects loaded by sbt.\nIn case module is missing you’ll get a warning. This makes it unlikely for you to accidentally forget to aggregate a module in multi-module project.","title":"Aggregation Safety Check"},{"location":"/sbt/index.html#build-descriptors","text":"","title":"Build Descriptors"},{"location":"/sbt/index.html#bills-of-materials","text":"Izumi brings Bill of Materials concept to SBT.","title":"Bills of Materials"},{"location":"/sbt/index.html#izumi-bom","text":"You can import Izumi libraries and transitive dependencies without specifying their version or even artifact names. To do that add sbt-izumi-deps SBT plugin:\nval izumi_version = \"0.10.0-SNAPSHOT\"\naddSbtPlugin(\"io.7mind.izumi\" % \"sbt-izumi-deps\" % izumi_version)\nYou can use it like this:\nlibraryDependencies += Izumi.R.distage_core // Import an izumi library\nlibraryDependencies += IzumiDeps.R.cats_effect // Import a dependency of izumi\nlibraryDependencies += IzumiDeps.T.scalatest // Import a dependency of izumi in test scope\nR is for Runtime artifacts and T is for Test scope artifacts","title":"Izumi BOM"},{"location":"/sbt/index.html#create-a-bom-for-your-projects","text":"sbt-izumi-deps allows you to a create BOMs for your own projects. Just add the following snippet into your project settings:\nlazy val myProject = (project in file(\"my-project-bom\"))\n  .settings(withBuildInfo(\"com.mycompany.myproject\", \"MyProjectBOM\"))\nIf you use Izumi SBT DSL, you can use the following syntax:\nlazy val inRoot = In(\".\")\nlazy val myProjectBom = inRoot.as.module\n  .settings(withBuildInfo(\"com.mycompany.myproject\", \"MyProjectBOM\"))\nIf you want to include BOMs of you project, you can use the following syntax:\nimport com.mycompany.myproject.MyProjectBOM\n\nlazy val myLib = In(\"lib\").as.module\n  .settings(\n    libraryDependencies ++= Seq(\n      MyProjectBOM.R.my_project_bom,     // Runtime artifact\n      MyProjectBOM.T.my_project_bom,     // Runtime artifacts for test scope*\n      MyProjectBOM.TSR.my_project_bom,   // Test artifacts\n      MyProjectBOM.TST.my_project_bom,   // Test artifacts for test scope\n    )\n  )","title":"Create a BOM for your projects"},{"location":"/sbt/index.html#build-manifest-entries","text":"","title":"Build Manifest entries"},{"location":"/sbt/index.html#git-manifest-entries","text":"GitStampPlugin adds the following values into MANIFEST.MF of each jar artifact produced:\nManifest Key Description X-Git-Branch The name of branch sbt was invoked on X-Git-Repo-Is-Clean true or false, indicates if GIT repo was in clean state when the build was invoked X-Git-Head-Rev GIT revision on which sbt was invoked\nTo activate the plugin add the following statement into your root project:\nenablePlugins(GitStampPlugin)","title":"Git Manifest entries"},{"location":"/sbt/index.html#convenience-helpers","text":"","title":"Convenience Helpers"},{"location":"/sbt/index.html#stub-generators","text":"ConvenienceTasksPlugin provides you the following commands:\nnewModule <module_path/module_name> [package.suffix]: creates empty project layout at /module_path/module_name. Optional package.suffix may be specified. newStub <module_path/module_name> [stub_name:default]: copies /stubs/${stub_name} into /module_path/module_name. stub_name may be omitted, default value is default\nSetting Description ConvenienceTasksPlugin.Keys.mkJavaDirs Also adds src/*/java directories into generated stubs ConvenienceTasksPlugin.Keys.defaultStubPackage Default stub package. By default same as project’s organization","title":"Stub Generators"},{"location":"/sbt/index.html#version-suffixes","text":"ConvenienceTasksPlugin provides you command\naddVersionSuffix SUFFIX\nThis command updates project version defined in version.sbt with qualifier SUFFIX-SNAPSHOT\nExisting qualifiers will be removed. 1.0.0 would become 1.0.0-SUFFIX-SNAPSHOT 1.0.0-SNAPSHOT would become 1.0.0-SUFFIX-SNAPSHOT\nYou may need this command while setting up a build for feature branches and wish to avoid situation when different branches publishes artifacts with the same names.","title":"Version Suffixes"},{"location":"/sbt/index.html#target-preservation","text":"ConvenienceTasksPlugin provides you command\npreserveTargets SUFFIX\nThis command recursively enumerates all the directories named target and recursively copies them using name target.SUFFIX.\nYou may need this command while setting up a build where you wish to perform clean several times but want to preserve intermediate build artifacts stored in target directories. The most frequent case is coverage build followed by tests and then by production build. In this case you would like to use a command sequence like\n;clean;coverage;test;coverageOff;coverageReport;preserveTargets coverage;clean;publish","title":"target preservation"},{"location":"/sbt/index.html#directory-cleanups","text":"ConvenienceTasksPlugin provides you command\nrmDirs target.coverage\nThis command recursively removes all the directories named target.coverage across the project.\nYou may need this command to cleanup preserved target directories, or destroy some build artifacts, like rmDirs scala-2.11","title":"Directory cleanups"},{"location":"/sbt/index.html#property-readers","text":"IzumiPropertiesPlugin provides you implicit classes allowing you to convert Strings into Integers or Booleans exceptions-safe and do the same for system properties:\n\"true\".asBoolean(default = false) // true\n\"junk\".asBoolean(default = false) // false\n\"123\".asInt(default = 265) // 123\n\"junk\".asInt(default = 265) // 265\nsys.props.asBoolean(\"my.property\", default = false)\nsys.props.asInt(\"my.property\", default = 123)\nYou may activate this plugin with the following statement in root project:","title":"Property Readers"},{"location":"/sbt/index.html#transitive-artifact-downloader","text":"TODO","title":"Transitive Artifact Downloader"},{"location":"/sbt/index.html#optional-settings","text":"","title":"Optional settings"},{"location":"/sbt/index.html#publishing","text":"TODO","title":"Publishing"},{"location":"/sbt/index.html#publishing-settings","text":"TODO","title":"Publishing settings"},{"location":"/sbt/index.html#publishing-credentials-and-targets","text":"TODO","title":"Publishing credentials and targets"},{"location":"/sbt/index.html#compiler-options","text":"CompilerOptionsPlugin provides you some sane compiler option presets (linting, optimizations).\nYou should explicitly enable this plugin in each project you want to use it. When you want to enable it globally, use a settings group:\nval GlobalSettings = new SettingsGroup {\n  override val plugins = Set(\n      IzumiCompilerOptionsPlugin,\n      // ...\n  )\n  // ...\n}","title":"Compiler options"},{"location":"/sbt/index.html#resolvers","text":"ResolverPlugin turns on the following settings which should speedup your dependency resolution:\nupdateOptions := updateOptions\n      .value\n      .withCachedResolution(true)\n      .withGigahorse(true)","title":"Resolvers"},{"location":"/manifesto/index.html","text":"","title":"Productivity and challenges ? Izumi Project"},{"location":"/manifesto/index.html#productivity-and-challenges","text":"TODO Sorry, this page is not ready yet","title":"Productivity and challenges"},{"location":"/pper/index.html","text":"","title":"PPER Pattern ? Izumi Project"},{"location":"/pper/index.html#pper-pattern","text":"“Project Networks and Percept-Plan-Execute-Repeat loop to the rescue” slides: https://github.com/7mind/slides/raw/master/03-pper-basics/target/pper-base.pdf\nTODO Sorry, this page is not ready yet","title":"PPER Pattern"}]}