<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="microsite">
<meta name="generator" content="Paradox, paradox-material-theme=1.0.9-SNAPSHOT, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="microsite">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>distage-testkit Â· Izumi Project</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Izumi Project" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Izumi Project
</span>
<span class="md-header-nav__topic">
distage-testkit
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/7mind/izumi"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
7mind/izumi
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Izumi Project" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="../index.html" title="Izumi Project">
Izumi Project
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/7mind/izumi"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
7mind/izumi
</div>
</a>

</div>
<ul>
  <li><a href="../distage/index.html" class="page">distage: Staged Dependency Injection</a>
  <ul>
    <li><a href="../distage/basics.html" class="page">Overview</a></li>
    <li><a href="../distage/debugging.html" class="page">Debugging</a></li>
    <li><a href="../distage/advanced-features.html" class="page">Advanced Features</a></li>
    <li><a href="../distage/distage-framework.html" class="page">distage-framework</a></li>
    <li><a href="../distage/distage-framework-docker.html" class="page">distage-framework-docker</a></li>
    <li><a href="../distage/distage-testkit.html" class="active page">distage-testkit</a></li>
    <li><a href="../distage/reference.html" class="page">Syntax Reference</a></li>
  </ul></li>
  <li><a href="../logstage/index.html" class="page">LogStage</a></li>
  <li><a href="../bio/index.html" class="page">BIO Hierarchy</a></li>
  <li><a href="../idealingua/index.html" class="page">IdeaLingua RPC/DML</a>
  <ul>
    <li><a href="../idealingua/language-reference.html" class="page">Idealingua Language Reference</a></li>
    <li><a href="../idealingua/json.html" class="page">JSON Wire Format</a></li>
    <li><a href="../idealingua/cogen.html" class="page">Code generator reference</a></li>
    <li><a href="../idealingua/cogen-circe.html" class="page">Circe serialization reference</a></li>
  </ul></li>
  <li><a href="../sbt/index.html" class="page">SBT Toolkit</a></li>
  <li><a href="../manifesto/index.html" class="page">Productivity and challenges</a></li>
  <li><a href="../pper/index.html" class="page">PPER Pattern</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../distage/distage-testkit.html#distage-testkit" class="header">distage-testkit</a>
  <ul>
    <li><a href="../distage/distage-testkit.html#quick-start" class="header">Quick Start</a></li>
    <li><a href="../distage/distage-testkit.html#api-overview" class="header">API Overview</a></li>
    <li><a href="../distage/distage-testkit.html#syntax-reference" class="header">Syntax Reference</a></li>
    <li><a href="../distage/distage-testkit.html#execution-order" class="header">Execution Order</a></li>
    <li><a href="../distage/distage-testkit.html#resource-reuse-memoization" class="header">Resource Reuse - Memoization</a></li>
    <li><a href="../distage/distage-testkit.html#forced-roots" class="header">Forced Roots</a></li>
    <li><a href="../distage/distage-testkit.html#test-selection" class="header">Test Selection</a></li>
    <li><a href="../distage/distage-testkit.html#references" class="header">References</a></li>
    <li><a href="../distage/distage-testkit.html#extended-example" class="header">Extended Example</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 1.0.9*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../distage/distage-testkit.html#distage-testkit" class="header">distage-testkit</a>
  <ul>
    <li><a href="../distage/distage-testkit.html#quick-start" class="header">Quick Start</a></li>
    <li><a href="../distage/distage-testkit.html#api-overview" class="header">API Overview</a></li>
    <li><a href="../distage/distage-testkit.html#syntax-reference" class="header">Syntax Reference</a></li>
    <li><a href="../distage/distage-testkit.html#execution-order" class="header">Execution Order</a></li>
    <li><a href="../distage/distage-testkit.html#resource-reuse-memoization" class="header">Resource Reuse - Memoization</a></li>
    <li><a href="../distage/distage-testkit.html#forced-roots" class="header">Forced Roots</a></li>
    <li><a href="../distage/distage-testkit.html#test-selection" class="header">Test Selection</a></li>
    <li><a href="../distage/distage-testkit.html#references" class="header">References</a></li>
    <li><a href="../distage/distage-testkit.html#extended-example" class="header">Extended Example</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#distage-testkit" name="distage-testkit" class="anchor"><span class="anchor-link"></span></a>distage-testkit</h1>
<div class="toc ">
<ul>
  <li><a href="../distage/distage-testkit.html#quick-start" class="header">Quick Start</a></li>
  <li><a href="../distage/distage-testkit.html#api-overview" class="header">API Overview</a>
  <ul>
    <li><a href="../distage/distage-testkit.html#spec-base-classes" class="header"><code>Spec</code> Base Classes</a></li>
    <li><a href="../distage/distage-testkit.html#test-cases" class="header">Test Cases</a></li>
    <li><a href="../distage/distage-testkit.html#assertions" class="header">Assertions</a></li>
    <li><a href="../distage/distage-testkit.html#assertions-with-effects" class="header">Assertions with Effects</a></li>
    <li><a href="../distage/distage-testkit.html#assertions-with-effects-with-environments" class="header">Assertions with Effects with Environments</a></li>
    <li><a href="../distage/distage-testkit.html#pattern-dual-test-tactic" class="header">Pattern: Dual Test Tactic</a></li>
    <li><a href="../distage/distage-testkit.html#test-case-context" class="header">Test Case Context</a></li>
    <li><a href="../distage/distage-testkit.html#configuration" class="header">Configuration</a></li>
  </ul></li>
  <li><a href="../distage/distage-testkit.html#syntax-reference" class="header">Syntax Reference</a></li>
  <li><a href="../distage/distage-testkit.html#execution-order" class="header">Execution Order</a></li>
  <li><a href="../distage/distage-testkit.html#resource-reuse-memoization" class="header">Resource Reuse - Memoization</a>
  <ul>
    <li><a href="../distage/distage-testkit.html#memoization-environments" class="header">Memoization Environments</a></li>
    <li><a href="../distage/distage-testkit.html#memoization-levels" class="header">Memoization Levels</a></li>
    <li><a href="../distage/distage-testkit.html#examples" class="header">Examples</a></li>
    <li><a href="../distage/distage-testkit.html#pseudocode" class="header">Pseudocode</a></li>
  </ul></li>
  <li><a href="../distage/distage-testkit.html#forced-roots" class="header">Forced Roots</a></li>
  <li><a href="../distage/distage-testkit.html#test-selection" class="header">Test Selection</a>
  <ul>
    <li><a href="../distage/distage-testkit.html#using-integrationcheck" class="header">Using <code>IntegrationCheck</code></a></li>
  </ul></li>
  <li><a href="../distage/distage-testkit.html#references" class="header">References</a></li>
  <li><a href="../distage/distage-testkit.html#extended-example" class="header">Extended Example</a></li>
</ul>
</div>
<h3><a href="#quick-start" name="quick-start" class="anchor"><span class="anchor-link"></span></a>Quick Start</h3>
<p><code>distage-testkit</code> simplifies pragmatic purely-functional program testing providing <code>Spec*</code> <a href="https://www.scalatest.org/">ScalaTest</a> base classes for any existing Scala effect type with kind <code>F[_]</code>, <code>F[+_, +_]</code>, <code>F[-_, +_, +_]</code> or <code>Identity</code>. <code>Spec</code>s provide an interface similar to ScalaTest&rsquo;s <a href="http://doc.scalatest.org/3.1.0/org/scalatest/wordspec/AnyWordSpec.html"><code>WordSpec</code></a>, however <code>distage-testkit</code> adds additional capabilities such as: first class support for effect types; dependency injection; and parallel execution.</p>
<p>Usage of <code>distage-testkit</code> generally follows these steps:</p>
<ol>
  <li>Extend a base class corresponding to the effect type:
    <ul>
      <li>No effect type - <a href="/latest/snapshot/api/izumi/distage/testkit/scalatest/SpecIdentity.html"><code>SpecIdentity</code></a></li>
      <li><code>F[_]</code> - <a href="/latest/snapshot/api/izumi/distage/testkit/scalatest/Spec1.html"><code>Spec1[F]</code></a>, for monofunctors (<code>cats.effect.IO</code>  , <code>monix</code>)</li>
      <li><code>F[+_, +_]</code> - <a href="/latest/snapshot/api/izumi/distage/testkit/scalatest/Spec2.html"><code>Spec2[F]</code></a>, for bifunctors (<code>ZIO</code>, <code>monix-bio</code>)</li>
      <li><code>F[-_, +_, +_]</code> - <a href="/latest/snapshot/api/izumi/distage/testkit/scalatest/Spec3.html"><code>Spec3[F]</code></a> for trifunctors (<code>ZIO</code>)</li>
    </ul>
  </li>
  <li>Override <code>def config: TestConfig</code> to customize the <a href="/latest/snapshot/api/izumi/distage/testkit/TestConfig.html"><code>TestConfig</code></a></li>
  <li>Establish test case contexts  using <a href="https://www.scalatest.org/scaladoc/3.2.0/org/scalatest/verbs/ShouldVerb.html"><code>should</code></a>,  <a href="https://www.scalatest.org/scaladoc/3.2.0/org/scalatest/verbs/MustVerb.html"><code>must</code></a>,  or <a href="https://www.scalatest.org/scaladoc/3.2.0/org/scalatest/verbs/CanVerb.html"><code>can</code></a>.</li>
  <li>Introduce test cases using one of the <code>in</code> methods. These test cases can have a variety of forms, from plain  functions returning an  <a href="https://www.scalatest.org/scaladoc/3.2.0/org/scalatest/Assertions.html">assertion</a>, to effectful functions with  dependencies:
    <ul>
      <li>No effect type / <code>Identity</code> -  <a href="/latest/snapshot/api/izumi/distage/testkit/services/scalatest/dstest/DistageAbstractScalatestSpec$$LowPriorityIdentityOverloads.html"><code>in</code></a></li>
      <li><a href="/latest/snapshot/api/izumi/distage/testkit/services/scalatest/dstest/DistageAbstractScalatestSpec$$DSWordSpecStringWrapper.html"><code>in</code> for <code>F[_]</code></a></li>
      <li><a href="/latest/snapshot/api/izumi/distage/testkit/services/scalatest/dstest/DistageAbstractScalatestSpec$$DSWordSpecStringWrapper2.html"><code>in</code> for <code>F[+_, +_]</code></a></li>
      <li><a href="/latest/snapshot/api/izumi/distage/testkit/services/scalatest/dstest/DistageAbstractScalatestSpec$$DSWordSpecStringWrapper3.html"><code>in</code> for <code>F[-_, +_, +_]</code></a></li>
      <li>Test cases dependent on injectables: <a href="/latest/snapshot/api/izumi/distage/model/providers/Functoid.html"><code>Functoid</code></a></li>
    </ul>
  </li>
</ol>
<h3><a href="#api-overview" name="api-overview" class="anchor"><span class="anchor-link"></span></a>API Overview</h3>
<p>The highest value tests to develop <a href="https://blog.7mind.io/constructive-test-taxonomy.html">in our experience</a> are those that verify the communication behavior of components. These are tests of blackbox interfaces, with atomic or group isolation levels.</p>
<p>To demonstrate usage of <code>distage-testkit</code> we&rsquo;ll consider a hypothetical game score system. This system will have a model, logic, and service which we&rsquo;ll then define test cases to verify. Our application will use <code>ZIO[-R, +E, +A]</code>.</p>
<p>We&rsquo;ll start with the following model and service interface for the game score system:</p>
<pre class="prettyprint"><code class="language-scala">package app

import zio._
import zio.console.{Console, putStrLn}

final case class Score(
  value: Int
)

final case class Config(
  starValue: Int,
  mangoValue: Int,
  defaultBonus: Int,
)

trait BonusService {
  def queryCurrentBonus: Task[Int]
  def increaseCurrentBonus(delta: Int): Task[Int]
}

object Score {
  val zero = Score(0)

  def addStar(config: Config, score: Score) =
    score.copy(value = score.value + config.starValue)

  def echoConfig(config: Config): RIO[Has[Console.Service], Config] =
    for {
      _ &lt;- putStrLn(config.toString)
    } yield config

  def addMango(config: Config, score: Score): RIO[Has[Console.Service] with Has[BonusService], Score] =
    for {
      bonusService &lt;- RIO.service[BonusService]
      currentBonus &lt;- bonusService.queryCurrentBonus
    } yield {
      val value = score.value + config.mangoValue + currentBonus
      score.copy(value = value)
    }
}
</code></pre>
<p>This represents a game score system where the player can collect Stars or Mangoes with differently configured and calculated point values.</p>
<h4><a href="#spec-base-classes" name="spec-base-classes" class="anchor"><span class="anchor-link"></span></a><code>Spec</code> Base Classes</h4>
<p>There are test suite base classes for functor, bifunctor and trifunctor effect types. We will be choosing the one that matches our application&rsquo;s effect type from the following:</p>
<ul>
  <li>No effect type, imperative usage - <a href="/latest/snapshot/api/izumi/distage/testkit/scalatest/SpecIdentity.html"><code>SpecIdentity</code></a></li>
  <li><code>F[_]</code> - <a href="/latest/snapshot/api/izumi/distage/testkit/scalatest/Spec1.html"><code>Spec1[F]</code></a></li>
  <li><code>F[+_, +_]</code> - <a href="/latest/snapshot/api/izumi/distage/testkit/scalatest/Spec2.html"><code>Spec2[F]</code></a></li>
  <li><code>F[-_, +_, +_]</code> - <a href="/latest/snapshot/api/izumi/distage/testkit/scalatest/Spec3.html"><code>Spec3[F]</code></a></li>
</ul>
<p>The effect monad is expected to support sync and async effects. <code>distage-testkit</code> provides this support for <code>Identity</code> , <code>monix</code>, <code>monix-bio</code>, <code>ZIO</code>, and monads wth instances of <code>cats-effect</code> or <a href="../bio/index.html">BIO</a> typeclasses. For our demonstration application, the tests will use the <code>ZIO[-R, +E, +A]</code> effect type. This means we&rsquo;ll be using <code>Spec3[ZIO]</code> for the test suite base class.</p>
<p>The default config (<code>super.config</code>) has <code>pluginConfig</code>, which by default will scan the package the test is defined in for defined Plugin modules. See the <a href="distage-framework.html#plugins"><code>distage-extension-plugins</code></a> documentation for more information. For our demonstration the module will be provided using explicit <code>moduleOverrides</code> instead of classpath scanning, like so:</p>
<pre class="prettyprint"><code class="language-scala">package app

import com.typesafe.config.ConfigFactory
import distage.ModuleDef
import izumi.distage.testkit.scalatest.{AssertZIO, Spec3}

abstract class Test extends Spec3[ZIO] with AssertZIO {
  val defaultConfig = Config(
    starValue = 10,
    mangoValue = 256,
    defaultBonus = 10,
  )

  override def config = super
    .config.copy(
      moduleOverrides = new ModuleDef {
        make[Config].from(defaultConfig)
      },
      debugOutput = true,
    )
}
</code></pre>
<h4><a href="#test-cases" name="test-cases" class="anchor"><span class="anchor-link"></span></a>Test Cases</h4>
<p>In <code>WordSpec</code>, a test case is a sentence (a <code>String</code>) followed by <code>in</code> then the body. In <code>distage-testkit</code> the body of the test case is not limited to a function returning an <a href="https://www.scalatest.org/scaladoc/3.2.0/org/scalatest/Assertions.html">assertion</a>.</p>
<p><a href="/latest/snapshot/api/izumi/distage/model/providers/Functoid.html">Functions that take arguments</a> and functions using effect types are also supported. Function arguments and effect environments will be provided according to the <code>distage</code> object graph created from the modules defined in <a href="izumi.distage.testkit.TestConfig"><code>def config: TestConfig</code></a>.</p>
<h4><a href="#assertions" name="assertions" class="anchor"><span class="anchor-link"></span></a>Assertions</h4>
<p>All of the base classes support test cases that are:</p>
<ul>
  <li>Assertions.</li>
  <li>Functions returning an assertion.</li>
  <li>Functions returning unit that fail on exception.</li>
</ul>
<p>These are introduced using <code>in</code> from <a href="/latest/snapshot/api/izumi/distage/testkit/services/scalatest/dstest/DistageAbstractScalatestSpec$$LowPriorityIdentityOverloads.html">DistageAbstractScalatestSpec.LowPriorityIdentityOverloads</a></p>
<p>The assertion methods are the same as ScalaTest as the base classes extend <a href="https://www.scalatest.org/scaladoc/3.2.0/org/scalatest/Assertions.html">ScalaTest Assertions</a>.</p>
<p>Let&rsquo;s now create a simple test for our demonstration application:</p>
<pre class="prettyprint"><code class="language-scala">package app

class ScoreSimpleTest extends Test {

  &quot;Score&quot; should {

    &quot;increase by config star value&quot; in {
      val starValue = util.Random.nextInt()
      val mangoValue = util.Random.nextInt()
      val defaultBonus = util.Random.nextInt()
      val config = Config(starValue, mangoValue, defaultBonus)
      val expected = Score(starValue)
      val actual = Score.addStar(config, Score.zero)
      assert(actual == expected)
    }

    // Use `Config` from the module in the `Test` class above
    &quot;increase by config star value from DI&quot; in {
      config: Config =&gt;
        val expected = Score(defaultConfig.starValue)
        val actual = Score.addStar(config, Score.zero)
        assert(actual == expected)
    }

  }
}
</code></pre>
<pre><code>ScoreSimpleTest:
- Score should increase by config star value
  - Score should increase by config star value from DI 
- Score should increase by config star value from DI


</code></pre>
<h4><a href="#assertions-with-effects" name="assertions-with-effects" class="anchor"><span class="anchor-link"></span></a>Assertions with Effects</h4>
<p>All of the base classes support test cases that are effects with assertions. Functions returning effects will have arguments provided from the object graph. These test cases are supported by <a href="/latest/snapshot/api/izumi/distage/testkit/services/scalatest/dstest/DistageAbstractScalatestSpec$$DSWordSpecStringWrapper.html"><code>in</code> from DSWordSpecStringWrapper</a>.</p>
<p>The different effect types fix the <code>F[_]</code> argument for this syntax:</p>
<ul>
  <li><code>Spec1</code>: <code>F[_]</code></li>
  <li><code>Spec2</code>: <code>F[Throwable, _]</code></li>
  <li><code>Spec3</code>: <code>F[Any, Throwable, _]</code></li>
</ul>
<p>With our demonstration application we&rsquo;ll use this to verify the <code>Score.echoConfig</code> method. The <code>Config</code> required is from the <code>distage</code> object graph defined in <code>moduleOverrides</code>. By using a function with a <code>Config</code> argument in <code>in</code>, the required argument will be injected by <code>distage-testkit</code>.</p>
<pre class="prettyprint"><code class="language-scala">package app

class ScoreEffectsTest extends Test {
  &quot;testkit operations with effects&quot; should {

    &quot;support assertions in effects&quot; in {
      (config: Config) =&gt;
        for {
          actual &lt;- Score.echoConfig(config)
          _      &lt;- assertIO(actual == config)
        } yield ()
    }

    &quot;support assertions outside of effect&quot; in {
      (config: Config) =&gt;
        for {
          actual &lt;- Score.echoConfig(config)
        } yield {
          assert(actual == config)
        }
    }
  }
}
</code></pre>
<pre><code>ScoreEffectsTest:
Config(10,256,10)
Config(10,256,10)
  - testkit operations with effects should support assertions outside of effect 
- testkit operations with effects should support assertions outside of effect
  - testkit operations with effects should support assertions in effects 
- testkit operations with effects should support assertions in effects


</code></pre>
<h4><a href="#assertions-with-effects-with-environments" name="assertions-with-effects-with-environments" class="anchor"><span class="anchor-link"></span></a>Assertions with Effects with Environments</h4>
<p><a href="/latest/snapshot/api/izumi/distage/testkit/services/scalatest/dstest/DistageAbstractScalatestSpec$$DSWordSpecStringWrapper3.html">The <code>in</code> method for <code>F[_, _, _]</code> effect types</a> supports injection of environments from the object graph in addition to simple assertions and assertions with effects.</p>
<p>A test that verifies the <code>BonusService</code> in our demonstration would be:</p>
<pre class="prettyprint"><code class="language-scala">package app

abstract class BonusServiceTest extends Test {
  &quot;BonusService&quot; should {

    &quot;initially use default bonus as current&quot; in {
      for {
        bonusService &lt;- ZIO.service[BonusService]
        currentBonus &lt;- bonusService.queryCurrentBonus
        _            &lt;- putStrLn(s&quot;currentBonus = $currentBonus&quot;)
        _            &lt;- assertIO(currentBonus == defaultConfig.defaultBonus)
      } yield ()
    }

    &quot;increment by delta&quot; in {
      for {
        delta        &lt;- zio.random.nextInt
        bonusService &lt;- ZIO.service[BonusService]
        initialBonus &lt;- bonusService.queryCurrentBonus
        actualBonus  &lt;- bonusService.increaseCurrentBonus(delta)
        expectedBonus = initialBonus + delta
        _            &lt;- assertIO(actualBonus == expectedBonus)
      } yield ()
    }

  }
}
</code></pre>
<p>The <a href="basics.html#zio-has-bindings">ZIO Has injection</a> support extends to the test cases, here we request two components implicitly using the ZIO environment:</p>
<ul>
  <li><code>BonusService</code> - is requested by <code>ZIO.service[BonusService]</code></li>
  <li><code>zio.Random.Service</code> - is requested by <code>zio.random.nextInt</code></li>
</ul>
<p>While this compiles just fine, this test cannot be run without the object graph containing a <code>BonusService</code> component!</p>
<p>Our demonstration application includes <code>dummy</code> and <code>production</code> implementations for <code>BonusService</code>. For each implementation, we define a <code>ZManaged</code> value describing how to create and finalize it. After adding implementations for <code>BonusService</code> component using these <code>ZManaged</code>&rsquo;s as constructors, our test cases will be able to use the component <code>BonusService</code>.</p>
<pre class="prettyprint"><code class="language-scala">package app

object DummyBonusService {

  class Impl(
     bonusState: Ref[Int]
  ) extends BonusService {

    override def queryCurrentBonus: UIO[Int] = {
      bonusState.get
    }

    override def increaseCurrentBonus(delta: Int): UIO[Int] = {
      bonusState.updateAndGet(_ + delta)
    }
  }

  val acquire: Task[DummyBonusService.Impl] = for {
    ref &lt;- Ref.make(10)
    impl = new Impl(ref)
  } yield impl

  val release: UIO[Unit] = UIO.unit

  val managed: TaskManaged[DummyBonusService.Impl] =
    acquire.toManaged(_ =&gt; release)
}
</code></pre>
<p>This dummy implementation is useful for verification in both automated tests and functional prototypes.</p>
<p>For a real system we might build a production implementation like the following. This hypothetical implementation would perform an HTTP request to a REST service. We&rsquo;ll introduce a production service, but this actual query will be unimplemented for our demonstration:</p>
<pre class="prettyprint"><code class="language-scala">package app

object ProdBonusService {

  class Impl(
    console: Console.Service,
    url: String,
  ) extends BonusService {

    override def queryCurrentBonus = for {
      _ &lt;- console.putStrLn(s&quot;querying $url&quot;)
    } yield ???

    override def increaseCurrentBonus(delta: Int) = for {
      _ &lt;- console.putStrLn(s&quot;post to $url&quot;)
    } yield ???
  }

  val acquire: RIO[Has[Console.Service], ProdBonusService.Impl] = for {
    console &lt;- ZIO.service[Console.Service]
    impl      = new Impl(console, &quot;https://my-bonus-server/current-bonus.json&quot;)
  } yield impl

  val release: UIO[Unit] = UIO.unit

  val managed: RManaged[Has[Console.Service], ProdBonusService.Impl] =
    acquire.toManaged(_ =&gt; release)
}
</code></pre>
<h4><a href="#pattern-dual-test-tactic" name="pattern-dual-test-tactic" class="anchor"><span class="anchor-link"></span></a>Pattern: Dual Test Tactic</h4>
<p>The testing of <code>BonusService</code> in our demonstration application will follow the Dual Test Tactic. See our blog post <a href="https://blog.7mind.io/constructive-test-taxonomy.html">Unit, Functional, Integration? You are doing it wrong</a> for a discussion of test taxonomy and the value of this tactic.</p>
<p>A binding for the implementation of <code>BonusService</code> must be passed to <code>distage</code>, to be able to build a <code>Has[BonusService]</code> to inject into the <code>ZIO</code> environment of the test.</p>
<p>But note that we have two implementations, to use both one option is to define separate modules for the dummy and production implementations. One module would be used by tests and the other only by production.</p>
<p>However, this is not as declaring both implementations in our modules at the same time but with different activations.</p>
<p>Our demonstration application will use the <a href="/latest/snapshot/api/izumi/distage/model/definition/StandardAxis$$Repo$.html">StandardAxis.Repo</a> <code>Dummy</code> and <code>Prod</code> axis tags:</p>
<pre class="prettyprint"><code class="language-scala">package app

import distage.plugins.PluginDef
import distage.Activation
import distage.StandardAxis.Repo

object BonusServicePlugin extends PluginDef {
  make[BonusService]
    .fromHas(DummyBonusService.managed)
    .tagged(Repo.Dummy)

  make[BonusService]
    .fromHas(ProdBonusService.managed)
    .tagged(Repo.Prod)
}
</code></pre>
<p>Here we used <a href="basics.html#zio-has-bindings">ZIO Has injection</a> <code>.fromHas</code> to supply the environment dependencies for <code>ProdBonusService.managed</code>, namely <code>Has[Console.Service]</code>. (Implementation for <code>Console.Service</code> is provided by default from <a href="/latest/snapshot/api/izumi/distage/modules/support/ZIOSupportModule.html">ZIOSupportModule</a>) <code>.fromHas</code> can be used with <code>ZLayer</code>, <code>ZManaged</code> <code>ZIO</code> or any <code>F[-_, +_, +_]: Local3</code> (from <a href="../bio/index.html">BIO</a> typeclasses).</p>
<p>Note that the <code>BonusServicePlugin</code> is not explicitly added to the <code>Test.config</code>: But, this <code>PluginDef</code> class is defined in the same package as the test, namely in <code>app</code>. By default the <code>pluginConfig</code> for the test will include the test&rsquo;s package, which will be scanned by <code>distage</code> for <code>PluginDef</code> instances.</p>
<p>Continuing with the pattern, a trait will control which implementation is activated:</p>
<pre class="prettyprint"><code class="language-scala">package app

trait DummyTest extends Test {
  override def config = super
    .config.copy(
      activation = Activation(Repo -&gt; Repo.Dummy)
    )
}

trait ProdTest extends Test {
  override def config = super
    .config.copy(
      activation = Activation(Repo -&gt; Repo.Prod)
    )
}
</code></pre>
<p>With these, a production test and a dummy test can be introduced for the demonstration game score application. Note how these share the same test code, in <code>BonusServiceTest</code> and differ only in activations.</p>
<p>When extended beyond this small example, this pattern simplifies system level tests, sanity checks, and even a pragmatic form of <a href="https://en.wikipedia.org/wiki/N-version_programming">N-Version Programming</a>:</p>
<pre class="prettyprint"><code class="language-scala">package app

class ProdBonusServiceTest extends BonusServiceTest with ProdTest

class DummyBonusServiceTest extends BonusServiceTest with DummyTest
</code></pre>
<pre><code>DummyBonusServiceTest:
currentBonus = 10
  - BonusService should initially use default bonus as current 
- BonusService should initially use default bonus as current
  - BonusService should increment by delta 
- BonusService should increment by delta


</code></pre>
<h4><a href="#test-case-context" name="test-case-context" class="anchor"><span class="anchor-link"></span></a>Test Case Context</h4>
<p>The <code>testkit</code> ScalaTest base classes include the following verbs for establishing test context:</p>
<ul>
  <li><a href="https://www.scalatest.org/scaladoc/3.2.0/org/scalatest/verbs/ShouldVerb.html"><code>should</code></a></li>
  <li><a href="https://www.scalatest.org/scaladoc/3.2.0/org/scalatest/verbs/MustVerb.html"><code>must</code></a></li>
  <li><a href="https://www.scalatest.org/scaladoc/3.2.0/org/scalatest/verbs/CanVerb.html"><code>can</code></a></li>
</ul>
<h4><a href="#configuration" name="configuration" class="anchor"><span class="anchor-link"></span></a>Configuration</h4>
<p>The test suite class for your application should override the <code>def config: TestConfig</code> attribute.</p>
<p><code>config</code> defines plugin configuration, memoization, module overrides and other options.</p>
<p>See also:</p>
<ul>
  <li><a href="/latest/snapshot/api/izumi/distage/testkit/TestConfig.html"><code>TestConfig</code> API docs</a>.</li>
  <li><a href="#resource-reuse-memoization">Memoization</a></li>
  <li><a href="#execution-order">Execution Order</a></li>
</ul>
<h3><a href="#syntax-reference" name="syntax-reference" class="anchor"><span class="anchor-link"></span></a>Syntax Reference</h3>
<p>For <code>F[_]</code>, including <code>Identity</code>:</p>
<ul>
  <li><code>in { assert(???) }</code>: The test case is a function returning an  <a href="https://www.scalatest.org/scaladoc/3.2.0/org/scalatest/Assertions.html">assertion</a>.</li>
  <li><code>in { (a: A, b: B) =&gt; assert(???) }</code>: The test case is a function returning an assertion. The <code>a</code> and  <code>b</code> will be injected from the object graph.</li>
  <li><code>in { (a: A, b: B) =&gt; ???: F[Unit] }</code>: The test case is a function returning an effect to be executed. The <code>a</code> and <code>b</code>  will be injected from the object graph. The test case will fail if the effect fails.</li>
  <li><code>in { (a: A, b: B) =&gt; ???: F[Assertion] }</code>: The test case is a function returning an effect to be executed. The <code>a</code>  and <code>b</code> will be injected from the object graph. The test case will fail if the effect fails or produces a failure  assertion.</li>
</ul>
<p>For <code>F[-_, +_, +_]</code>, it&rsquo;s same with <code>F[Any, _, _]</code>:</p>
<ul>
  <li><code>in { ???: F[zio.Has[C] with zio.Has[D], _, Unit] }</code>: The test case is an effect requiring an environment. The test  case will fail if the effect fails. The environment will be injected from the object graph.</li>
  <li><code>in { ???: F[zio.Has[C] with zio.Has[D], _, Assertion] }</code>: The test case is an effect requiring an environment. The  test case will fail if the effect fails or produces a failure assertion. The environment will be injected from the  object graph.</li>
  <li><code>in { (a: A, b: B) =&gt; ???: F[zio.Has[C] with zio.Has[D], _, Assertion] }</code>: The test case is a function producing an  effect requiring an environment. All of <code>a: A</code>, <code>b: B</code>, <code>Has[C]</code> and <code>Has[D]</code>  will be injected from the object graph.</li>
</ul>
<p>Provided by trait <a href="/latest/snapshot/api/izumi/distage/testkit/scalatest/AssertZIO.html">AssertZIO</a>:</p>
<ul>
  <li><code>assertIO(_: Boolean): zio.ZIO[Any, Nothing, Assertion]</code></li>
</ul>
<p>Provided by trait <a href="/latest/snapshot/api/izumi/distage/testkit/scalatest/AssertMonix.html">AssertMonix</a>:</p>
<ul>
  <li><code>assertIO(_: Boolean): monix.eval.Task[Assertion]</code></li>
</ul>
<p>Provided by trait <a href="/latest/snapshot/api/izumi/distage/testkit/scalatest/AssertCIO.html">AssertCIO</a>:</p>
<ul>
  <li><code>assertIO(_: Boolean): cats.effect.IO[Assertion]</code></li>
</ul>
<p>Provided by trait <a href="/latest/snapshot/api/izumi/distage/testkit/scalatest/AssertIO2.html">AssertIO2</a>:</p>
<ul>
  <li><code>assertBIO[F[+_, +_]: IO2](_: Boolean): F[Nothing, Assertion]</code></li>
</ul>
<p>Provided by trait <a href="/latest/snapshot/api/izumi/distage/testkit/scalatest/AssertSync.html">AssertSync</a>:</p>
<ul>
  <li><code>assertIO[F[_]: Sync](_: Boolean): F[Assertion]</code></li>
</ul>
<h3><a href="#execution-order" name="execution-order" class="anchor"><span class="anchor-link"></span></a>Execution Order</h3>
<p>By default, tests are executed in parallel. This includes tests using <code>ZIO</code>, <code>monix</code>, <code>cats.effect.IO</code>, or any effect type with <a href="../bio/index.html">BIO</a> or <code>cats-effect</code> typeclass instances. <code>Identity</code> is treated as an effect type for imperative code.</p>
<p>Interoperability with all existing Scala effect types is provided by implicit instances of <a href="/latest/snapshot/api/izumi/distage/model/effect/QuasiIO.html"><code>QuasiIO</code></a>, <a href="/latest/snapshot/api/izumi/distage/model/effect/QuasiAsync.html"><code>QuasiAsync</code></a> , and <a href="/latest/snapshot/api/izumi/distage/model/effect/QuasiIORunner.html"><code>QuasiIORunner</code></a>. These components will be provided to the application automatically via <a href="/latest/snapshot/api/izumi/distage/modules/DefaultModule.html"><code>DefaultModule</code></a>, but may be overridden by user bindings if different behavior or support for custom effect types is required.</p>
<p>The execution of tests is grouped into:</p>
<ul>
  <li><a href="#resource-reuse-memoization">memoization levels</a>.</li>
  <li>test suite</li>
  <li>test cases</li>
</ul>
<p>The default is to run all of these in parallel.</p>
<p>The <a href="/latest/snapshot/api/izumi/distage/testkit/TestConfig.html"><code>TestConfig</code></a> has options to change the behavior for each of these groups. The default is <a href="/latest/snapshot/api/izumi/distage/testkit/TestConfig$$ParallelLevel$$Unlimited$.html"><code>ParallelLevel.Unlimited</code></a> which does not constrain the number of parallel tests. <code>ParallelLevel.Fixed(n: Int)</code> limits the execution to at most <code>n</code> test cases. While <code>ParallelLevel.Sequential</code> executes the test cases one at a time.</p>
<ul>
  <li><code>parallelEnvs</code> - Parallelism level for distinct memoization environments.</li>
  <li><code>parallelSuites</code> - Parallelism level for test suites.</li>
  <li><code>parallelTests</code> - Parallelism level for test cases.</li>
</ul>
<p>If a group is configured to execute sequentially this will execute after the parallel tests.</p>
<p>For example, the <code>BonusServiceTest</code> above consists of two test cases and one test suite. Both test cases will be executed in parallel using the capabilities of the effect type.</p>
<p>The <code>NotUsingMemoTest</code> and <code>UsingMemoTest</code> test suites below demonstrate executing the test cases sequentially for each test suite. However, the two suites themselves will execute in parallel as they are in the same memoization environment.</p>
<h3><a href="#resource-reuse-memoization" name="resource-reuse-memoization" class="anchor"><span class="anchor-link"></span></a>Resource Reuse - Memoization</h3>
<p>For each test, a new object graph with injected values is created. Without using memoization, all components will be created, acquired and released anew for each test case. This may be unwanted. For example, you may wish to reuse a single PostgreSQL container for a sequence of test cases. In which case the PostgreSQL component should be memoized for the duration of those test cases.</p>
<p>Configuring memoization determines whether summoning a component results in a fresh component or reuses an existing, memoized, instance.</p>
<p>Further, the memoization environment determines how the test cases are scheduled for execution. See <a href="#execution-order">the execution order section for further information.</a></p>
<h4><a href="#memoization-environments" name="memoization-environments" class="anchor"><span class="anchor-link"></span></a>Memoization Environments</h4>
<p>Memoization strategy applied when a component is summoned is defined by the <em>memoization environment</em>. Each distinct memoization environment uses a distinct memoization store. When a component instance is memoized that instance is shared across all tests that use the same memoization environment. <a href="/latest/snapshot/api/izumi/distage/testkit/TestConfig.html"><code>TestConfig</code></a> contains the options that define the memoization environment:</p>
<ol>
  <li><code>memoizationRoots</code> - These components will be acquired once and shared across all tests that used the same  memoization environment.</li>
  <li><code>activation</code> - Chosen activation axis. Differences in Activation that affect the memoized part of the graph (that  alter implementations of components in <code>memoizationRoots</code> <em>or</em> their transitive dependencies) will  cause the test to execute in a new memoization environment.</li>
  <li><code>pluginConfig</code> - Defines the plugins to source module definitions.</li>
  <li><code>forcedRoots</code> - Components treated as a dependency of every test. A component added both to <code>forcedRoots</code> and  <code>memoizationRoots</code> will be acquired at the start of all tests and released at the end of all tests in the memoization  environment.</li>
  <li><code>moduleOverrides</code> - Overrides the modules from <code>pluginConfig</code>.</li>
</ol>
<p>The module environment depends on instantiation of the <code>memoizationRoots</code> components. Changes to the config that alter implementations of these components <em>or</em> their dependencies will change the memoization environment used. This includes, but is not limited to, changes to <code>activation</code>, <code>pluginConfig</code> and <code>moduleOverrides</code>.</p>
<p>When the <code>TestConfig</code> option <a href="/latest/snapshot/api/izumi/distage/testkit/TestConfig.html"><code>debugOutput</code></a> is true the debug output will include memoization environment diagnostics. This can also be controlled using the <a href="izumi.distage.testkit.DebugProperties$"><code>izumi.distage.testkit.debug</code></a> system property.</p>
<h4><a href="#memoization-levels" name="memoization-levels" class="anchor"><span class="anchor-link"></span></a>Memoization Levels</h4>
<p>Since version <code>1.0</code> the above memoization environments scheme has been generalized to support unlimited nesting of memoization environments.</p>
<p>Nested memoization levels allow more and better sharing of heavy components among test suites. With previous strategy of single-level memoization environments, any change in <code>TestConfig</code> that forces a new memoization environment would cause every single memoized component to be recreated in a new environment.</p>
<p>With new strategy, the memoization environment may be manually partitioned into levels and if a change in <code>TestConfig</code> does not cause a divergence at one of the levels, the nested levels may then fully reuse the object sub-graph of all parent levels that do not diverge.</p>
<p>For clarity, the memoization tree structure is printed before test runs. For example, a memoization tree of a project with the following test suites:</p>
<pre class="prettyprint"><code class="language-scala">class SameLevel_1_WithActivationsOverride extends Spec3[ZIO] {
  override protected def config: TestConfig = {
    super.config.copy(
        memoizationRoots = Map(
          1 -&gt; Set(DIKey[MemoizedInstance], DIKey[MemoizedLevel1]),
          2 -&gt; Set(DIKey[MemoizedLevel2]),
        ),
    )
  }
}

class SameLevel_1_2_WithAdditionalLevel3 extends SameLevel_1_WithActivationsOverride {
  override protected def config: TestConfig = {
    super.config.copy(
      memoizationRoots =
        super.config.memoizationRoots ++
        Set(DIKey[MemoizedLevel3]),
    )
  }
}
</code></pre>
<p>May be visualized as follows:</p>
<p><img src="media/memoization-tree.png" alt="Memoization Tree Log during tests" /></p>
<p>Technical note: divergence of memoization levels is calculated based on equality of <a href="debugging.html#pretty-printing-plans">recipes of future object graphs</a>, not equality of allocated/existing object graphs.</p>
<p>Note: <a href="https://github.com/7mind/izumi/issues/1188">original github ticket</a></p>
<h4><a href="#examples" name="examples" class="anchor"><span class="anchor-link"></span></a>Examples</h4>
<p>The first example will acquire the <code>BonusService</code> for each test case. This will not use memoization.</p>
<pre class="prettyprint"><code class="language-scala">package app

import izumi.distage.testkit.TestConfig

class NotUsingMemoTest extends DummyTest {
  override def config = super
    .config.copy(
      // this demo requires the tests to run sequentially
      parallelTests = TestConfig.ParallelLevel.Sequential
    )

  &quot;Not memoizing BonusService&quot; should {
    &quot;use a new instance in the first case&quot; in {
      val delta = util.Random.nextInt()

      for {
        bonusService &lt;- ZIO.service[BonusService]
        _            &lt;- console.putStrLn(s&quot;\n bonusService = ${bonusService} \n&quot;)

        // change the bonus service state
        currentBonus &lt;- bonusService.increaseCurrentBonus(delta)
        expectedBonus = defaultConfig.defaultBonus + delta

        _            &lt;- assertIO(currentBonus == expectedBonus)
      } yield ()
    }

    &quot;use a new instance in the second case&quot; in {
      for {
        bonusService &lt;- ZIO.service[BonusService]
        _            &lt;- console.putStrLn(s&quot;\n bonusService = ${bonusService} \n&quot;)

        currentBonus &lt;- bonusService.queryCurrentBonus

        // verify the state is unchanged from default
        _            &lt;- assertIO(currentBonus == defaultConfig.defaultBonus)
      } yield ()
    }
  }
}
</code></pre>
<p>These two tests will run sequentially. There is no memoization configured for the dependencies. Each test case will acquire a fresh instance from the object graph. For our demonstration this results in a new <code>BonusService</code> instance for each test case.</p>
<pre><code>NotUsingMemoTest:

 bonusService = repl.MdocSession$App$DummyBonusService$Impl@2ab6f9f2 

  - Not memoizing BonusService should use a new instance in the first case 
- Not memoizing BonusService should use a new instance in the first case

 bonusService = repl.MdocSession$App$DummyBonusService$Impl@5d50bca7 

  - Not memoizing BonusService should use a new instance in the second case 
- Not memoizing BonusService should use a new instance in the second case


</code></pre>
<p>Configuring the test to memoize <code>BonusService</code> will result in the same instance being used for both test cases:</p>
<pre class="prettyprint"><code class="language-scala">package app

import distage.DIKey

class UsingMemoTest extends DummyTest {
  override def config = super
    .config.copy(
      memoizationRoots = super.config.memoizationRoots ++ Set(DIKey[BonusService]),
      // this demo requires the test cases to run sequentially
      parallelTests = TestConfig.ParallelLevel.Sequential
    )

  val delta = util.Random.nextInt()

  &quot;Memoizing BonusService&quot; should {
    &quot;use a new instance in the first case&quot; in {
      for {
        bonusService &lt;- ZIO.service[BonusService]
        _            &lt;- console.putStrLn(s&quot;\n bonusService = ${bonusService} \n&quot;)

        // change the bonus service state
        currentBonus &lt;- bonusService.increaseCurrentBonus(delta)
        expectedBonus = defaultConfig.defaultBonus + delta

        _            &lt;- assertIO(currentBonus == expectedBonus)
      } yield ()
    }

    &quot;use the same instance in the second case&quot; in {
      for {
        bonusService &lt;- ZIO.service[BonusService]
        _            &lt;- console.putStrLn(s&quot;\n bonusService = ${bonusService} \n&quot;)

        currentBonus &lt;- bonusService.queryCurrentBonus
        expectedBonus = defaultConfig.defaultBonus + delta

        // verify the change in the first case modified this bonusService
        _            &lt;- assertIO(currentBonus == expectedBonus)
      } yield ()
    }
  }
}
</code></pre>
<p>The memoization roots include <code>BonusService</code>. This results in the same <code>BonusService</code> instance for each test case.</p>
<p>This test requires the effect of the first test case to occur prior to the second test case. As discussed <a href="#execution-order">Execution Order section</a>: Without configuring test cases for sequential execution this order would not be guaranteed.</p>
<p>Note that this test will <em>not</em> use the same <code>BonusService</code> instance as <code>NotUsingMemoTest</code>. The configs for these test have different memoization roots. This results in different <a href="#memoization-environments">memoization environments</a>.</p>
<p>If the memoization environments are equal then the components will be shared.</p>
<p>For our example, any other test suite with the same memoization environment will share the same <code>BonusService</code> instance:</p>
<pre class="prettyprint"><code class="language-scala">package app

class AnotherUsingMemoTest extends DummyTest {
  // This is the same memoization environment even tho the config is declared separately
  override def config = super
    .config.copy(
      memoizationRoots = super.config.memoizationRoots ++ Set(DIKey[BonusService]),
      // this demo requires the test cases to run sequentially
      parallelTests = TestConfig.ParallelLevel.Sequential
    )

  &quot;Another test using BonusService&quot; should {
    &quot;use the same instance&quot; in {
      for {
        bonusService &lt;- ZIO.service[BonusService]
        _            &lt;- console.putStrLn(s&quot;\n bonusService = ${bonusService} \n&quot;)
        currentBonus &lt;- bonusService.queryCurrentBonus
        _            &lt;- console.putStrLn(s&quot;currentBonus = ${currentBonus}&quot;)
      } yield ()
    }
  }
}
</code></pre>
<p>Both tests suites, all three test cases, will use same memoization environment and the same <code>bonusService</code> instance:</p>
<pre><code>UsingMemoTest:

 bonusService = repl.MdocSession$App$DummyBonusService$Impl@35c3c20c 


 bonusService = repl.MdocSession$App$DummyBonusService$Impl@35c3c20c 

currentBonus = 10
  - Memoizing BonusService should use a new instance in the first case 
- Memoizing BonusService should use a new instance in the first case

 bonusService = repl.MdocSession$App$DummyBonusService$Impl@35c3c20c 

  - Memoizing BonusService should use the same instance in the second case 
- Memoizing BonusService should use the same instance in the second case


AnotherUsingMemoTest:
  - Another test using BonusService should use the same instance 
- Another test using BonusService should use the same instance


</code></pre>
<h4><a href="#pseudocode" name="pseudocode" class="anchor"><span class="anchor-link"></span></a>Pseudocode</h4>
<p>Suppose that the lookup of an instance for a component uses a hypothetical function <code>lookup(graph, type and tag)</code>. This function is memoized using storage specific to the current memoization environment. This memoization environment is uniquely defined by the test config options above. This would have pseudocode like:</p>
<pre><code>rootComponents = planRoots(memoizationRoots, activation, forcedRoots, ...)
memoizationEnvironment = getOrCreate(rootComponents)
memoizationStore = memoizationEnvironment.store
...
for each test case
  add forcedRoots to component dependencies
  for each component dependency:
    if memoizationStore contains component
    then
      instance = memoizationStore.lookup(component)
    else
      instance = acquireComponent(component)
      if (component is in memoizationRoot paths)
        memoizationStore.add(component, instance)
    ...
</code></pre>
<h3><a href="#forced-roots" name="forced-roots" class="anchor"><span class="anchor-link"></span></a>Forced Roots</h3>
<p><code>forcedRoots</code> field of <code>TestConfig</code> specifies components to synthetically add to the dependencies of every test within this test suite / memoization environment.</p>
<p>If forced root components are not memoized, they will be acquired and released for each test case.</p>
<p>If memoized, they will be acquired and released once, before all and after all the tests within this memoization environment.</p>
<p>They provide an alternative to ScalaTest&rsquo;s native <code>beforeEach/beforeAll</code> that can use functional effects instead of mutability (However, <code>All</code> here includes the entire memoization environment, not the enclosing test suite)</p>
<p>Forced roots may be configured per-activation / combination of activations, e.g. you may force postgres table setup to happen only in test environments with <code>Repo -&gt; Repo.Prod</code> activation.</p>
<h3><a href="#test-selection" name="test-selection" class="anchor"><span class="anchor-link"></span></a>Test Selection</h3>
<h4><a href="#using-integrationcheck" name="using-integrationcheck" class="anchor"><span class="anchor-link"></span></a>Using <code>IntegrationCheck</code></h4>
<p>Implementation classes that inherit from <a href="/latest/snapshot/api/izumi/distage/framework/model/IntegrationCheck.html"><code>izumi.distage.framework.model.IntegrationCheck</code></a> will have their <code>resourceCheck()</code> method called before the test instantiation to check if external test dependencies â such as Docker containers in <a href="distage-framework-docker.html#docker-test-resources">distage-framework-docker</a> â are available for the test (or for the role when in main scope).</p>
<p>If not, the test will be canceled/ignored.</p>
<p>This feature therefore allows you to selectively run only the fast in-memory tests that have no external dependencies by shutting down the docker daemon (or another source of external dependencies).</p>
<p>Integration checks are executed only in <code>distage-testkit</code> tests and <code>distage-framework</code> <a href="distage-framework.html#roles">roles</a>.</p>
<h3><a href="#references" name="references" class="anchor"><span class="anchor-link"></span></a>References</h3>
<ul>
  <li><a href="https://github.com/7mind/distage-example">distage Example Project</a> project shows how to use <code>distage</code>, <code>distage-testkit</code> &amp; <code>distage-framework-docker</code></li>
  <li>Video for <a href="https://www.youtube.com/watch?v=CzpvjkUukAs">Hyper-pragmatic Pure FP Testing with distage-testkit</a> â is an overview of the concepts, design and usage.</li>
  <li>Slides for <a href="https://www.slideshare.net/7mind/hyperpragmatic-pure-fp-testing-with-distagetestkit">Hyper-pragmatic Pure FP testing with distage-testkit</a></li>
  <li>Slides for <a href="https://www.slideshare.net/7mind/scala-functional-programming-and-team-productivity">Scala, Functional Programming and Team Productivity</a></li>
  <li>7mind blog <a href="https://blog.7mind.io/constructive-test-taxonomy.html">Constructive Test Taxonomy</a></li>
  <li><a href="https://en.wikipedia.org/wiki/N-version_programming">N-Version Programming</a></li>
</ul>
<h2><a href="#extended-example" name="extended-example" class="anchor"><span class="anchor-link"></span></a>Extended Example</h2>
<p>This is an excerpt from <a href="https://github.com/7mind/distage-example">distage-example</a>, specifically the <a href="https://github.com/7mind/distage-example/blob/develop/src/test/scala/leaderboard/tests.scala">tests</a> source. Techniques in that example to look for:</p>
<ul>
  <li>Placing the <code>Profiles</code> component in the <code>memoizationRoots</code>. The axis <code>Repo.Prod</code> uses a PostgreSQL docker container.  This is shared across test cases since the <code>Profiles[IO]</code> depends on the PostgreSQL connection which then depends on  the container instance.</li>
  <li>Use of <code>Scene.Managed</code> to use <code>Repo.Prod</code> components in a managed environment.</li>
</ul>
<p>You may also take other projects&rsquo; test suites written with <code>distage-testkit</code> as reference:</p>
<ul>
  <li><a href="https://github.com/PlayQ/d4s/tree/develop/d4s-test/src/test/scala/d4s">tests in <code>d4s</code> library</a></li>
  <li><a href="https://github.com/7mind/izumi/tree/develop/distage/distage-testkit-scalatest/src/test/scala/izumi/distage/testkit/distagesuite">tests in <code>distage-testkit</code> library</a></li>
  <li><a href="https://github.com/7mind/izumi/tree/develop/distage/distage-framework-docker/src/test/scala/izumi/distage/testkit/docker">tests in <code>distage-framework-docker</code> library</a></li>
</ul>
<pre class="prettyprint"><code class="language-scala">import distage.{Activation, DIKey, ModuleDef}
import distage.StandardAxis.{Scene, Repo}
import distage.plugins.PluginConfig
import izumi.distage.testkit.TestConfig
import izumi.distage.testkit.scalatest.{AssertZIO, Spec3}
import leaderboard.model.{Score, UserId}
import leaderboard.repo.{Ladder, Profiles}
import leaderboard.zioenv.{ladder, rnd}
import zio.{ZIO, IO}

abstract class LeaderboardTest extends Spec3[ZIO] with AssertZIO {
  override def config = TestConfig(
    pluginConfig = PluginConfig.cached(packagesEnabled = Seq(&quot;leaderboard.plugins&quot;)),
    moduleOverrides = new ModuleDef {
      make[Rnd[IO]].from[Rnd.Impl[IO]]
    },
    // For testing, setup a docker container with postgres,
    // instead of trying to connect to an external database
    activation = Activation(Scene -&gt; Scene.Managed),
    // Instantiate Ladder &amp; Profiles only once per test-run and
    // share them and all their dependencies across all tests.
    // this includes the Postgres Docker container above and table DDLs
    memoizationRoots = Set(
      DIKey[Ladder[IO]],
      DIKey[Profiles[IO]],
    ),
    configBaseName = &quot;leaderboard-test&quot;,
  )
}

trait DummyTest extends LeaderboardTest {
  override final def config = super.config.copy(
    activation = super.config.activation ++ Activation(Repo -&gt; Repo.Dummy)
  )
}

trait ProdTest extends LeaderboardTest {
  override final def config = super.config.copy(
    activation = super.config.activation ++ Activation(Repo -&gt; Repo.Prod)
  )
}

final class LadderTestDummy extends LadderTest with DummyTest
final class LadderTestPostgres extends LadderTest with ProdTest

abstract class LadderTest extends LeaderboardTest {

  &quot;Ladder&quot; should {
    // this test gets dependencies through arguments
    &quot;submit &amp; get&quot; in {
      (rnd: Rnd[IO], ladder: Ladder[IO]) =&gt;
        for {
          user  &lt;- rnd[UserId]
          score &lt;- rnd[Score]
          _     &lt;- ladder.submitScore(user, score)
          res   &lt;- ladder.getScores.map(_.find(_._1 == user).map(_._2))
          _     &lt;- assertIO(res contains score)
        } yield ()
    }

    // other tests get dependencies via ZIO Env:
    &quot;assign a higher position in the list to a higher score&quot; in {
      for {
        user1  &lt;- rnd[UserId]
        score1 &lt;- rnd[Score]
        user2  &lt;- rnd[UserId]
        score2 &lt;- rnd[Score]

        _      &lt;- ladder.submitScore(user1, score1)
        _      &lt;- ladder.submitScore(user2, score2)
        scores &lt;- ladder.getScores

        user1Rank = scores.indexWhere(_._1 == user1)
        user2Rank = scores.indexWhere(_._1 == user2)

        _ &lt;- if (score1 &gt; score2) {
          assertIO(user1Rank &lt; user2Rank)
        } else if (score2 &gt; score1) {
          assertIO(user2Rank &lt; user1Rank)
        } else IO.unit
      } yield ()
    }

    // you can also mix arguments and env at the same time
    &quot;assign a higher position in the list to a higher score 2&quot; in {
      ladder: Ladder[IO] =&gt;
          for {
            user1  &lt;- rnd[UserId]
            score1 &lt;- rnd[Score]
            user2  &lt;- rnd[UserId]
            score2 &lt;- rnd[Score]

            _      &lt;- ladder.submitScore(user1, score1)
            _      &lt;- ladder.submitScore(user2, score2)
            scores &lt;- ladder.getScores

            user1Rank = scores.indexWhere(_._1 == user1)
            user2Rank = scores.indexWhere(_._1 == user2)

            _ &lt;- if (score1 &gt; score2) {
              assertIO(user1Rank &lt; user2Rank)
            } else if (score2 &gt; score1) {
              assertIO(user2Rank &lt; user1Rank)
            } else IO.unit
          } yield ()
    }
  }

}
</code></pre>
</div>
<div>
<a href="https://github.com/7mind/izumi/tree/master/doc/microsite/target/mdoc/distage/distage-testkit.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
1.0.9*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../distage/distage-framework-docker.html" title="distage-framework-docker" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
distage-framework-docker
</span>
</div>
</a>
<a href="../distage/reference.html" title="Syntax Reference" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Syntax Reference
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
7mind.io
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
