<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="microsite">
<meta name="generator" content="Paradox, paradox-material-theme=0.7.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="microsite">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>Overview Â· Izumi Project</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Izumi Project" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Izumi Project
</span>
<span class="md-header-nav__topic">
Overview
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/7mind/izumi"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
7mind/izumi
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Izumi Project" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="../index.html" title="Izumi Project">
Izumi Project
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/7mind/izumi"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
7mind/izumi
</div>
</a>

</div>
<ul>
  <li><a href="../glossary.html" class="page">Izumi Glossary</a></li>
  <li><a href="../guidelines.html" class="page">Izumi Framework Best Practices</a></li>
  <li><a href="../bio/index.html" class="page">BIO Hierarchy</a></li>
  <li><a href="../logstage/index.html" class="page">LogStage</a></li>
  <li><a href="../distage/index.html" class="page">DIStage</a>
  <ul>
    <li><a href="../distage/basics.html" class="active page">Overview</a></li>
    <li><a href="../distage/debugging.html" class="page">Debugging</a></li>
    <li><a href="../distage/advanced-features.html" class="page">Advanced Features</a></li>
    <li><a href="../distage/distage-framework.html" class="page">distage-framework</a></li>
    <li><a href="../distage/distage-framework-docker.html" class="page">distage-framework-docker</a></li>
    <li><a href="../distage/distage-testkit.html" class="page">distage-testkit</a></li>
    <li><a href="../distage/reference.html" class="page">Syntax Reference</a></li>
  </ul></li>
  <li><a href="../idealingua/index.html" class="page">IdeaLingua</a>
  <ul>
    <li><a href="../idealingua/language-reference.html" class="page">Idealingua Language Reference</a></li>
    <li><a href="../idealingua/json.html" class="page">JSON Wire Format</a></li>
    <li><a href="../idealingua/cogen.html" class="page">Code generator reference</a></li>
    <li><a href="../idealingua/cogen-circe.html" class="page">Circe serialization reference</a></li>
  </ul></li>
  <li><a href="../sbt/index.html" class="page">SBT Notes</a></li>
  <li><a href="../manifesto/index.html" class="page">Productivity and challenges</a></li>
  <li><a href="../pper/index.html" class="page">PPER Pattern</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../distage/basics.html#overview" class="header">Overview</a>
  <ul>
    <li><a href="../distage/basics.html#quick-start" class="header">Quick Start</a></li>
    <li><a href="../distage/basics.html#real-world-example" class="header">Real-world example</a></li>
    <li><a href="../distage/basics.html#activation-axis" class="header">Activation Axis</a></li>
    <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings, Lifecycle</a></li>
    <li><a href="../distage/basics.html#out-of-the-box-typeclass-instances" class="header">Out-of-the-box typeclass instances</a></li>
    <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
    <li><a href="../distage/basics.html#mutator-bindings" class="header">Mutator Bindings</a></li>
    <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
    <li><a href="../distage/basics.html#zio-environment-bindings" class="header">ZIO Environment bindings</a></li>
    <li><a href="../distage/basics.html#auto-traits" class="header">Auto-Traits</a></li>
    <li><a href="../distage/basics.html#auto-factories" class="header">Auto-Factories</a></li>
    <li><a href="../distage/basics.html#subcontexts" class="header">Subcontexts</a></li>
    <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a></li>
    <li><a href="../distage/basics.html#cats-zio-integration" class="header">Cats &amp; ZIO Integration</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 1.2.9*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../distage/basics.html#overview" class="header">Overview</a>
  <ul>
    <li><a href="../distage/basics.html#quick-start" class="header">Quick Start</a></li>
    <li><a href="../distage/basics.html#real-world-example" class="header">Real-world example</a></li>
    <li><a href="../distage/basics.html#activation-axis" class="header">Activation Axis</a></li>
    <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings, Lifecycle</a></li>
    <li><a href="../distage/basics.html#out-of-the-box-typeclass-instances" class="header">Out-of-the-box typeclass instances</a></li>
    <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
    <li><a href="../distage/basics.html#mutator-bindings" class="header">Mutator Bindings</a></li>
    <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
    <li><a href="../distage/basics.html#zio-environment-bindings" class="header">ZIO Environment bindings</a></li>
    <li><a href="../distage/basics.html#auto-traits" class="header">Auto-Traits</a></li>
    <li><a href="../distage/basics.html#auto-factories" class="header">Auto-Factories</a></li>
    <li><a href="../distage/basics.html#subcontexts" class="header">Subcontexts</a></li>
    <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a></li>
    <li><a href="../distage/basics.html#cats-zio-integration" class="header">Cats &amp; ZIO Integration</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#overview" name="overview" class="anchor"><span class="anchor-link"></span></a>Overview</h1>
<div class="toc ">
<ul>
  <li><a href="../distage/basics.html#quick-start" class="header">Quick Start</a>
  <ul>
    <li><a href="../distage/basics.html#dependencies" class="header">Dependencies</a></li>
    <li><a href="../distage/basics.html#hello-world-example" class="header">Hello World example</a></li>
    <li><a href="../distage/basics.html#singleton-components" class="header">Singleton components</a></li>
    <li><a href="../distage/basics.html#named-components" class="header">Named components</a></li>
    <li><a href="../distage/basics.html#non-singleton-components" class="header">Non-singleton components</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#real-world-example" class="header">Real-world example</a></li>
  <li><a href="../distage/basics.html#activation-axis" class="header">Activation Axis</a>
  <ul>
    <li><a href="../distage/basics.html#multi-dimensionality" class="header">Multi-dimensionality</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings, Lifecycle</a>
  <ul>
    <li><a href="../distage/basics.html#inheritance-helpers" class="header">Inheritance helpers</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#out-of-the-box-typeclass-instances" class="header">Out-of-the-box typeclass instances</a></li>
  <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
  <li><a href="../distage/basics.html#mutator-bindings" class="header">Mutator Bindings</a></li>
  <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
  <li><a href="../distage/basics.html#zio-environment-bindings" class="header">ZIO Environment bindings</a>
  <ul>
    <li><a href="../distage/basics.html#converting-zio-environment-dependencies-to-parameters" class="header">Converting ZIO environment dependencies to parameters</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#auto-traits" class="header">Auto-Traits</a>
  <ul>
    <li><a href="../distage/basics.html#impl-annotation" class="header">@impl annotation</a></li>
    <li><a href="../distage/basics.html#avoiding-constructors-even-further" class="header">Avoiding constructors even further</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#auto-factories" class="header">Auto-Factories</a>
  <ul>
    <li><a href="../distage/basics.html#with-annotation" class="header">@With annotation</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#subcontexts" class="header">Subcontexts</a></li>
  <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a>
  <ul>
    <li><a href="../distage/basics.html#effect-type-polymorphism" class="header">Effect-type polymorphism</a></li>
    <li><a href="../distage/basics.html#kind-polymorphism" class="header">Kind polymorphism</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#cats-zio-integration" class="header">Cats &amp; ZIO Integration</a></li>
</ul>
</div>
<h2><a href="#quick-start" name="quick-start" class="anchor"><span class="anchor-link"></span></a>Quick Start</h2>
<h3><a href="#dependencies" name="dependencies" class="anchor"><span class="anchor-link"></span></a>Dependencies</h3>
<p>Add the <code>distage-core</code> library:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "io.7mind.izumi" %% "distage-core" % "1.2.9-SNAPSHOT"</code></pre></dd></dl>
<p>If you&rsquo;re using Scala 3 you <strong>must</strong> enable <code>-Yretain-trees</code> for this library to work correctly:</p>
<pre class="prettyprint"><code class="language-scala">// REQUIRED options for Scala 3
scalacOptions += &quot;-Yretain-trees&quot;
</code></pre>
<p>If you&rsquo;re using Scala <code>2.12</code> you <strong>must</strong> enable <code>-Ypartial-unification</code> and either <code>-Xsource:2.13</code> or <code>-Xsource:3</code> for this library to work correctly:</p>
<pre class="prettyprint"><code class="language-scala">// REQUIRED options for Scala 2.12
scalacOptions += &quot;-Ypartial-unification&quot;
scalacOptions += &quot;-Xsource:2.13&quot; // either this
// scalacOptions += &quot;-Xsource:3&quot; // or this
</code></pre>
<p>Additionally, some source examples in this document use underscore syntax for type lambdas which you can enable with the following options:</p>
<pre class="prettyprint"><code class="language-scala">// For kind-projector on Scala 2
scalacOptions += &quot;-P:kind-projector:underscore-placeholders&quot;

// For Scala 3
scalacOptions += &quot;-Ykind-projector:underscores&quot;
</code></pre>
<h3><a href="#hello-world-example" name="hello-world-example" class="anchor"><span class="anchor-link"></span></a>Hello World example</h3>
<p>Suppose we have an abstract <code>Greeter</code> component, and some other components that depend on it:</p>
<pre class="prettyprint"><code class="language-scala">import zio.Task
import zio.Console.{printLine, readLine}

trait Greeter {
  def hello(name: String): Task[Unit]
}

final class PrintGreeter extends Greeter {
  override def hello(name: String) =
    printLine(s&quot;Hello $name!&quot;)
}

trait Byer {
  def bye(name: String): Task[Unit]
}

final class PrintByer extends Byer {
  override def bye(name: String) =
    printLine(s&quot;Bye $name!&quot;)
}

final class HelloByeApp(
  greeter: Greeter,
  byer: Byer,
) {
  def run: Task[Unit] = {
    for {
      _    &lt;- printLine(&quot;What&#39;s your name?&quot;)
      name &lt;- readLine
      _    &lt;- greeter.hello(name)
      _    &lt;- byer.bye(name)
    } yield ()
  }
}
</code></pre>
<p>To actually run the <code>HelloByeApp</code>, we have to wire implementations of <code>Greeter</code> and <code>Byer</code> into it. We will not do it directly. First we&rsquo;ll only declare the component interfaces we have, and the implementations we want for them:</p>
<pre class="prettyprint"><code class="language-scala">import distage.ModuleDef

def HelloByeModule = new ModuleDef {
  make[Greeter].from[PrintGreeter]
  make[Byer].from[PrintByer]
  make[HelloByeApp] // `.from` is not required for concrete classes
}
</code></pre>
<p><code>ModuleDef</code> merely contains a description of the desired object graph, let&rsquo;s transform that high-level description into an actionable series of steps - a <a href="/latest/snapshot/api/izumi/distage/model/plan/Plan.html" title="izumi.distage.model.plan.Plan"><code>Plan</code></a>, a datatype we can <a href="debugging.html#pretty-printing-plans">inspect</a>, <a href="debugging.html#testing-plans">test</a> or <a href="distage-framework.html#compile-time-checks">verify at compile-time</a> â€“ without having to actually create objects or execute effects.</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Activation, Injector, Roots}

val injector = Injector[Task]()
// injector: Injector[Task] = izumi.distage.InjectorDefaultImpl@689a545b

val plan = injector.plan(HelloByeModule, Activation.empty, Roots.target[HelloByeApp]).getOrThrow()
// plan: izumi.distage.model.plan.Plan = 1: {type.MdocSession::MdocApp1::Greeter} (basics.md:84) := call(Ï€:Class(): MdocSession::MdocApp1::PrintGreeter[32m) {}
// 2: {type.MdocSession::MdocApp1::Byer} (basics.md:85) := call(Ï€:Class(): MdocSession::MdocApp1::PrintByer[32m) {}
// 3: {type.MdocSession::MdocApp1::HelloByeApp} (basics.md:86) :=
// 4:     call(Ï€:Class(MdocSession::MdocApp1::Greeter, MdocSession::MdocApp1::Byer): MdocSession::MdocApp1::HelloByeApp[32m) {
// 5:       arg greeter: MdocSession::MdocApp1::Greeter &lt;- {type.MdocSession::MdocApp1::Greeter}
// 6:       arg byer: MdocSession::MdocApp1::Byer &lt;- {type.MdocSession::MdocApp1::Byer}
// 7:     }
</code></pre>
<p>The series of steps must be executed to produce the object graph.</p>
<p><code>Injector.produce</code> will interpret the steps into a <a href="basics.html#resource-bindings-lifecycle"><code>Lifecycle</code></a> value holding the lifecycle of the object graph:</p>
<pre class="prettyprint"><code class="language-scala">import izumi.functional.bio.UnsafeRun2

// Interpret into a Lifecycle value

val resource = injector.produce(plan)
// resource: izumi.distage.model.definition.package.Lifecycle[Task, izumi.distage.model.Locator] = izumi.functional.lifecycle.LifecycleMethodImpls$$anon$2@2fee02fc

// Use the object graph:
// After `.use` exits, all objects will be deallocated,
// and all allocated resources will be freed.

val effect = resource.use {
  objects =&gt;
    objects.get[HelloByeApp].run
}
// effect: Task[Unit] = DynamicNoBox(izumi.functional.quasi.QuasiPrimitivesFromBIO.bracket(QuasiIO.scala:339),1,zio.ZIO$$$Lambda$22352/0x00007fea4a41bda0@276df2e9)

// Run the resulting program

val runner = UnsafeRun2.createZIO()
// runner: UnsafeRun2.ZIORunner[Any] = izumi.functional.bio.UnsafeRun2$ZIORunner@218054d

runner.unsafeRun(effect)
// What&#39;s your name?
// &gt; izumi
// Hello izumi!
// Bye izumi!
</code></pre>
<h3><a href="#singleton-components" name="singleton-components" class="anchor"><span class="anchor-link"></span></a>Singleton components</h3>
<p><code>distage</code> creates components at most once, even if multiple other objects depend on them.</p>
<p>A given component <code>X</code> will be the <em>same</em> <code>X</code> everywhere in the object graph, i.e. a singleton.</p>
<p>It&rsquo;s impossible to create non-singletons in <code>distage</code>.</p>
<h3><a href="#named-components" name="named-components" class="anchor"><span class="anchor-link"></span></a>Named components</h3>
<p>If you need multiple singleton instances of the same type, you may create &ldquo;named&rdquo; instances and disambiguate between them using <a href="/latest/snapshot/api/izumi/distage/model/definition/Id.html" title="izumi.distage.model.definition.Id"><code>`@distage.Id`</code></a> annotation. (<code>javax.inject.Named</code> is also supported)</p>
<pre class="prettyprint"><code class="language-scala">import distage.Id

def negateByer(otherByer: Byer): Byer = {
  new Byer {
    def bye(name: String) =
     otherByer.bye(s&quot;NOT-$name&quot;)
  }
}

new ModuleDef {
  make[Byer].named(&quot;byer-1&quot;).from[PrintByer]
  make[Byer].named(&quot;byer-2&quot;).from {
    (otherByer: Byer @Id(&quot;byer-1&quot;)) =&gt;
      negateByer(otherByer)
  }
}
</code></pre>
<p>You can use <code>make[_].annotateParameter</code> method instead of an annotation, to attach a name component to an existing constructor:</p>
<pre class="prettyprint"><code class="language-scala">new ModuleDef {
  // same binding as above
  make[Byer].named(&quot;byer-2&quot;)
    .from(negateByer(_))
    .annotateParameter[Byer](&quot;byer-1&quot;)
}
</code></pre>
<p>You can also abstract over annotations using type aliases and/or string constants (<code>final val</code>):</p>
<pre class="prettyprint"><code class="language-scala">object Ids {
  final val byer1Id = &quot;byer-1&quot;
  type Byer1 = Byer @Id(byer1Id)
}
</code></pre>
<h3><a href="#non-singleton-components" name="non-singleton-components" class="anchor"><span class="anchor-link"></span></a>Non-singleton components</h3>
<p>You cannot embed non-singletons into the object graph, but you may create them as normal using factories. <code>distage</code>&rsquo;s <a href="basics.html#auto-factories">Auto-Factories</a> can generate implementations for your factories, removing the associated boilerplate.</p>
<p>While Auto-Factories may remove the boilerplate of generating factories for singular components, if you need to create a new non-trivial subgraph dynamically, you&rsquo;ll need to run <code>Injector</code> again. <a href="basics.html#subcontexts">Subcontexts</a> feature automates running nested Injectors and makes it easier to define nested object graphs. You may also manually use <code>Injector.inherit</code> to reuse components from the outer object graph in your new nested object graph, see <a href="advanced-features.html#injector-inheritance">Injector Inheritance</a>.</p>
<h2><a href="#real-world-example" name="real-world-example" class="anchor"><span class="anchor-link"></span></a>Real-world example</h2>
<p>Check out <a href="https://github.com/7mind/distage-example"><code>distage-example</code></a> sample project for a complete example built using <code>distage</code>, <a href="../bio/index.html">bifunctor tagless final</a>, <code>http4s</code>, <code>doobie</code> and <code>zio</code> libraries.</p>
<p>It shows how to write an idiomatic <code>distage</code>-style from scratch and how to:</p>
<ul>
  <li>write tests using <a href="distage-testkit.html"><code>distage-testkit</code></a></li>
  <li>setup portable test environments using <a href="distage-framework-docker.html"><code>distage-framework-docker</code></a></li>
  <li>create <a href="distage-framework.html#roles">role-based applications</a></li>
  <li>enable <a href="distage-framework.html#compile-time-checks">compile-time checks</a> for fast feedback on wiring errors</li>
</ul>
<h2><a href="#activation-axis" name="activation-axis" class="anchor"><span class="anchor-link"></span></a>Activation Axis</h2>
<p>You can choose between different implementations of a component using &ldquo;Activation axis&rdquo;:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Axis, Activation, ModuleDef, Injector}
import zio.Console

class AllCapsGreeter extends Greeter {
  def hello(name: String) =
    Console.printLine(s&quot;HELLO ${name.toUpperCase}&quot;)
}

// declare a configuration axis for our components

object Style extends Axis {
  case object AllCaps extends AxisChoiceDef
  case object Normal extends AxisChoiceDef
}

// Declare a module with several implementations of Greeter
// but in different environments

def TwoImplsModule = new ModuleDef {
  make[Greeter].tagged(Style.Normal)
    .from[PrintGreeter]

  make[Greeter].tagged(Style.AllCaps)
    .from[AllCapsGreeter]
}

// Combine previous `HelloByeModule` with our new module
// While overriding `make[Greeter]` bindings from the first module

def CombinedModule = HelloByeModule overriddenBy TwoImplsModule

// Choose component configuration when making an Injector:

runner.unsafeRun {
  Injector()
    .produceGet[HelloByeApp](CombinedModule, Activation(Style -&gt; Style.AllCaps))
    .use(_.run)
}
// What&#39;s your name?
// &gt; kai
// HELLO KAI
// Bye kai!

// Check that result changes with a different configuration:

runner.unsafeRun {
  Injector()
    .produceGet[HelloByeApp](CombinedModule, Activation(Style -&gt; Style.Normal))
    .use(_.run)
}
// What&#39;s your name?
// &gt; Pavel
// Hello Pavel!
// Bye Pavel!
</code></pre>
<p><a href="/latest/snapshot/api/izumi/distage/model/definition/StandardAxis$.html" title="izumi.distage.model.definition.StandardAxis"><code>distage.StandardAxis</code></a> contains bundled Axes for back-end development:</p>
<ul>
  <li>
  <p><a href="/latest/snapshot/api/izumi/distage/model/definition/StandardAxis$$Repo$.html" title="izumi.distage.model.definition.StandardAxis$$Repo"><code>Repo</code></a> axis, with <code>Prod</code>/<code>Dummy</code> choices, describes any entities which may store and persist state or &ldquo;repositories&rdquo;. e.g. databases, message queues, KV storages, file systems, etc. Those may typically have both in-memory <code>Dummy</code> implementations and heavyweight <code>Prod</code> implementations using external databases.</p></li>
  <li>
  <p><a href="/latest/snapshot/api/izumi/distage/model/definition/StandardAxis$$Mode$.html" title="izumi.distage.model.definition.StandardAxis$$Mode"><code>Mode</code></a> axis, with <code>Prod</code>/<code>Test</code> choices, describes a generic choice between production and test implementations of a component.</p></li>
  <li>
  <p><a href="/latest/snapshot/api/izumi/distage/model/definition/StandardAxis$$World$.html" title="izumi.distage.model.definition.StandardAxis$$World"><code>World</code></a> axis, with <code>Real</code>/<code>Mock</code> choices, describes third-party integrations which are not controlled by the application and provided &ldquo;as is&rdquo;. e.g. Facebook API, Google API, etc. those may contact a <code>Real</code> external integration or a <code>Mock</code> one with predefined responses.</p></li>
  <li>
  <p><a href="/latest/snapshot/api/izumi/distage/model/definition/StandardAxis$$Scene$.html" title="izumi.distage.model.definition.StandardAxis$$Scene"><code>Scene</code></a> axis with <code>Managed</code>/<code>Provided</code> choices, describes whether external services required by the application should be set-up on the fly by an orchestrator library such as <a href="distage-framework-docker.html"><code>distage-framework-docker</code></a> (<code>Scene.Managed</code>), or whether the application should try to connect to external services as if they already exist in the environment (<code>Scene.Provided</code>).  We call a set of external services required by the application a <code>Scene</code>, etymology being that the running external services required by the application are like a &ldquo;scene&rdquo; that the &ldquo;staff&rdquo; (the orchestrator) must prepare for the &ldquo;actor&rdquo; (the application) to enter.</p></li>
</ul>
<p>In <code>distage-framework</code>&rsquo;s <a href="/latest/snapshot/api/izumi/distage/roles/RoleAppMain.html" title="izumi.distage.roles.RoleAppMain"><code>RoleAppMain</code></a>, you can choose axes using the <code>-u</code> command-line parameter:</p>
<pre><code>./launcher -u repo:dummy -u env:prod app1
</code></pre>
<p>In <code>distage-testkit</code>, choose axes using <a href="/latest/snapshot/api/izumi/distage/testkit/TestConfig.html" title="izumi.distage.testkit.TestConfig"><code>TestConfig</code></a>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.StandardAxis.Repo
import izumi.distage.testkit.TestConfig
import izumi.distage.testkit.scalatest.Spec2

class AxisTest extends Spec2[zio.IO] {

  // choose implementations `.tagged` as `Repo.Dummy` over those tagged `Repo.Prod`
  override def config: TestConfig = super.config.copy(
    activation = Activation(Repo -&gt; Repo.Dummy)
  )

}
</code></pre>
<h3><a href="#multi-dimensionality" name="multi-dimensionality" class="anchor"><span class="anchor-link"></span></a>Multi-dimensionality</h3>
<p>There may be many configuration axes in an application and components can specify multiple axis choices at once:</p>
<pre class="prettyprint"><code class="language-scala">import distage.StandardAxis.Mode
import zio.Console

class TestPrintGreeter extends Greeter {
  def hello(name: String) =
    Console.printLine(s&quot;Test 1 2, hello $name&quot;)
}

// declare 3 possible implementations

def TestModule = new ModuleDef {
  make[Greeter].tagged(Style.Normal, Mode.Prod).from[PrintGreeter]
  make[Greeter].tagged(Style.Normal, Mode.Test).from[TestPrintGreeter]
  make[Greeter].tagged(Style.AllCaps).from[AllCapsGreeter]
}

def runWith(activation: Activation) = {
  runner.unsafeRun {
    Injector().produceRun(TestModule, activation) {
      (greeter: Greeter) =&gt; greeter.hello(&quot;$USERNAME&quot;)
    }
  }
}

// Production Normal Greeter

runWith(Activation(Style -&gt; Style.Normal, Mode -&gt; Mode.Prod))
// Hello $USERNAME!

// Test Normal Greeter

runWith(Activation(Style -&gt; Style.Normal, Mode -&gt; Mode.Test))
// Test 1 2, hello $USERNAME

// Both Production and Test Caps Greeters are the same:

runWith(Activation(Style -&gt; Style.AllCaps, Mode -&gt; Mode.Prod))
// HELLO $USERNAME

runWith(Activation(Style -&gt; Style.AllCaps, Mode -&gt; Mode.Test))
// HELLO $USERNAME
</code></pre>
<h4><a href="#specificity-and-defaults" name="specificity-and-defaults" class="anchor"><span class="anchor-link"></span></a>Specificity and defaults</h4>
<p>When multiple dimensions are attached to a binding, bindings with less specified dimensions will be considered less specific and will be overridden by bindings with more dimensions, if all of those dimensions are explicitly set.</p>
<p>A binding with no attached dimensions is considered a &ldquo;default&rdquo; vs. a binding with attached dimensions. A default will be chosen only if all other bindings are explicitly contradicted by passed activations. If the dimensions for other bindings are merely unset, it will cause an ambiguity error.</p>
<p>Example of these rules:</p>
<pre class="prettyprint"><code class="language-scala">import scala.util.Try

sealed trait Color
case object RED extends Color
case object Blue extends Color
case object Green extends Color

// Defaults:

def DefaultsModule = new ModuleDef {
  make[Color].from(Green)
  make[Color].tagged(Style.AllCaps).from(RED)
}

Injector().produceRun(DefaultsModule, Activation(Style -&gt; Style.AllCaps))(println(_: Color))
// RED
// res11: distage.package.Identity[Unit] = ()

Injector().produceRun(DefaultsModule, Activation(Style -&gt; Style.Normal))(println(_: Color))
// Green
// res12: distage.package.Identity[Unit] = ()

// ERROR Ambiguous without Style
Try { Injector().produceRun(DefaultsModule, Activation.empty)(println(_: Color)) }.isFailure
// res13: Boolean = true

// Specificity

def SpecificityModule = new ModuleDef {
  make[Color].tagged(Mode.Test).from(Blue)
  make[Color].tagged(Mode.Prod).from(Green)
  make[Color].tagged(Mode.Prod, Style.AllCaps).from(RED)
}

Injector().produceRun(SpecificityModule, Activation(Mode -&gt; Mode.Prod, Style -&gt; Style.AllCaps))(println(_: Color))
// RED
// res14: distage.package.Identity[Unit] = ()

Injector().produceRun(SpecificityModule, Activation(Mode -&gt; Mode.Test, Style -&gt; Style.AllCaps))(println(_: Color))
// Blue
// res15: distage.package.Identity[Unit] = ()

Injector().produceRun(SpecificityModule, Activation(Mode -&gt; Mode.Prod, Style -&gt; Style.Normal))(println(_: Color))
// Green
// res16: distage.package.Identity[Unit] = ()

Injector().produceRun(SpecificityModule, Activation(Mode -&gt; Mode.Test))(println(_: Color))
// Blue
// res17: distage.package.Identity[Unit] = ()

// ERROR Ambiguous without Mode
Try { Injector().produceRun(SpecificityModule, Activation(Style -&gt; Style.Normal))(println(_: Color)) }.isFailure
// res18: Boolean = true
</code></pre>
<h2><a href="#resource-bindings-lifecycle" name="resource-bindings-lifecycle" class="anchor"><span class="anchor-link"></span></a>Resource Bindings, Lifecycle</h2>
<p>You can specify object lifecycle by injecting <a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle.html" title="izumi.functional.lifecycle.Lifecycle"><code>distage.Lifecycle</code></a>, <a href="https://typelevel.org/cats-effect/docs/std/resource">cats.effect.Resource</a>, <a href="https://zio.dev/guides/migrate/zio-2.x-migration-guide#scopes-1">scoped zio.ZIO</a>, <a href="https://zio.dev/reference/contextual/zlayer">zio.ZLayer</a> or <a href="https://zio.dev/1.0.18/reference/resource/zmanaged/">zio.managed.ZManaged</a> values specifying the allocation and finalization actions of an object.</p>
<p>When ran, distage <code>Injector</code> itself returns a <code>Lifecycle</code> value that describes actions to create and finalize the object graph; the <code>Lifecycle</code> value is pure and can be reused multiple times.</p>
<p>A <code>Lifecycle</code> is executed using its <code>.use</code> method, the function passed to <code>use</code> will receive an allocated resource and when the function exits the resource will be deallocated. <code>Lifecycle</code> is generally not invalidated after <code>.use</code> and may be executed multiple times.</p>
<p>Example with <code>cats.effect.Resource</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Roots, ModuleDef, Injector}
import cats.effect.{Resource, IO}

class DBConnection
class MessageQueueConnection

val dbResource = Resource.make(
  acquire = IO {
    println(&quot;Connecting to DB!&quot;)
    new DBConnection
})(release = _ =&gt; IO(println(&quot;Disconnecting DB&quot;)))
// dbResource: Resource[IO, DBConnection] = Allocate(cats.effect.kernel.Resource$$$Lambda$22642/0x00007fea4b5de5f0@389ab1d9)

val mqResource = Resource.make(
  acquire = IO {
   println(&quot;Connecting to Message Queue!&quot;)
   new MessageQueueConnection
})(release = _ =&gt; IO(println(&quot;Disconnecting Message Queue&quot;)))
// mqResource: Resource[IO, MessageQueueConnection] = Allocate(cats.effect.kernel.Resource$$$Lambda$22642/0x00007fea4b5de5f0@67bcbdd4)

class MyApp(
  db: DBConnection,
  mq: MessageQueueConnection,
) {
  val run = {
    IO(println(&quot;Hello World!&quot;))
  }
}

def module = new ModuleDef {
  make[DBConnection].fromResource(dbResource)
  make[MessageQueueConnection].fromResource(mqResource)
  make[MyApp]
}
</code></pre>
<p>Will produce the following output:</p>
<pre class="prettyprint"><code class="language-scala">import cats.effect.unsafe.implicits.global

val objectGraphResource = {
  Injector[IO]()
    .produce(module, Roots.target[MyApp])
}
// objectGraphResource: izumi.distage.model.definition.package.Lifecycle[IO, izumi.distage.model.Locator] = izumi.functional.lifecycle.LifecycleMethodImpls$$anon$2@2f0ef170

objectGraphResource
  .use(_.get[MyApp].run)
  .unsafeRunSync()
// Connecting to DB!
// Connecting to Message Queue!
// Hello World!
// Disconnecting Message Queue
// Disconnecting DB
</code></pre>
<p>Lifecycle management with <code>Lifecycle</code> is also available without an effect type, via <code>Lifecycle.Simple</code> and <code>Lifecycle.Mutable</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Lifecycle, ModuleDef, Injector}

class Init {
  var initialized = false
}

class InitResource extends Lifecycle.Simple[Init] {
  override def acquire = {
    val init = new Init
    init.initialized = true
    init
  }
  override def release(init: Init) = {
    init.initialized = false
  }
}

def module = new ModuleDef {
  make[Init].fromResource[InitResource]
}

val closedInit = Injector()
  .produceGet[Init](module)
  .use {
    init =&gt;
      println(init.initialized)
      init
}
// true
// closedInit: distage.package.Identity[Init] = repl.MdocSession$MdocApp21$Init@6dfeabb1

println(closedInit.initialized)
// false
</code></pre>
<p><code>Lifecycle</code> forms a monad and has the expected <code>.map</code>, <code>.flatMap</code>, <code>.evalMap</code>, <code>.mapK</code> methods.</p>
<p>You can convert between a <code>Lifecycle</code> and <code>cats.effect.Resource</code> via <code>Lifecycle#toCats</code>/<code>Lifecycle.fromCats</code> methods, and between a <code>Lifecycle</code> and scoped <code>zio.ZIO</code>/<code>zio.managed.ZManaged</code>/<code>zio.ZLayer</code> via <code>Lifecycle#toZIO</code>/<code>Lifecycle.fromZIO</code> methods.</p>
<h3><a href="#inheritance-helpers" name="inheritance-helpers" class="anchor"><span class="anchor-link"></span></a>Inheritance helpers</h3>
<p>The following helpers allow defining <code>Lifecycle</code> subclasses using expression-like syntax:</p>
<ul>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$Of.html" title="izumi.functional.lifecycle.Lifecycle.Of"><code>Lifecycle.Of</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$OfInner.html" title="izumi.functional.lifecycle.Lifecycle.OfInner"><code>Lifecycle.OfInner</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$OfCats.html" title="izumi.functional.lifecycle.Lifecycle.OfCats"><code>Lifecycle.OfCats</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$OfZIO.html" title="izumi.functional.lifecycle.Lifecycle.OfZIO"><code>Lifecycle.OfZIO</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$OfZManaged.html" title="izumi.functional.lifecycle.Lifecycle.OfZManaged"><code>Lifecycle.OfZManaged</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$OfZLayer.html" title="izumi.functional.lifecycle.Lifecycle.OfZLayer"><code>Lifecycle.OfZLayer</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$LiftF.html" title="izumi.functional.lifecycle.Lifecycle.LiftF"><code>Lifecycle.LiftF</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$Make.html" title="izumi.functional.lifecycle.Lifecycle.Make"><code>Lifecycle.Make</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$Make_.html" title="izumi.functional.lifecycle.Lifecycle.Make_"><code>Lifecycle.Make_</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$MakePair.html" title="izumi.functional.lifecycle.Lifecycle.MakePair"><code>Lifecycle.MakePair</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$FromAutoCloseable.html" title="izumi.functional.lifecycle.Lifecycle.FromAutoCloseable"><code>Lifecycle.FromAutoCloseable</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$SelfOf.html" title="izumi.functional.lifecycle.Lifecycle.SelfOf"><code>Lifecycle.SelfOf</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$MutableOf.html" title="izumi.functional.lifecycle.Lifecycle.MutableOf"><code>Lifecycle.MutableOf</code></a></li>
</ul>
<p>The main reason to employ them is to work around a limitation in Scala 2&rsquo;s eta-expansion â€” when converting a method to a function value, Scala always tries to fulfill implicit parameters eagerly instead of making them parameters of the function value, this limitation makes it harder to inject implicits using <code>distage</code>.</p>
<p>However, when using <code>distage</code>&rsquo;s type-based syntax: <code>make[A].fromResource[A.Resource[F]]</code> â€” this limitation does not apply and implicits inject successfully.</p>
<p>So to work around this limitation you can convert an expression based resource constructor:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Lifecycle, ModuleDef}
import cats.Monad

class A(val n: Int)

object A {

  def resource[F[_]: Monad]: Lifecycle[F, A] =
    Lifecycle.pure[F](new A(1))

}

def module = new ModuleDef {
  // Bad: summons Monad[cats.effect.IO] immediately, instead of getting it from the object graph
  make[A].fromResource(A.resource[cats.effect.IO])
}
</code></pre>
<p>Into a class-based form:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Lifecycle, ModuleDef}
import cats.Monad

class A(val n: Int)

object A {

  final class Resource[F[_]: Monad]
    extends Lifecycle.Of[F, A](
      Lifecycle.pure[F](new A(1))
    )

}

def module = new ModuleDef {
  // Good: implicit Monad[cats.effect.IO] parameter is wired from the object graph, same as the non-implicit parameters
  make[A].fromResource[A.Resource[cats.effect.IO]]
  addImplicit[Monad[cats.effect.IO]]
}
</code></pre>
<p>And inject successfully using <code>make[A].fromResource[A.Resource[F]]</code> syntax of <a href="/latest/snapshot/api/izumi/distage/model/definition/dsl/ModuleDefDSL.html" title="izumi.distage.model.definition.dsl.ModuleDefDSL"><code>ModuleDefDSL</code></a>.</p>
<p>The following helpers ease defining <code>Lifecycle</code> subclasses using traditional inheritance where <code>acquire</code>/<code>release</code> parts are defined as methods:</p>
<ul>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$Basic.html" title="izumi.functional.lifecycle.Lifecycle.Basic"><code>Lifecycle.Basic</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$Simple.html" title="izumi.functional.lifecycle.Lifecycle.Simple"><code>Lifecycle.Simple</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$Mutable.html" title="izumi.functional.lifecycle.Lifecycle.Mutable"><code>Lifecycle.Mutable</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$MutableNoClose.html" title="izumi.functional.lifecycle.Lifecycle.MutableNoClose"><code>Lifecycle.MutableNoClose</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$Self.html" title="izumi.functional.lifecycle.Lifecycle.Self"><code>Lifecycle.Self</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$SelfNoClose.html" title="izumi.functional.lifecycle.Lifecycle.SelfNoClose"><code>Lifecycle.SelfNoClose</code></a></li>
  <li><a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$NoClose.html" title="izumi.functional.lifecycle.Lifecycle.NoClose"><code>Lifecycle.NoClose</code></a></li>
</ul>
<h2><a href="#out-of-the-box-typeclass-instances" name="out-of-the-box-typeclass-instances" class="anchor"><span class="anchor-link"></span></a>Out-of-the-box typeclass instances</h2>
<p>Typeclass instances for popular typeclass hierarchies are included by default for the effect type in which <code>distage</code> is running.</p>
<p>Whenever your effect type implements <a href="../bio/index.html">BIO</a> or <a href="https://typelevel.org/cats-effect/">cats-effect</a> typeclasses, their instances will be summonable without adding them into modules. This applies for <code>ZIO</code>, <code>cats.effect.IO</code>, <code>monix</code>, <code>monix-bio</code> and any other effect type with relevant typeclass instances in implicit scope.</p>
<ul>
  <li>For <code>ZIO</code>, <code>monix-bio</code> and any other implementors of <a href="../bio/index.html">BIO</a> typeclasses, <code>BIO</code> hierarchy instances will be included.</li>
  <li>For <code>ZIO</code>, <code>cats-effect</code> instances will be included only if ZIO <a href="https://github.com/zio/interop-cats/"><code>interop-cats</code></a> library is on the classpath.</li>
</ul>
<p>Example usage:</p>
<pre class="prettyprint"><code class="language-scala">import cats.effect.{IO, Sync}
import distage.{Activation, DefaultModule, Injector, Module, TagK}
import izumi.functional.quasi.QuasiIO

def polymorphicHelloWorld[F[_]: TagK: QuasiIO: DefaultModule]: F[Unit] = {
  Injector[F]().produceRun(
    Module.empty, // we do not define _any_ components
    Activation.empty,
  ) {
      (F: Sync[F]) =&gt; // cats.effect.Sync[F] is available anyway
        F.delay(println(&quot;Hello world!&quot;))
  }
}

val catsEffectHello = polymorphicHelloWorld[cats.effect.IO]
// catsEffectHello: IO[Unit] = IO(...)

//val monixHello = polymorphicHelloWorld[monix.eval.Task]

val zioHello = polymorphicHelloWorld[zio.IO[Throwable, _]]
// zioHello: zio.ZIO[Any, Throwable, Unit] = DynamicNoBox(izumi.functional.quasi.QuasiPrimitivesFromBIO.bracket(QuasiIO.scala:339),1,zio.ZIO$$$Lambda$22352/0x00007fea4a41bda0@87dbae)

//val monixBioHello = polymorphicHelloWorld[monix.bio.IO[Throwable, _]]
</code></pre>
<p>See <a href="/latest/snapshot/api/izumi/distage/modules/DefaultModule.html" title="izumi.distage.modules.DefaultModule"><code>`DefaultModule`</code></a> implicit for implementation details. For details on what exact components are available for each effect type, see <a href="/latest/snapshot/api/izumi/distage/modules/support/ZIOSupportModule.html" title="izumi.distage.modules.support.ZIOSupportModule"><code>ZIOSupportModule</code></a>, <a href="/latest/snapshot/api/izumi/distage/modules/support/CatsIOSupportModule.html" title="izumi.distage.modules.support.CatsIOSupportModule"><code>CatsIOSupportModule</code></a>, <a href="/latest/snapshot/api/izumi/distage/modules/support/MonixSupportModule.html" title="izumi.distage.modules.support.MonixSupportModule"><code>MonixSupportModule</code></a>, <a href="/latest/snapshot/api/izumi/distage/modules/support/MonixBIOSupportModule.html" title="izumi.distage.modules.support.MonixBIOSupportModule"><code>MonixBIOSupportModule</code></a>, <a href="/latest/snapshot/api/izumi/distage/modules/typeclass/ZIOCatsEffectInstancesModule.html" title="izumi.distage.modules.typeclass.ZIOCatsEffectInstancesModule"><code>ZIOCatsEffectInstancesModule</code></a>, respectively.</p>
<p>DefaultModule occurs as an implicit parameter in <code>distage</code> entrypoints that require an effect type parameter, namely: <code>Injector[F]()</code> in <code>distage-core</code>, <a href="distage-framework.html#roles"><code>extends RoleAppMain[F]</code></a> and <a href="distage-framework.html#compile-time-checks"><code>extends PlanCheck.Main[F]</code></a> in <code>distage-framework</code> and <a href="distage-testkit.html"><code>extends Spec1[F]</code></a> in <code>distage-testkit</code>.</p>
<h2><a href="#set-bindings" name="set-bindings" class="anchor"><span class="anchor-link"></span></a>Set Bindings</h2>
<p>Set bindings are useful for implementing listeners, plugins, hooks, http routes, healthchecks, migrations, etc. Everywhere where a collection of components is required, a Set Binding is appropriate.</p>
<p>To define a Set binding use <code>.many</code> and <code>.add</code> methods of the <a href="/latest/snapshot/api/izumi/distage/model/definition/ModuleDef.html" title="izumi.distage.model.definition.ModuleDef"><code>ModuleDef</code></a> DSL.</p>
<p>As an example, we may declare multiple command handlers and use them to interpret user input in a REPL</p>
<pre class="prettyprint"><code class="language-scala">import distage.ModuleDef

final case class CommandHandler(
  handle: PartialFunction[String, String]
)

val additionHandler = CommandHandler {
  case s&quot;$x + $y&quot; =&gt; s&quot;${x.toInt + y.toInt}&quot;
}
// additionHandler: CommandHandler = CommandHandler(&lt;function1&gt;)

object AdditionModule extends ModuleDef {
  many[CommandHandler]
    .add(additionHandler)
}
</code></pre>
<p>We&rsquo;ve used <code>many</code> method to declare an open <code>Set</code> of command handlers and then added one handler to it.</p>
<p>When module definitions are combined, elements for the same type of <code>Set</code> will be merged together into a larger set.</p>
<p>You can summon a Set binding by summoning a scala <code>Set</code>, as in <code>Set[CommandHandler]</code>.</p>
<p>Let&rsquo;s define a new module with another handler:</p>
<pre class="prettyprint"><code class="language-scala">val subtractionHandler = CommandHandler {
  case s&quot;$x - $y&quot; =&gt; s&quot;${x.toInt - y.toInt}&quot;
}
// subtractionHandler: CommandHandler = CommandHandler(&lt;function1&gt;)

object SubtractionModule extends ModuleDef {
  many[CommandHandler]
    .add(subtractionHandler)
}
</code></pre>
<p>Let&rsquo;s create a command-line application using our command handlers:</p>
<pre class="prettyprint"><code class="language-scala">import distage.Injector

trait App {
  def interpret(input: String): String
}
object App {
  final class Impl(
    handlers: Set[CommandHandler]
  ) extends App {
    override def interpret(input: String): String = {
      handlers.map(_.handle).reduce(_ orElse _).lift(input) match {
        case Some(answer) =&gt; s&quot;ANSWER: $answer&quot;
        case None         =&gt; &quot;?&quot;
      }
    }
  }
}

object AppModule extends ModuleDef {
  // include all the previous module definitions
  include(AdditionModule)
  include(SubtractionModule)

  // add a help handler
  many[CommandHandler].add(CommandHandler {
    case &quot;help&quot; =&gt; &quot;Please input an arithmetic expression!&quot;
  })

  // bind App
  make[App].from[App.Impl]
}

// wire the graph and get the app

val app = Injector().produceGet[App](AppModule).unsafeGet()
// app: App = repl.MdocSession$MdocApp26$App$Impl@7e3b13d3

// check how it works

app.interpret(&quot;1 + 5&quot;)
// res27: String = &quot;ANSWER: 6&quot;

app.interpret(&quot;7 - 11&quot;)
// res28: String = &quot;ANSWER: -4&quot;

app.interpret(&quot;1 / 3&quot;)
// res29: String = &quot;?&quot;

app.interpret(&quot;help&quot;)
// res30: String = &quot;ANSWER: Please input an arithmetic expression!&quot;
</code></pre>
<p>If we rewire the app without <code>SubtractionModule</code>, it will expectedly lose the ability to subtract:</p>
<pre class="prettyprint"><code class="language-scala">Injector().produceRun(AppModule -- SubtractionModule.keys) {
  (app: App) =&gt;
    app.interpret(&quot;10 - 1&quot;)
}
// res31: String = &quot;?&quot;
</code></pre>
<p>Further reading:</p>
<ul>
  <li>Guice calls the same concept <a href="https://github.com/google/guice/wiki/Multibindings">&ldquo;Multibindings&rdquo;</a>.</li>
</ul>
<h2><a href="#mutator-bindings" name="mutator-bindings" class="anchor"><span class="anchor-link"></span></a>Mutator Bindings</h2>
<p>Mutations can be attached to any component using <code>modify[X]</code> keyword.</p>
<p>If present, they will be applied in an undefined order after the component has been created, but <em>before</em> it is visible to any other component.</p>
<p>Mutators provide a way to do partial overrides or slight modifications of some existing component without redefining it fully.</p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Id, Injector, ModuleDef}

def startingModule = new ModuleDef {
  make[Int].fromValue(1) // 1
}

def increment2 = new ModuleDef {
  modify[Int](_ + 1) // 2
  modify[Int](_ + 1) // 3
}

def incrementWithDep = new ModuleDef {
  make[String].fromValue(&quot;hello&quot;)
  make[Int].named(&quot;a-few&quot;).fromValue(2)

  // mutators may use other components and add additional dependencies
  modify[Int].by(_.flatAp {
    (s: String, few: Int @Id(&quot;a-few&quot;)) =&gt; (currentInt: Int) =&gt;
      s.length + few + currentInt
  }) // 5 + 2 + 3
}

Injector().produceRun(
  startingModule ++
  increment2 ++
  incrementWithDep
)((currentInt: Int) =&gt; currentInt): Int
// res33: Int = 10
</code></pre>
<p>Another example: Suppose you&rsquo;re using a config case class in your <a href="distage-testkit.html"><code>distage-testkit</code></a> tests, and for one of the test you want to use a modified value for one of the fields in it. Before 1.0 you&rsquo;d have to duplicate the config binding into a new key and apply the modifying function to it:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Id, ModuleDef}
import distage.config.ConfigModuleDef
import izumi.distage.testkit.TestConfig
import izumi.distage.testkit.scalatest.SpecIdentity

class MyTest extends SpecIdentity {
  override def config: TestConfig = super.config.copy(
    moduleOverrides = new ConfigModuleDef {
      makeConfig[Config](&quot;config.myconfig&quot;).named(&quot;duplicate&quot;)
      make[Config].from {
        (thatConfig: Config @Id(&quot;duplicate&quot;)) =&gt;
          modifyingFunction(thatConfig)
      }
    }
  )
}
</code></pre>
<p>Now instead of overriding the entire binding, we may use a mutator:</p>
<pre class="prettyprint"><code class="language-scala">class MyTest extends SpecIdentity {
  override def config: TestConfig = super.config.copy(
    moduleOverrides = new ModuleDef {
      modify[Config](modifyingFunction(_))
    }
  )
}
</code></pre>
<p>Mutators are subject to configuration using <a href="basics.html#activation-axis">Activation Axis</a> and will be applied conditionally, if tagged:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Activation, Injector, Mode}

def axisIncrement = new ModuleDef {
  make[Int].fromValue(1)
  modify[Int](_ + 10).tagged(Mode.Test)
  modify[Int](_ + 1).tagged(Mode.Prod)
}

Injector().produceRun(axisIncrement, Activation(Mode -&gt; Mode.Test))((currentInt: Int) =&gt; currentInt): Int
// res35: Int = 11

Injector().produceRun(axisIncrement, Activation(Mode -&gt; Mode.Prod))((currentInt: Int) =&gt; currentInt): Int
// res36: Int = 2
</code></pre>
<h2><a href="#effect-bindings" name="effect-bindings" class="anchor"><span class="anchor-link"></span></a>Effect Bindings</h2>
<p>Sometimes we want to effectfully create a component, but the resulting component or data does not need to be deallocated. An example might be a global <code>Semaphore</code> to limit the parallelism of the entire application based on configuration, or a test implementation of some service made with <code>Ref</code>s.</p>
<p>In these cases we can use <code>.fromEffect</code> to create a value using an effectful constructor.</p>
<p>Example with a <code>Ref</code>-based Tagless Final <code>KVStore</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Injector, ModuleDef}
import izumi.functional.bio.{Error2, Primitives2, F}
import zio.{Task, IO}

trait KVStore[F[_, _]] {
  def get(key: String): F[NoSuchElementException, String]
  def put(key: String, value: String): F[Nothing, Unit]
}

def dummyKVStore[F[+_, +_]: Error2: Primitives2]: F[Nothing, KVStore[F]] = {
  for {
    ref &lt;- F.mkRef(Map.empty[String, String])
  } yield new KVStore[F] {
    def put(key: String, value: String): F[Nothing, Unit] = {
      ref.update_(_ + (key -&gt; value))
    }

    def get(key: String): F[NoSuchElementException, String] = {
      for {
        map &lt;- ref.get
        res &lt;- map.get(key) match {
          case Some(value) =&gt; F.pure(value)
          case None        =&gt; F.fail(new NoSuchElementException(key))
        }
      } yield res
    }
  }
}

def kvStoreModule = new ModuleDef {
  make[KVStore[IO]].fromEffect(dummyKVStore[IO])
}

val io = Injector[Task]()
  .produceRun[String](kvStoreModule) {
    (kv: KVStore[IO]) =&gt;
      for {
        _    &lt;- kv.put(&quot;apple&quot;, &quot;pie&quot;)
        res1 &lt;- kv.get(&quot;apple&quot;)
        _    &lt;- kv.put(&quot;apple&quot;, &quot;ipad&quot;)
        res2 &lt;- kv.get(&quot;apple&quot;)
      } yield res1 + res2
  }
// io: Task[String] = DynamicNoBox(izumi.functional.quasi.QuasiPrimitivesFromBIO.bracket(QuasiIO.scala:339),1,zio.ZIO$$$Lambda$22352/0x00007fea4a41bda0@2b846e3a)

import izumi.functional.bio.UnsafeRun2

val runtime = UnsafeRun2.createZIO()
// runtime: UnsafeRun2.ZIORunner[Any] = izumi.functional.bio.UnsafeRun2$ZIORunner@4aca8bc1

runtime.unsafeRun(io)
// res38: String = pieipad
</code></pre>
<p>You must specify your effect type when constructing an <code>Injector</code>, as in <code>Injector[F]()</code>, to use effect bindings in the chosen <code>F[_]</code> type.</p>
<p>You may want to use <a href="/latest/snapshot/api/izumi/functional/lifecycle/Lifecycle$$LiftF.html" title="izumi.functional.lifecycle.Lifecycle.LiftF"><code>Lifecycle.LiftF</code></a> to convert effect methods with implicit parameters into a class-based form to ensure that implicit parameters are wired from the object graph, not from the surrounding implicit scope. (See <a href="basics.html#inheritance-helpers">Inheritance Helpers</a>)</p>
<h2><a href="#zio-environment-bindings" name="zio-environment-bindings" class="anchor"><span class="anchor-link"></span></a>ZIO Environment bindings</h2>
<p>You can inject into ZIO Environment using <code>make[_].fromZEnv</code> syntax for <code>ZLayer</code>, <code>ZManaged</code>, <code>ZIO</code> or any <code>F[_, _, _]: Local3</code>:</p>
<pre class="prettyprint"><code class="language-scala">import zio._
import zio.managed._
import distage.ModuleDef

class Dependency

class X(dependency: Dependency)

def makeX: ZIO[Dependency, Throwable, X] = {
  for {
    dep &lt;- ZIO.service[Dependency]
    _   &lt;- Console.printLine(s&quot;Obtained environment dependency = $dep&quot;)
  } yield new X(dep)
}

def makeXManaged: ZManaged[Dependency, Throwable, X] = makeX.toManaged

def makeXLayer: ZLayer[Dependency, Throwable, X] = ZLayer.fromZIO(makeX)

def module1 = new ModuleDef {
  make[Dependency]

  make[X].fromZIOEnv(makeX)
  // or
  make[X].fromZManagedEnv(makeXManaged)
  // or
  make[X].fromZLayerEnv(makeXLayer)
}
</code></pre>
<p>You can also mix environment and parameter dependencies at the same time in one constructor:</p>
<pre class="prettyprint"><code class="language-scala">def zioArgEnvCtor(
  dependency: Dependency
): RLayer[Console, X] = {
  ZLayer.succeed(dependency) ++
  ZLayer.environment[Console] &gt;&gt;&gt;
  ZLayer.fromZIO(makeX)
}

def module2 = new ModuleDef {
  make[Dependency]

  make[X].fromZLayerEnv(zioArgEnvCtor _)
}
</code></pre>
<p><code>zio.ZEnvironment</code> values are derived at compile-time by <a href="/latest/snapshot/api/izumi/distage/constructors/ZEnvConstructor.html" title="izumi.distage.constructors.ZEnvConstructor"><code>ZEnvConstructor</code></a> macro and can be summoned at need.</p>
<p>Another example:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Injector, ModuleDef}
import zio.{Console, UIO, URIO, RIO, ZIO, Ref, Task}

trait Hello {
  def hello: UIO[String]
}
trait World {
  def world: UIO[String]
}

// Environment forwarders that allow
// using service functions from everywhere

val hello: URIO[Hello, String] = ZIO.serviceWithZIO(_.hello)
// hello: URIO[Hello, String] = OnSuccess(repl.MdocSession.MdocApp39.hello(basics.md:916),Sync(repl.MdocSession.MdocApp39.hello(basics.md:916),zio.ZIO$ServiceWithZIOPartiallyApplied$$$Lambda$22400/0x00007fea49ae7890@3dd0fabf),zio.ZIO$$$Lambda$22275/0x00007fea4b4b8dd0@3f81a452)

val world: URIO[World, String] = ZIO.serviceWithZIO(_.world)
// world: URIO[World, String] = OnSuccess(repl.MdocSession.MdocApp39.world(basics.md:919),Sync(repl.MdocSession.MdocApp39.world(basics.md:919),zio.ZIO$ServiceWithZIOPartiallyApplied$$$Lambda$22400/0x00007fea49ae7890@377ce826),zio.ZIO$$$Lambda$22275/0x00007fea4b4b8dd0@3f81a452)

// service implementations

val makeHello = {
  for {
    _     &lt;- ZIO.acquireRelease(
      acquire = Console.printLine(&quot;Creating Enterprise Hellower...&quot;)
    )(release = _ =&gt; Console.printLine(&quot;Shutting down Enterprise Hellower&quot;).orDie)
  } yield new Hello {
    val hello = ZIO.succeed(&quot;Hello&quot;)
  }
}
// makeHello: ZIO[Any with Any with zio.Scope, java.io.IOException, AnyRef with Hello{val hello: zio.ZIO[Any,Nothing,String]}] = OnSuccess(repl.MdocSession.MdocApp39.makeHello(basics.md:924),OnSuccess(repl.MdocSession.MdocApp39.makeHello(basics.md:926),Sync(repl.MdocSession.MdocApp39.makeHello(basics.md:926),zio.ZIO$$$Lambda$22833/0x00007fea4b63a098@29f6f98b),zio.ZIO$$$Lambda$22275/0x00007fea4b4b8dd0@3f81a452),zio.ZIO$$Lambda$22381/0x00007fea49fe0000@1349fb08)

val makeWorld = {
  for {
    counter &lt;- Ref.make(0)
  } yield new World {
    val world = counter.get.map(c =&gt; if (c &lt; 1) &quot;World&quot; else &quot;THE World&quot;)
  }
}
// makeWorld: ZIO[Any, Nothing, AnyRef with World{val world: zio.ZIO[Any,Nothing,String]}] = OnSuccess(repl.MdocSession.MdocApp39.makeWorld(basics.md:935),Sync(repl.MdocSession.MdocApp39.makeWorld(basics.md:935),zio.Ref$$$Lambda$22469/0x00007fea4a5e7d38@21d87e07),zio.ZIO$$Lambda$22381/0x00007fea49fe0000@71358fc2)

// the main function

val turboFunctionalHelloWorld: RIO[Hello with World, Unit] = {
  for {
    hello &lt;- hello
    world &lt;- world
    _     &lt;- Console.print(s&quot;$hello $world&quot;)
  } yield ()
}
// turboFunctionalHelloWorld: RIO[Hello with World, Unit] = OnSuccess(repl.MdocSession.MdocApp39.turboFunctionalHelloWorld(basics.md:944),OnSuccess(repl.MdocSession.MdocApp39.hello(basics.md:916),Sync(repl.MdocSession.MdocApp39.hello(basics.md:916),zio.ZIO$ServiceWithZIOPartiallyApplied$$$Lambda$22400/0x00007fea49ae7890@3dd0fabf),zio.ZIO$$$Lambda$22275/0x00007fea4b4b8dd0@3f81a452),&lt;function1&gt;)

def module = new ModuleDef {
  make[Hello].fromZIOEnv(makeHello)
  make[World].fromZIOEnv(makeWorld)
  make[Unit].fromZIOEnv(turboFunctionalHelloWorld)
}

val main = Injector[Task]()
  .produceRun[Unit](module)((_: Unit) =&gt; ZIO.unit)
// main: Task[Unit] = DynamicNoBox(izumi.functional.quasi.QuasiPrimitivesFromBIO.bracket(QuasiIO.scala:339),1,zio.ZIO$$$Lambda$22352/0x00007fea4a41bda0@6f911ace)

import izumi.functional.bio.UnsafeRun2

val runtime = UnsafeRun2.createZIO()
// runtime: UnsafeRun2.ZIORunner[Any] = izumi.functional.bio.UnsafeRun2$ZIORunner@33dc2d8f

runtime.unsafeRun(main)
// Creating Enterprise Hellower...
// Hello WorldShutting down Enterprise Hellower
</code></pre>
<h3><a href="#converting-zio-environment-dependencies-to-parameters" name="converting-zio-environment-dependencies-to-parameters" class="anchor"><span class="anchor-link"></span></a>Converting ZIO environment dependencies to parameters</h3>
<p>Any ZIO Service that requires an environment can be turned into a service without an environment dependency by providing the dependency in each method using <code>.provide</code>.</p>
<p>This pattern can be generalized by implementing an instance of <code>cats.Contravariant</code> (or <code>cats.tagless.FunctorK</code>) for your services and using it to turn environment dependencies into constructor parameters.</p>
<p>In that way ZIO Environment can be used uniformly for declaration of dependencies, but the dependencies used inside the service do not leak to other services calling it. See: <a href="https://gitter.im/ZIO/Core?at=5dbb06a86570b076740f6db2">https://gitter.im/ZIO/Core?at=5dbb06a86570b076740f6db2</a></p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Injector, ModuleDef, Functoid, Tag, TagK, ZEnvConstructor}
import zio.{URIO, ZIO, ZEnvironment}

trait Dependee[-R] {
  def x(y: String): URIO[R, Int]
}
trait Depender[-R] {
  def y: URIO[R, String]
}

trait ContravariantService[M[_]] {
  def contramapZEnv[A, B](s: M[A])(f: ZEnvironment[B] =&gt; ZEnvironment[A]): M[B]
}

implicit val contra1: ContravariantService[Dependee] = new ContravariantService[Dependee] {
  def contramapZEnv[A, B](fa: Dependee[A])(f: ZEnvironment[B] =&gt; ZEnvironment[A]): Dependee[B] = new Dependee[B] { def x(y: String) = fa.x(y).provideSomeEnvironment(f) }
}
// contra1: ContravariantService[Dependee] = repl.MdocSession$MdocApp41$$anon$28@519645b5
implicit val contra2: ContravariantService[Depender] = new ContravariantService[Depender] {
  def contramapZEnv[A, B](fa: Depender[A])(f: ZEnvironment[B] =&gt; ZEnvironment[A]): Depender[B] = new Depender[B] { def y = fa.y.provideSomeEnvironment(f) }
}
// contra2: ContravariantService[Depender] = repl.MdocSession$MdocApp41$$anon$30@c009bda

type DependeeR = Dependee[Any]
type DependerR = Depender[Any]
object dependee extends Dependee[DependeeR] {
  def x(y: String) = ZIO.serviceWithZIO(_.x(y))
}
object depender extends Depender[DependerR] {
  def y = ZIO.serviceWithZIO(_.y)
}

// cycle
object dependerImpl extends Depender[DependeeR] {
  def y: URIO[DependeeR, String] = dependee.x(&quot;hello&quot;).map(_.toString)
}
object dependeeImpl extends Dependee[DependerR] {
  def x(y: String): URIO[DependerR, Int] = {
    if (y == &quot;hello&quot;) ZIO.succeed(5)
    else depender.y.map(y.length + _.length)
  }
}

/** Fulfill the environment dependencies of a service from the object graph */
def fullfill[R: Tag: ZEnvConstructor, M[_]: TagK: ContravariantService](service: M[R]): Functoid[M[Any]] = {
  ZEnvConstructor[R]
    .map(zenv =&gt; implicitly[ContravariantService[M]].contramapZEnv(service)(_ =&gt; zenv))
}

def module = new ModuleDef {
  make[Depender[Any]].from(fullfill(dependerImpl))
  make[Dependee[Any]].from(fullfill(dependeeImpl))
}

import izumi.functional.bio.UnsafeRun2

val runtime = UnsafeRun2.createZIO()
// runtime: UnsafeRun2.ZIORunner[Any] = izumi.functional.bio.UnsafeRun2$ZIORunner@6b20a7fe

runtime.unsafeRun {
  Injector()
    .produceRun(module) {
      ZEnvConstructor[DependeeR].map {
        (for {
          r &lt;- dependee.x(&quot;zxc&quot;)
          _ &lt;- ZIO.attempt(println(s&quot;result: $r&quot;))
        } yield ()).provideEnvironment(_)
      }
    }
}
// result: 4
</code></pre>
<h2><a href="#auto-traits" name="auto-traits" class="anchor"><span class="anchor-link"></span></a>Auto-Traits</h2>
<p>distage can instantiate traits and structural types.</p>
<p>Use <code>makeTrait[X]</code> or <code>make[X].fromTrait[Y]</code> to wire traits, abstract classes or a structural types.</p>
<p>All unimplemented fields in a trait, or a refinement are filled in from the object graph. Trait implementations are derived at compile-time by <a href="/latest/snapshot/api/izumi/distage/constructors/TraitConstructor.html" title="izumi.distage.constructors.TraitConstructor"><code>TraitConstructor</code></a> macro and can be summoned at need.</p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{ModuleDef, Id, Injector}

trait Trait1 {
  def a: Int @Id(&quot;a&quot;)
}
trait Trait2 {
  def b: Int @Id(&quot;b&quot;)
}

/** All methods in this trait are implemented,
  * so a constructor for it will be generated
  * even though it&#39;s not a class */
trait Pluser {
  def plus(a: Int, b: Int) = a + b
}

trait PlusedInt {
  def result(): Int
}
object PlusedInt {

  /**
    * Besides the dependency on `Pluser`,
    * this class defines 2 more dependencies
    * to be injected from the object graph:
    *
    * `def a: Int @Id(&quot;a&quot;)` and
    * `def b: Int @Id(&quot;b&quot;)`
    *
    * When an abstract type is declared as an implementation,
    * its no-argument abstract defs &amp; vals are considered as
    * dependency parameters by TraitConstructor. (empty-parens and
    * parameterized methods are not considered parameters)
    *
    * Here, using an abstract class directly as an implementation
    * lets us avoid writing a lengthier constructor, like this one:
    *
    * {{{
    *   final class Impl(
    *     pluser: Pluser,
    *     override val a: Int @Id(&quot;a&quot;),
    *     override val b: Int @Id(&quot;b&quot;),
    *   ) extends PlusedInt with Trait1 with Trait2
    * }}}
    */
  abstract class Impl(
    pluser: Pluser
  ) extends PlusedInt
    with Trait1
    with Trait2 {
    override def result(): Int = {
      pluser.plus(a, b)
    }
  }

}

def module = new ModuleDef {
  make[Int].named(&quot;a&quot;).from(1)
  make[Int].named(&quot;b&quot;).from(2)
  makeTrait[Pluser]
  make[PlusedInt].fromTrait[PlusedInt.Impl]
}

Injector().produceRun(module) {
  (plusedInt: PlusedInt) =&gt;
    plusedInt.result()
}
// res44: distage.package.Identity[Int] = 3
</code></pre>
<h3><a href="#impl-annotation" name="impl-annotation" class="anchor"><span class="anchor-link"></span></a>@impl annotation</h3>
<p>Abstract classes or traits without obvious concrete subclasses may hinder the readability of a codebase, to mitigate that you may use an optional <a href="/latest/snapshot/api/izumi/distage/model/definition/impl.html" title="izumi.distage.model.definition.impl"><code>@impl</code></a> documenting annotation to aid the reader in understanding your intention.</p>
<pre class="prettyprint"><code class="language-scala">import distage.impl

@impl abstract class Impl(
  pluser: Pluser
) extends PlusedInt with Trait1 with Trait2 {
  override def result(): Int = {
    pluser.plus(a, b)
  }
}
</code></pre>
<h3><a href="#avoiding-constructors-even-further" name="avoiding-constructors-even-further" class="anchor"><span class="anchor-link"></span></a>Avoiding constructors even further</h3>
<p>When overriding behavior of a class, you may avoid writing a repeat of its constructor in your subclass by inheriting a trait from it instead. Example:</p>
<pre class="prettyprint"><code class="language-scala">/**
  * Note how we avoid writing a call to the super-constructor
  * of `PlusedInt.Impl`, such as:
  *
  * {{{
  *   abstract class OverridenPlusedIntImpl(
  *     pluser: Pluser
  *   ) extends PlusedInt.Impl(pluser)
  * }}}
  *
  * Which would be unavoidable with class-to-class inheritance.
  * Using trait-to-class inheritance we avoid writing any boilerplate
  * besides the overrides we want to apply to the class.
  */
@impl trait OverridenPlusedIntImpl extends PlusedInt.Impl {
 override def result(): Int = {
   super.result() * 10
 }
}

Injector().produceRun(module overriddenBy new ModuleDef {
  make[PlusedInt].fromTrait[OverridenPlusedIntImpl]
}) {
  (plusedInt: PlusedInt) =&gt;
    plusedInt.result()
}
// res45: distage.package.Identity[Int] = 30
</code></pre>
<h2><a href="#auto-factories" name="auto-factories" class="anchor"><span class="anchor-link"></span></a>Auto-Factories</h2>
<p><code>distage</code> can derive &lsquo;factory&rsquo; implementations from suitable traits using <code>makeFactory</code> method. This feature is especially useful with <code>Akka</code>. All unimplemented methods <em>with parameters</em> in a trait will be filled by factory methods:</p>
<p>Given a class <code>ActorFactory</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.ModuleDef
import java.util.UUID

class SessionStorage

class UserActor(sessionId: UUID, sessionStorage: SessionStorage)

trait ActorFactory {
  // UserActor will be created as follows:
  //   sessionId argument is provided by the user
  //   sessionStorage argument is wired from the object graph
  def createActor(sessionId: UUID): UserActor
}
</code></pre>
<p>And a binding of <code>ActorFactory</code> <em>without</em> an implementation.</p>
<pre class="prettyprint"><code class="language-scala">class ActorModule extends ModuleDef {
  makeFactory[ActorFactory]
}
</code></pre>
<p><code>distage</code> will derive and bind the following implementation for <code>ActorFactory</code>:</p>
<pre class="prettyprint"><code class="language-scala">class ActorFactoryImpl(sessionStorage: SessionStorage) extends ActorFactory {
  override def createActor(sessionId: UUID): UserActor = {
    new UserActor(sessionId, sessionStorage)
  }
}
</code></pre>
<p>Note that ordinary function types conform to distage&rsquo;s definition of a &lsquo;factory&rsquo;, since they are just traits with an unimplemented method. Sometimes declaring a separate named factory trait isn&rsquo;t worth it, in these cases you can use <code>makeFactory</code> to generate ordinary function types:</p>
<pre class="prettyprint"><code class="language-scala">object UserActor {
  type Factory = UUID =&gt; UserActor
}

class ActorFunctionModule extends ModuleDef {
  makeFactory[UserActor.Factory]
}
</code></pre>
<p>You can use this feature to concisely provide non-Singleton semantics for some of your components.</p>
<p>Factory implementations are derived at compile-time by <a href="/latest/snapshot/api/izumi/distage/constructors/FactoryConstructor.html" title="izumi.distage.constructors.FactoryConstructor"><code>FactoryConstructor</code></a> macro and can be summoned at need.</p>
<p>Since <code>distage</code> version <code>1.1.0</code> you have to bind factories explicitly using <code>makeFactory</code> and <code>fromFactory</code> methods, not implicitly via <code>make</code>; parameterless methods in factories now produce new instances instead of summoning a dependency.</p>
<h3><a href="#with-annotation" name="with-annotation" class="anchor"><span class="anchor-link"></span></a>@With annotation</h3>
<p><code>@With</code> annotation can be used to specify the implementation class, to avoid leaking the implementation type in factory method result:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Injector, ModuleDef, With}

trait Actor {
  def receive(msg: Any): Unit
}

object Actor {
  trait Factory {
    def newActor(id: String): Actor @With[Actor.Impl]
  }

  final class Impl(id: String, config: Actor.Configuration) extends Actor {
    def receive(msg: Any): Unit = {
      val response = s&quot;Actor `$id` received a message: $msg&quot;
      println(if (config.allCaps) response.toUpperCase else response)
    }
  }

  final case class Configuration(allCaps: Boolean)
}

def factoryModule = new ModuleDef {
  makeFactory[Actor.Factory]
  make[Actor.Configuration].from(Actor.Configuration(allCaps = false))
}

Injector()
  .produceGet[Actor.Factory](factoryModule)
  .use(_.newActor(&quot;Martin Odersky&quot;).receive(&quot;ping&quot;))
// Actor `Martin Odersky` received a message: ping
// res48: distage.package.Identity[Unit] = ()
</code></pre>
<h2><a href="#subcontexts" name="subcontexts" class="anchor"><span class="anchor-link"></span></a>Subcontexts</h2>
<p>Sometimes multiple components depend on the same piece of data that appears locally, after all the components were already wired. This data may need to be passed around repeatedly, possibly across the entire application. To do this, we may have to add an argument to most methods of an application, or have to use a Reader monad everywhere.</p>
<p>For example, we could be adding distributed tracing to our application - after getting a RequestId from a request, we may need to carry it everywhere to add it to logs and metrics.</p>
<p>Ideally, instead of adding the same argument to our methods, we&rsquo;d want to just move that argument data out to the class constructor - passing the argument just once during the construction of a class. However, we&rsquo;d lose the ability to automatically wire our objects, since we can only get a RequestId from a request, it&rsquo;s not available when we initially wire our object graph.</p>
<p>Since 1.2.0 this problem is addressed in distage using <code>Subcontext</code>s - using them we can define a wireable sub-graph of our components that depend on local data unavailable during wiring, but that we can then finish wiring once we pass them the data.</p>
<p>Starting with a graph that has no local dependencies:</p>
<pre class="prettyprint"><code class="language-scala">import izumi.functional.bio.IO2
import distage.{ModuleDef, Subcontext, TagKK}

class PetStoreBusinessLogic[F[+_, +_]] {
  // requestId is a method parameter
  def buyPetLogic(requestId: RequestId, petId: PetId, payment: Int): F[Throwable, Pet] = ???
}

def module1[F[+_, +_]: TagKK] = new ModuleDef {
  make[PetStoreAPIHandler[F]]

  make[PetStoreRepository[F]]
  make[PetStoreBusinessLogic[F]]
}

class PetStoreAPIHandler[F[+_, +_]: IO2](
  petStoreBusinessLogic: PetStoreBusinessLogic[F]
) {
  def buyPet(petId: PetId, payment: Int): F[Throwable, Pet] = {
    petStoreBusinessLogic.buyPetLogic(RequestId(), petId, payment)
  }
}
</code></pre>
<p>We use <code>makeSubcontext</code> to delineate a portion of the graph that requires a <code>RequestId</code> to be wired:</p>
<pre class="prettyprint"><code class="language-scala">class PetStoreBusinessLogic[F[+_, +_]](
  // requestId is a now a class parameter
  requestId: RequestId
) {
  def buyPetLogic(petId: PetId, payment: Int): F[Throwable, Pet] = ???
}

def module2[F[+_, +_] : TagKK] = new ModuleDef {
  make[PetStoreAPIHandler[F]]

  makeSubcontext[PetStoreBusinessLogic[F]]
    .withSubmodule(new ModuleDef {
      make[PetStoreRepository[F]]
      make[PetStoreBusinessLogic[F]]
    })
    .localDependency[RequestId]
}

class PetStoreAPIHandler[F[+_, +_]: IO2: TagKK](
  petStoreBusinessLogic: Subcontext[PetStoreBusinessLogic[F]]
) {
  def buyPet(petId: PetId, payment: Int): F[Throwable, Pet] = {
    // we have to pass the parameter and create the component now, since it&#39;s not already wired.
    petStoreBusinessLogic
      .provide[RequestId](RequestId())
      .produceRun {
        _.buyPetLogic(petId, payment)
      }
  }
}
</code></pre>
<p>We managed to move RequestId from a method parameter that polluted every method signature, to a class parameter, that we pass to the subgraph just once - when the RequestId is generated.</p>
<p>Full example:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Injector, Lifecycle, ModuleDef, Subcontext, TagKK}
import izumi.functional.bio.{Error2, F, IO2, Monad2, Primitives2}
import izumi.functional.bio.data.Morphism1
import logstage.{IzLogger, LogIO2}
import izumi.logstage.distage.LogIO2Module

import java.util.UUID

final case class PetId(petId: UUID)
final case class RequestId(requestId: UUID)

sealed trait TransactionFailure
object TransactionFailure {
  case object NoSuchPet extends TransactionFailure
  case object InsufficientFunds extends TransactionFailure
}

final case class Pet(name: String, species: String, price: Int)

final class PetStoreAPIHandler[F[+_, +_]: IO2: TagKK](
  petStoreBusinessLogic: Subcontext[PetStoreBusinessLogic[F]]
) {
  def buyPet(petId: PetId, payment: Int): F[TransactionFailure, Pet] = {
    for {
      requestId &lt;- F.sync(RequestId(UUID.randomUUID()))
      pet &lt;- petStoreBusinessLogic
              .provide[RequestId](requestId)
              .produce[F[Throwable, _]]()
              .mapK[F[Throwable, _], F[TransactionFailure, _]](Morphism1(_.orTerminate))
              .use {
                component =&gt;
                  component.buyPetLogic(petId, payment)
              }
    } yield pet
  }
}

final class PetStoreBusinessLogic[F[+_, +_]: Error2](
  requestId: RequestId,
  petStoreReposistory: PetStoreReposistory[F],
  log: LogIO2[F],
) {
  private val contextLog = log.withCustomContext(&quot;requestId&quot; -&gt; requestId)

  def buyPetLogic(petId: PetId, payment: Int): F[TransactionFailure, Pet] = {
    for {
      pet &lt;- petStoreReposistory.findPet(petId).fromOption(TransactionFailure.NoSuchPet)
      _   &lt;- if (payment &lt; pet.price) {
          contextLog.error(s&quot;Insufficient $payment, couldn&#39;t afford ${pet.price}&quot;) *&gt;
          F.fail(TransactionFailure.InsufficientFunds)
        } else {
          for {
            result &lt;- petStoreReposistory.removePet(petId)
            _      &lt;- F.when(!result)(F.fail(TransactionFailure.NoSuchPet))
            _      &lt;- contextLog.info(s&quot;Successfully bought $pet with $petId for $payment! ${payment - pet.price -&gt; &quot;overpaid&quot;}&quot;)
          } yield ()
        }
    } yield pet
  }
}

trait PetStoreReposistory[F[+_, +_]] {
  def findPet(petId: PetId): F[Nothing, Option[Pet]]
  def removePet(petId: PetId): F[Nothing, Boolean]
}
object PetStoreReposistory {
  final class Impl[F[+_, +_]: Monad2: Primitives2](
    requestId: RequestId,
    log: LogIO2[F],
  ) extends Lifecycle.LiftF[F[Nothing, _], PetStoreReposistory[F]](for {
    state &lt;- F.mkRef(Pets.builtinPetMap)
  } yield new PetStoreReposistory[F] {
    private val contextLog = log(&quot;requestId&quot; -&gt; requestId)

    override def findPet(petId: PetId): F[Nothing, Option[Pet]] = {
      for {
        _        &lt;- contextLog.info(s&quot;Looking up $petId&quot;)
        maybePet &lt;- state.get.map(_.get(petId))
        _        &lt;- contextLog.info(s&quot;Got $maybePet&quot;)
      } yield maybePet
    }

    override def removePet(petId: PetId): F[Nothing, Boolean] = {
      for {
        success &lt;- state.modify(s =&gt; (s.contains(petId), s - petId))
        _       &lt;- contextLog.info(s&quot;Tried to remove $petId, $success&quot;)
      } yield success

    }
  })
}

object Pets {
  val arnoldId = PetId(UUID.randomUUID())
  val buckId   = PetId(UUID.randomUUID())
  val chipId   = PetId(UUID.randomUUID())
  val derryId  = PetId(UUID.randomUUID())
  val emmyId   = PetId(UUID.randomUUID())

  val builtinPetMap = Map[PetId, Pet](
    arnoldId -&gt; Pet(&quot;Arnold&quot;, &quot;Dog&quot;, 99),
    buckId   -&gt; Pet(&quot;Buck&quot;, &quot;Rabbit&quot;, 60),
    chipId   -&gt; Pet(&quot;Chip&quot;, &quot;Cat&quot;, 75),
    derryId  -&gt; Pet(&quot;Derry&quot;, &quot;Dog&quot;, 250),
    emmyId   -&gt; Pet(&quot;Emmy&quot;, &quot;Guinea Pig&quot;, 20)
  )
}

object Module extends ModuleDef {
  include(module[zio.IO])

  def module[F[+_, +_]: TagKK] = new ModuleDef {
    make[PetStoreAPIHandler[F]]

    make[IzLogger].from(IzLogger())
    include(LogIO2Module[F]())

    makeSubcontext[PetStoreBusinessLogic[F]]
      .withSubmodule(new ModuleDef {
        make[PetStoreReposistory[F]].fromResource[PetStoreReposistory.Impl[F]]
        make[PetStoreBusinessLogic[F]]
      })
      .localDependency[RequestId]
  }
}

import izumi.functional.bio.UnsafeRun2

val runner = UnsafeRun2.createZIO()
// runner: UnsafeRun2.ZIORunner[Any] = izumi.functional.bio.UnsafeRun2$ZIORunner@39425f40

val result = runner.unsafeRun {
  Injector[zio.Task]()
    .produceRun(Module) {
      (p: PetStoreAPIHandler[zio.IO]) =&gt;
        p.buyPet(Pets.arnoldId, 100).attempt
    }
}
// I 2024-05-27T21:56:33.788 (basics.md:1493)  â€¦PetStoreReposistory.findPet [433:Thread-118] requestId=RequestId(85dc4887-44bf-4810-8a60-a08bcd8b7210) Looking up pet_id=PetId(50d91bdf-2331-4f62-b70d-ce24da4159e5)
// I 2024-05-27T21:56:33.800 (basics.md:1495)  â€¦P.I.1.1.P.findPet.1493.1494 [433:Thread-118] requestId=RequestId(85dc4887-44bf-4810-8a60-a08bcd8b7210) Got maybe_pet=Some(Pet(Arnold,Dog,99))
// I 2024-05-27T21:56:33.821 (basics.md:1502)  â€¦eReposistory.removePet.1501 [433:Thread-118] requestId=RequestId(85dc4887-44bf-4810-8a60-a08bcd8b7210) Tried to remove pet_id=PetId(50d91bdf-2331-4f62-b70d-ce24da4159e5), success=true
// I 2024-05-27T21:56:33.828 (basics.md:1468)  r.M.M.P.b.1460.1466.1467 [433:Thread-118] requestId=RequestId(85dc4887-44bf-4810-8a60-a08bcd8b7210) Successfully bought pet=Pet(Arnold,Dog,99) with pet_id=PetId(50d91bdf-2331-4f62-b70d-ce24da4159e5) for payment=100! overpaid=1
// result: Either[TransactionFailure, Pet] = Right(
//   value = Pet(name = &quot;Arnold&quot;, species = &quot;Dog&quot;, price = 99)
// )
</code></pre>
<p>Using subcontexts is more efficient than <a href="advanced-features.html#depending-on-locator">nesting Injectors</a> manually, since subcontexts are planned ahead of time - there&rsquo;s no planning step for subcontexts, only execution step.</p>
<p>Note: When your subcontext&rsquo;s submodule only contains one binding, you may be able to achieve the same result using an <a href="basics.html#auto-factories">Auto-Factory</a> instead.</p>
<h2><a href="#tagless-final-style" name="tagless-final-style" class="anchor"><span class="anchor-link"></span></a>Tagless Final Style</h2>
<p>Tagless Final is one of the popular patterns for structuring purely-functional applications.</p>
<p>Brief introduction to tagless final:</p>
<ul>
  <li><a href="https://medium.com/@calvin.l.fer/deferring-commitments-tagless-final-704d768f15cb">Deferring Commitments: Tagless Final</a></li>
  <li><a href="https://www.beyondthelines.net/programming/introduction-to-tagless-final/">Introduction to Tagless Final</a></li>
</ul>
<p>Advantages of <code>distage</code> as a driver for TF compared to implicits:</p>
<ul>
  <li>easy explicit overrides</li>
  <li>easy <a href="basics.html#effect-bindings">effectful instantiation</a> and <a href="basics.html#resource-bindings-lifecycle">resource management</a></li>
  <li>extremely easy &amp; scalable <a href="distage-testkit.html">test</a> context setup due to the above</li>
  <li>multiple different implementations for a type using disambiguation by <code>@Id</code></li>
</ul>
<p>For example, let&rsquo;s take <a href="http://frees.io/docs/core/handlers/#tagless-interpretation"><code>freestyle</code>&rsquo;s tagless example</a> and make it better by replacing dependencies on global <code>import</code>ed implementations with explicit modules.</p>
<p>First, the program we want to write:</p>
<pre class="prettyprint"><code class="language-scala">import cats.Monad
import cats.effect.{Sync, IO}
import cats.syntax.all._
import distage.{Roots, ModuleDef, Injector, Tag, TagK, TagKK}

trait Validation[F[_]] {
  def minSize(s: String, n: Int): F[Boolean]
  def hasNumber(s: String): F[Boolean]
}
object Validation {
  def apply[F[_]: Validation]: Validation[F] = implicitly
}

trait Interaction[F[_]] {
  def tell(msg: String): F[Unit]
  def ask(prompt: String): F[String]
}
object Interaction {
  def apply[F[_]: Interaction]: Interaction[F] = implicitly
}

class TaglessProgram[F[_]: Monad: Validation: Interaction] {
  def program: F[Unit] = for {
    userInput &lt;- Interaction[F].ask(&quot;Give me something with at least 3 chars and a number on it&quot;)
    valid     &lt;- (Validation[F].minSize(userInput, 3), Validation[F].hasNumber(userInput)).mapN(_ &amp;&amp; _)
    _         &lt;- if (valid) Interaction[F].tell(&quot;awesomesauce!&quot;)
                 else       Interaction[F].tell(s&quot;$userInput is not valid&quot;)
  } yield ()
}

def ProgramModule[F[_]: TagK: Monad] = new ModuleDef {
  make[TaglessProgram[F]]
}
</code></pre>
<p><a href="/latest/snapshot/api/izumi/reflect/TagK.html" title="izumi.reflect.TagK"><code>TagK</code></a> is <code>distage</code>&rsquo;s analogue of <code>TypeTag</code> for higher-kinded types such as <code>F[_]</code>, it allows preserving type-information at runtime for type parameters. You&rsquo;ll need to add a <a href="/latest/snapshot/api/izumi/reflect/TagK.html" title="izumi.reflect.TagK"><code>TagK</code></a> context bound to create a module parameterized by an abstract <code>F[_]</code>. To parameterize by non-higher-kinded types, use just <a href="/latest/snapshot/api/izumi/reflect/Tag.html" title="izumi.reflect.Tag"><code>Tag</code></a>.</p>
<p>Now the interpreters for <code>Validation</code> and <code>Interaction</code>:</p>
<pre class="prettyprint"><code class="language-scala">final class SyncValidation[F[_]](implicit F: Sync[F]) extends Validation[F] {
  def minSize(s: String, n: Int): F[Boolean] = F.delay(s.size &gt;= n)
  def hasNumber(s: String): F[Boolean]       = F.delay(s.exists(c =&gt; &quot;0123456789&quot;.contains(c)))
}

final class SyncInteraction[F[_]](implicit F: Sync[F]) extends Interaction[F] {
  def tell(s: String): F[Unit]  = F.delay(println(s))
  def ask(s: String): F[String] = F.delay(&quot;This could have been user input 1&quot;)
}

def SyncInterpreters[F[_]: TagK: Sync] = {
  new ModuleDef {
    make[Validation[F]].from[SyncValidation[F]]
    make[Interaction[F]].from[SyncInteraction[F]]
  }
}

// combine all modules

def SyncProgram[F[_]: TagK: Sync] = ProgramModule[F] ++ SyncInterpreters[F]

// create object graph Lifecycle

val objectsLifecycle = Injector[IO]().produce(SyncProgram[IO], Roots.Everything)
// objectsLifecycle: izumi.distage.model.definition.package.Lifecycle[IO, izumi.distage.model.Locator] = izumi.functional.lifecycle.LifecycleMethodImpls$$anon$2@2169d6c0

// run

import cats.effect.unsafe.implicits.global

objectsLifecycle.use(_.get[TaglessProgram[IO]].program).unsafeRunSync()
// awesomesauce!
</code></pre>
<h3><a href="#effect-type-polymorphism" name="effect-type-polymorphism" class="anchor"><span class="anchor-link"></span></a>Effect-type polymorphism</h3>
<p>The program module is polymorphic over effect type. It can be instantiated by a different effect:</p>
<pre class="prettyprint"><code class="language-scala">import zio.interop.catz._
import zio.Task

val ZIOProgram = ProgramModule[Task] ++ SyncInterpreters[Task]
// ZIOProgram: izumi.distage.model.definition.Module = 
// make[{type.repl.MdocSession::MdocApp51::TaglessProgram[=Î» %0 â†’ zio.ZIO[-scala.Any,+java.lang.Throwable,+0]]}].from(call(Ï€:Class(cats.Monad[=Î» %0 â†’ zio.ZIO[-scala.Any,+java.lang.Throwable,+0]], repl.MdocSession::MdocApp51::Validation[=Î» %0 â†’ zio.ZIO[-scala.Any,+java.lang.Throwable,+0]], repl.MdocSession::MdocApp51::Interaction[=Î» %0 â†’ zio.ZIO[-scala.Any,+java.lang.Throwable,+0]]): repl.MdocSession::MdocApp51::TaglessProgram[=Î» %0 â†’ zio.ZIO[-scala.Any,+java.lang.Throwable,+0]])) ((basics.md:1612))
// make[{type.repl.MdocSession::MdocApp51::Validation[=Î» %0 â†’ zio.ZIO[-scala.Any,+java.lang.Throwable,+0]]}].from(call(Ï€:Class(cats.effect.kernel.Sync[=Î» %0 â†’ zio.ZIO[-scala.Any,+java.lang.Throwable,+0]]): repl.MdocSession::MdocApp51::SyncValidation[=Î» %0 â†’ zio.ZIO[-scala.Any,+java.lang.Throwable,+0]])) ((basics.md:1633))
// make[{type.repl.MdocSession::MdocApp51::Interaction[=Î» %0 â†’ zio.ZIO[-scala.Any,+java.lang.Throwable,+0]]}].from(call(Ï€:Class(cats.effect.kernel.Sync[=Î» %0 â†’ zio.ZIO[-scala.Any,+java.lang.Throwable,+0]]): repl.MdocSession::MdocApp51::SyncInteraction[=Î» %0 â†’ zio.ZIO[-scala.Any,+java.lang.Throwable,+0]])) ((basics.md:1634))
</code></pre>
<p>We may even choose different interpreters at runtime:</p>
<pre class="prettyprint"><code class="language-scala">import zio.Console
import distage.Activation

object RealInteractionZIO extends Interaction[Task] {
  def tell(s: String): Task[Unit]  = Console.printLine(s)
  def ask(s: String): Task[String] = Console.printLine(s) *&gt; Console.readLine
}

def RealInterpretersZIO = {
  SyncInterpreters[Task] overriddenBy new ModuleDef {
    make[Interaction[Task]].from(RealInteractionZIO)
  }
}

def chooseInterpreters(isDummy: Boolean) = {
  val interpreters = if (isDummy) SyncInterpreters[Task]
                     else         RealInterpretersZIO
  def module = ProgramModule[Task] ++ interpreters

  Injector[Task]()
    .produceGet[TaglessProgram[Task]](module, Activation.empty)
}

// execute

chooseInterpreters(true)
// res53: izumi.distage.model.definition.package.Lifecycle[Task, TaglessProgram[Task]] = izumi.functional.lifecycle.LifecycleMethodImpls$$anon$1@2c726dc0
</code></pre>
<h3><a href="#kind-polymorphism" name="kind-polymorphism" class="anchor"><span class="anchor-link"></span></a>Kind polymorphism</h3>
<p>Modules can be polymorphic over arbitrary kinds - use <code>TagKK</code> to abstract over bifunctors:</p>
<pre class="prettyprint"><code class="language-scala">class BifunctorIOModule[F[_, _]: TagKK] extends ModuleDef
</code></pre>
<p>Or use <code>Tag.auto.T</code> to abstract over any kind:</p>
<pre class="prettyprint"><code class="language-scala">class MonadTransformerModule[F[_[_], _]: Tag.auto.T] extends ModuleDef
</code></pre>
<pre class="prettyprint"><code class="language-scala">class EldritchModule[F[+_, -_[_, _], _[_[_, _], _], _]: Tag.auto.T] extends ModuleDef
</code></pre>
<p>consult <a href="https://javadoc.io/doc/dev.zio/izumi-reflect_2.13/latest/izumi/reflect/HKTag.html">izumi.reflect.HKTag</a> docs for more details.</p>
<h2><a href="#cats-zio-integration" name="cats-zio-integration" class="anchor"><span class="anchor-link"></span></a>Cats &amp; ZIO Integration</h2>
<p>Cats &amp; ZIO instances and syntax are available automatically in <code>distage-core</code>, without wildcard imports, if your project depends on <code>cats-core</code>, <code>cats-effect</code> or <code>zio</code>. However, distage <em>won&rsquo;t</em> bring in <code>cats</code> or <code>zio</code> as dependencies if you don&rsquo;t already depend on them. (see <a href="https://blog.7mind.io/no-more-orphans.html">No More Orphans</a> blog post for details on how that works)</p>
<p><a href="basics.html#resource-bindings-lifecycle">Cats Resource &amp; ZIO ZManaged Bindings</a> also work out of the box without any magic imports.</p>
<p>All relevant typeclass instances for chosen effect type, such as <code>ConcurrentEffect[F]</code>, are <a href="basics.html#out-of-the-box-typeclass-instances">included by default</a> (overridable by user bindings)</p>
</div>
<div>
<a href="https://github.com/7mind/izumi/tree/master/doc/microsite/target/mdoc/distage/basics.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
1.2.9*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../distage/index.html" title="DIStage" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
DIStage
</span>
</div>
</a>
<a href="../distage/debugging.html" title="Debugging" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Debugging
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
7mind.io
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://sbt.github.io/sbt-paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
