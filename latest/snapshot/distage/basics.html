<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="microsite">
<meta name="generator" content="Paradox, paradox-material-theme=0.11.0-SNAPSHOT, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="microsite">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>Basics Â· Izumi Project</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Izumi Project" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Izumi Project
</span>
<span class="md-header-nav__topic">
Basics
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/7mind/izumi"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
7mind/izumi
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Izumi Project" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="../index.html" title="Izumi Project">
Izumi Project
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/7mind/izumi"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
7mind/izumi
</div>
</a>

</div>
<ul>
  <li><a href="../distage/index.html" class="page">distage: Staged Dependency Injection</a>
  <ul>
    <li><a href="../distage/basics.html" class="active page">Basics</a></li>
    <li><a href="../distage/advanced-features.html" class="page">Advanced Features</a></li>
    <li><a href="../distage/debugging.html" class="page">Debugging</a></li>
    <li><a href="../distage/distage-framework.html" class="page">distage-framework</a></li>
    <li><a href="../distage/distage-framework-docker.html" class="page">distage-framework-docker</a></li>
    <li><a href="../distage/distage-testkit.html" class="page">distage-testkit</a></li>
    <li><a href="../distage/reference.html" class="page">Syntax Summary</a></li>
  </ul></li>
  <li><a href="../logstage/index.html" class="page">LogStage</a></li>
  <li><a href="../bio/index.html" class="page">BIO Hierarchy</a></li>
  <li><a href="../idealingua/index.html" class="page">IdeaLingua RPC/DML</a>
  <ul>
    <li><a href="../idealingua/language-reference.html" class="page">Idealingua Language Reference</a></li>
    <li><a href="../idealingua/json.html" class="page">JSON Wire Format</a></li>
    <li><a href="../idealingua/cogen.html" class="page">Code generator reference</a></li>
    <li><a href="../idealingua/cogen-circe.html" class="page">Circe serialization reference</a></li>
  </ul></li>
  <li><a href="../sbt/index.html" class="page">SBT Toolkit</a></li>
  <li><a href="../manifesto/index.html" class="page">Productivity and challenges</a></li>
  <li><a href="../pper/index.html" class="page">PPER Pattern</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../distage/basics.html#basics" class="header">Basics</a>
  <ul>
    <li><a href="../distage/basics.html#quick-start" class="header">Quick Start</a></li>
    <li><a href="../distage/basics.html#activation-axis" class="header">Activation Axis</a></li>
    <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings, Lifecycle</a></li>
    <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
    <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
    <li><a href="../distage/basics.html#zio-has-bindings" class="header">ZIO Has Bindings</a></li>
    <li><a href="../distage/basics.html#auto-traits" class="header">Auto-Traits</a></li>
    <li><a href="../distage/basics.html#auto-factories" class="header">Auto-Factories</a></li>
    <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a></li>
    <li><a href="../distage/basics.html#cats-zio-integration" class="header">Cats &amp; ZIO Integration</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 0.11.0*
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../distage/basics.html#basics" class="header">Basics</a>
  <ul>
    <li><a href="../distage/basics.html#quick-start" class="header">Quick Start</a></li>
    <li><a href="../distage/basics.html#activation-axis" class="header">Activation Axis</a></li>
    <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings, Lifecycle</a></li>
    <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
    <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
    <li><a href="../distage/basics.html#zio-has-bindings" class="header">ZIO Has Bindings</a></li>
    <li><a href="../distage/basics.html#auto-traits" class="header">Auto-Traits</a></li>
    <li><a href="../distage/basics.html#auto-factories" class="header">Auto-Factories</a></li>
    <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a></li>
    <li><a href="../distage/basics.html#cats-zio-integration" class="header">Cats &amp; ZIO Integration</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#basics" name="basics" class="anchor"><span class="anchor-link"></span></a>Basics</h1>
<div class="toc ">
<ul>
  <li><a href="../distage/basics.html#quick-start" class="header">Quick Start</a></li>
  <li><a href="../distage/basics.html#activation-axis" class="header">Activation Axis</a>
  <ul>
    <li><a href="../distage/basics.html#multi-dimensionality" class="header">Multi-dimensionality</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings, Lifecycle</a>
  <ul>
    <li><a href="../distage/basics.html#inheritance-helpers" class="header">Inheritance helpers</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
  <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
  <li><a href="../distage/basics.html#zio-has-bindings" class="header">ZIO Has Bindings</a>
  <ul>
    <li><a href="../distage/basics.html#converting-between-zio-environment-dependencies-and-parameters" class="header">Converting between ZIO environment dependencies and parameters</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#auto-traits" class="header">Auto-Traits</a></li>
  <li><a href="../distage/basics.html#auto-factories" class="header">Auto-Factories</a></li>
  <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a></li>
  <li><a href="../distage/basics.html#cats-zio-integration" class="header">Cats &amp; ZIO Integration</a></li>
</ul>
</div>
<h3><a href="#quick-start" name="quick-start" class="anchor"><span class="anchor-link"></span></a>Quick Start</h3>
<p>Suppose we have an abstract <code>Greeter</code> component, and some other components that depend on it:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{ModuleDef, Injector, Roots, Activation}

trait Greeter {
  def hello(name: String): Unit
}

final class PrintGreeter extends Greeter {
  override def hello(name: String) = println(s&quot;Hello $name!&quot;) 
}

trait Byer {
  def bye(name: String): Unit
}

final class PrintByer extends Byer {  
  override def bye(name: String) = println(s&quot;Bye $name!&quot;)
}

final class HelloByeApp(greeter: Greeter, byer: Byer) {
  def run(): Unit = {
    println(&quot;What&#39;s your name?&quot;)
    val name = readLine()
    
    greeter.hello(name)
    byer.bye(name)
  }
}
</code></pre>
<p>To actually run the <code>HelloByeApp</code>, we have to wire implementations of <code>Greeter</code> and <code>Byer</code> into it. We will not do it directly. First we&rsquo;ll only declare the component interfaces we have, and the implementations we want for them:</p>
<pre class="prettyprint"><code class="language-scala">val HelloByeModule = new ModuleDef {
  make[Greeter].from[PrintGreeter]
  make[Byer].from[PrintByer]
  make[HelloByeApp] // `.from` is not required for concrete classes 
}
// HelloByeModule: AnyRef with ModuleDef = 
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.HelloByeApp}].from(call(Ï:Class(repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter, repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.HelloByeApp)) ((basics.md:68))
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Ï:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintGreeter)) ((basics.md:66))
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer}].from(call(Ï:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintByer)) ((basics.md:67))
</code></pre>
<p><code>ModuleDef</code> merely contains a description of the desired object graph, let&rsquo;s transform that high-level description into an actionable series of steps - an <a href="/latest/snapshot/api/izumi/distage/model/plan/OrderedPlan.html">OrderedPlan</a>, a datatype we can <a href="debugging.html#pretty-printing-plans">inspect</a>, <a href="debugging.html#testing-plans">test</a> or <a href="distage-framework.html#compile-time-checks">verify at compile-time</a> â without actually creating any objects or executing any effects.</p>
<pre class="prettyprint"><code class="language-scala">val plan = Injector().plan(HelloByeModule, Activation.empty, Roots.target[HelloByeApp])
// plan: izumi.distage.model.plan.OrderedPlan = 
// {type.MdocSession::App0::Greeter} (basics.md:66) := call(Ï:Class(): MdocSession::App0::PrintGreeter) {}
// {type.MdocSession::App0::Byer} (basics.md:67) := call(Ï:Class(): MdocSession::App0::PrintByer) {}
// {type.MdocSession::App0::HelloByeApp} (basics.md:68) := call(Ï:Class(MdocSession::App0::Greeter, MdocSession::App0::Byer): MdocSession::App0::HelloByeApp) {
//   arg greeter: MdocSession::App0::Greeter = lookup({type.MdocSession::App0::Greeter})
//   arg byer: MdocSession::App0::Byer = lookup({type.MdocSession::App0::Byer})
// }
</code></pre>
<p>The series of steps must be executed to produce the object graph. <code>Injector.produce</code> will interpret the steps into a <a href="basics.html#resource-bindings-lifecycle">Resource</a> value, that holds the lifecycle of the object graph:</p>
<pre class="prettyprint"><code class="language-scala">// Interpret into Lifecycle

val resource = Injector().produce(plan)
// resource: izumi.distage.model.definition.Lifecycle[izumi.fundamentals.platform.functional.package.Identity, izumi.distage.model.Locator] = izumi.distage.model.definition.Lifecycle$$anon$11@7dadd741

// Use the object graph:
// After `.use` exits, all objects will be deallocated,
// and all allocated resources will be freed.

resource.use {
  objects =&gt;
    objects.get[HelloByeApp].run()
}
// What&#39;s your name?
// &gt; izumi
// Hello izumi!
// Bye izumi!
// res1: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()
</code></pre>
<p><code>distage</code> always creates components exactly once, even if multiple other objects depend on them. Coming from other DI frameworks, you may think it&rsquo;s as if there is only a &ldquo;Singleton&rdquo; scope. It&rsquo;s impossible to create non-singletons in <code>distage</code>. If you need multiple singleton instances of the same type, you can create <code>named</code> instances and disambiguate between them using <code>@Id</code> annotation. (<code>javax.inject.Named</code> is also supported)</p>
<pre class="prettyprint"><code class="language-scala">import distage.Id

new ModuleDef {
  make[Byer].named(&quot;byer-1&quot;).from[PrintByer]
  make[Byer].named(&quot;byer-2&quot;).from {
    otherByer: Byer @Id(&quot;byer-1&quot;) =&gt;
      new Byer {
        def bye(name: String) = otherByer.bye(s&quot;NOT-$name&quot;)
      }
  }
}
// res2: AnyRef with ModuleDef = 
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer@byer-2}].from(call(Æ:&lt;function1&gt;(repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer)) ((basics.md:98))
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer@byer-1}].from(call(Ï:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintByer)) ((basics.md:97))
</code></pre>
<p>You can abstract over annotations using type aliases or string constants:</p>
<pre class="prettyprint"><code class="language-scala">object Ids {
  final val byer1Id = &quot;byer-1&quot;
  type Byer1 = Byer @Id(byer1Id)
}
</code></pre>
<p>To create fully non-singleton components you must use explicit factory classes. You can use <a href="basics.html#auto-factories">Auto-Factories</a> to auto-generate implementations for these factories.</p>
<h3><a href="#activation-axis" name="activation-axis" class="anchor"><span class="anchor-link"></span></a>Activation Axis</h3>
<p>You can choose between different implementations of a component using <code>Axis</code> tags:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Axis, Activation, ModuleDef, Injector, Roots}

class AllCapsGreeter extends Greeter {
  def hello(name: String) = println(s&quot;HELLO ${name.toUpperCase}&quot;)
}

// declare the configuration axis for our components

object Style extends Axis {
  case object AllCaps extends AxisValueDef
  case object Normal extends AxisValueDef
}

// Declare a module with several implementations of Greeter
// but in different environments

val TwoImplsModule = new ModuleDef {
  make[Greeter].tagged(Style.Normal)
    .from[PrintGreeter]
  
  make[Greeter].tagged(Style.AllCaps)
    .from[AllCapsGreeter]
}
// TwoImplsModule: AnyRef with ModuleDef = 
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Ï:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.AllCapsGreeter)).tagged(Set(AxisTag(style:allcaps))) ((basics.md:137))
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Ï:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintGreeter)).tagged(Set(AxisTag(style:normal))) ((basics.md:134))

// Combine previous `HelloByeModule` with our new module
// While overriding `make[Greeter]` bindings from the first module 

val CombinedModule = HelloByeModule overriddenBy TwoImplsModule
// CombinedModule: izumi.distage.model.definition.Module = 
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Ï:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintGreeter)).tagged(Set(AxisTag(style:normal))) ((basics.md:134))
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Ï:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.AllCapsGreeter)).tagged(Set(AxisTag(style:allcaps))) ((basics.md:137))
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer}].from(call(Ï:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintByer)) ((basics.md:67))
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.HelloByeApp}].from(call(Ï:Class(repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter, repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.HelloByeApp)) ((basics.md:68))

// Choose component configuration when making an Injector:
Injector()
  .produceGet[HelloByeApp](CombinedModule, Activation(Style -&gt; Style.AllCaps))
  .use(_.run())
// What&#39;s your name?
// &gt; kai
// HELLO KAI
// Bye kai!
// res3: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()

// Check that result changes with a different configuration:

Injector()
  .produceGet[HelloByeApp](CombinedModule, Activation(Style -&gt; Style.Normal))
  .use(_.run())
// What&#39;s your name?
// &gt; Pavel
// Hello Pavel!
// Bye Pavel!
// res4: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()
</code></pre>
<p><a href="/latest/snapshot/api/izumi/distage/model/definition/StandardAxis.html">distage.StandardAxis</a> contains bundled Axes for back-end development: </p>
<ul>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/StandardAxis$$Repo.html">Repo</a> axis with <code>Prod</code>/<code>Dummy</code> choices</li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/StandardAxis$$Mode.html">Mode</a> axis with <code>Prod</code>/<code>Test</code> choices</li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/StandardAxis$$World.html">World</a> axis with <code>Real</code>/<code>Mock</code> choices</li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/StandardAxis$$Scene.html">Scene</a> axis with <code>Managed</code>/<code>Provided</code> choices.</li>
</ul>
<p>In <code>distage-framework</code>&rsquo;s <a href="/latest/snapshot/api/izumi/distage/roles/RoleAppLauncher.html">RoleAppLauncher</a>, you can choose axes using the <code>-u</code> command-line parameter:</p>
<pre><code>./launcher -u repo:dummy -u env:prod app1
</code></pre>
<p>In <code>distage-testkit</code>, choose axes using <a href="/latest/snapshot/api/izumi/distage/testkit/TestConfig.html">TestConfig</a>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.StandardAxis.Repo
import izumi.distage.testkit.TestConfig
import izumi.distage.testkit.scalatest.DistageBIOSpecScalatest

class AxisTest extends DistageBIOSpecScalatest[zio.IO] {
  override protected def config: TestConfig = super.config.copy(
    // choose implementations `.tagged` as `Repo.Dummy` over those tagged `Repo.Prod`
    activation = Activation(Repo -&gt; Repo.Dummy)
  )
}
</code></pre>
<h4><a href="#multi-dimensionality" name="multi-dimensionality" class="anchor"><span class="anchor-link"></span></a>Multi-dimensionality</h4>
<p>There may be many configuration axes in an application and components can specify multiple axis choices at once:</p>
<pre class="prettyprint"><code class="language-scala">import distage.StandardAxis.Env

class TestPrintGreeter extends Greeter {
  def hello(name: String) = println(s&quot;Test 1 2, hello $name&quot;)
}

// declare 3 possible implementations

val TestModule = new ModuleDef {
  make[Greeter].tagged(Style.Normal, Env.Prod).from[PrintGreeter]
  make[Greeter].tagged(Style.Normal, Env.Test).from[TestPrintGreeter]
  make[Greeter].tagged(Style.AllCaps).from[AllCapsGreeter]
}
// TestModule: AnyRef with ModuleDef = 
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Ï:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.TestPrintGreeter)).tagged(Set(AxisTag(style:normal), AxisTag(mode:test))) ((basics.md:188))
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Ï:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.AllCapsGreeter)).tagged(Set(AxisTag(style:allcaps))) ((basics.md:189))
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Ï:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintGreeter)).tagged(Set(AxisTag(style:normal), AxisTag(mode:prod))) ((basics.md:187))

def runWith(activation: Activation) =
  Injector().produceRun(TestModule, activation) {
    greeter: Greeter =&gt; greeter.hello(&quot;$USERNAME&quot;)
  }

// Production Normal Greeter

runWith(Activation(Style -&gt; Style.Normal, Env -&gt; Env.Prod))
// Hello $USERNAME!
// res5: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()

// Test Normal Greeter

runWith(Activation(Style -&gt; Style.Normal, Env -&gt; Env.Test))
// Test 1 2, hello $USERNAME
// res6: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()

// Both Production and Test Caps Greeters are the same:

runWith(Activation(Style -&gt; Style.AllCaps, Env -&gt; Env.Prod))
// HELLO $USERNAME
// res7: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()

runWith(Activation(Style -&gt; Style.AllCaps, Env -&gt; Env.Test))
// HELLO $USERNAME
// res8: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()
</code></pre>
<h3><a href="#resource-bindings-lifecycle" name="resource-bindings-lifecycle" class="anchor"><span class="anchor-link"></span></a>Resource Bindings, Lifecycle</h3>
<p>You can specify object lifecycle by injecting <a href="https://typelevel.org/cats-effect/datatypes/resource.html">cats.effect.Resource</a>, <a href="https://zio.dev/docs/datatypes/datatypes_managed">zio.ZManaged</a> or <a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle.html">distage.Lifecycle</a> values that specify the allocation and finalization actions for an object.</p>
<p>Injector itself only returns a <code>Lifecycle</code> value that can be used to create and finalize the object graph, this value is pure and can be reused multiple times. A <code>Lifecycle</code> is consumed using its <code>.use</code> method, the function passed to <code>use</code> will receive an allocated resource and when the function exits the resource will be deallocated. </p>
<p>Example with <code>cats.effect.Resource</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Roots, ModuleDef, Injector}
import cats.effect.{Bracket, Resource, IO}

class DBConnection
class MessageQueueConnection

val dbResource = Resource.make(
  acquire = IO { 
    println(&quot;Connecting to DB!&quot;)
    new DBConnection 
})(release = _ =&gt; IO(println(&quot;Disconnecting DB&quot;)))
// dbResource: Resource[IO, DBConnection] = Allocate(&lt;function1&gt;)

val mqResource = Resource.make(
  acquire = IO {
   println(&quot;Connecting to Message Queue!&quot;)
   new MessageQueueConnection 
})(release = _ =&gt; IO(println(&quot;Disconnecting Message Queue&quot;)))
// mqResource: Resource[IO, MessageQueueConnection] = Allocate(&lt;function1&gt;)

class MyApp(db: DBConnection, mq: MessageQueueConnection) {
  val run = IO(println(&quot;Hello World!&quot;))
}

val module = new ModuleDef {
  make[DBConnection].fromResource(dbResource)
  make[MessageQueueConnection].fromResource(mqResource)
  addImplicit[Bracket[IO, Throwable]]
  make[MyApp]
}
// module: AnyRef with ModuleDef = 
// make[{type.cats.effect.Bracket[=Î» %1:0 â IO[+1:0],=Throwable]}].from(value(cats.effect.IOLowPriorityInstances$IOEffect@2631ead5: cats.effect.Bracket[=Î» %1:0 â IO[+1:0],=Throwable])) ((basics.md:251))
// make[{type.repl.MdocSession::repl.MdocSession.App9::repl.MdocSession.App9.DBConnection}].from(allocate[Î» %0 â cats.effect.IO[+0]](call(Æ:izumi.distage.model.providers.Functoid$$Lambda$20242/2121087834@301ccc18(cats.effect.Sync[=Î» %0 â IO[+0]]): izumi.distage.model.definition.Lifecycle::izumi.distage.model.definition.Lifecycle.FromCats[=Î» %1:0 â IO[+1:0],=MdocSession::App9::DBConnection]))) ((basics.md:249))
// make[{type.repl.MdocSession::repl.MdocSession.App9::repl.MdocSession.App9.MyApp}].from(call(Ï:Class(repl.MdocSession::repl.MdocSession.App9::repl.MdocSession.App9.DBConnection, repl.MdocSession::repl.MdocSession.App9::repl.MdocSession.App9.MessageQueueConnection): repl.MdocSession::repl.MdocSession.App9::repl.MdocSession.App9.MyApp)) ((basics.md:252))
// make[{type.repl.MdocSession::repl.MdocSession.App9::repl.MdocSession.App9.MessageQueueConnection}].from(allocate[Î» %0 â cats.effect.IO[+0]](call(Æ:izumi.distage.model.providers.Functoid$$Lambda$20242/2121087834@45c36e86(cats.effect.Sync[=Î» %0 â IO[+0]]): izumi.distage.model.definition.Lifecycle::izumi.distage.model.definition.Lifecycle.FromCats[=Î» %1:0 â IO[+1:0],=MdocSession::App9::MessageQueueConnection]))) ((basics.md:250))
</code></pre>
<p>Will produce the following output:</p>
<pre class="prettyprint"><code class="language-scala">import distage.DIKey

val objectGraphResource = Injector[IO]().produce(module, Roots(root = DIKey[MyApp]))
// objectGraphResource: izumi.distage.model.definition.Lifecycle[IO, izumi.distage.model.Locator] = izumi.distage.model.definition.Lifecycle$$anon$11@25d067ce

objectGraphResource
  .use(_.get[MyApp].run)
  .unsafeRunSync()
// Connecting to Message Queue!
// Connecting to DB!
// Hello World!
// Disconnecting DB
// Disconnecting Message Queue
</code></pre>
<p>Lifecycle management with <code>Lifecycle</code> is also available without an effect type, via <code>Lifecycle.Simple</code> and <code>Lifecycle.Mutable</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Lifecycle, Roots, ModuleDef, Injector}

class Init {
  var initialized = false
}

class InitResource extends Lifecycle.Simple[Init] {
  override def acquire = {
    val init = new Init
    init.initialized = true
    init
  }
  override def release(init: Init) = {
    init.initialized = false
  }
}

val module = new ModuleDef {
  make[Init].fromResource[InitResource]
}
// module: AnyRef with ModuleDef = 
// make[{type.repl.MdocSession::repl.MdocSession.App11::repl.MdocSession.App11.Init}].from(allocate[Î» %0 â 0](call(Ï:Class(): repl.MdocSession::repl.MdocSession.App11::repl.MdocSession.App11.InitResource))) ((basics.md:297))

val closedInit = Injector()
  .produceGet[Init](module)
  .use {
    init =&gt;
      println(init.initialized)
      init
}
// true
// closedInit: izumi.fundamentals.platform.functional.package.Identity[Init] = repl.MdocSession$App11$Init@37621999

println(closedInit.initialized)
// false
</code></pre>
<p><code>Lifecycle</code> forms a monad and has the expected <code>.map</code>, <code>.flatMap</code>, <code>.evalMap</code>, <code>.mapK</code> methods.</p>
<p>You can convert between a <code>Lifecycle</code> and <code>cats.effect.Resource</code> via <code>Lifecycle#toCats</code>/<code>Lifecycle.fromCats</code> methods, and between a <code>Lifecycle</code> and <code>zio.ZManaged</code> via <code>Lifecycle#toZIO</code>/<code>Lifecycle.fromZIO</code> methods.</p>
<h4><a href="#inheritance-helpers" name="inheritance-helpers" class="anchor"><span class="anchor-link"></span></a>Inheritance helpers</h4>
<p>The following helpers allow defining <code>Lifecycle</code> sub-classes using expression-like syntax:</p>
<ul>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle$$Of.html">Lifecycle.Of</a></li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle$$OfInner.html">Lifecycle.OfInner</a></li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle$$OfCats.html">Lifecycle.OfCats</a></li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle$$OfZIO.html">Lifecycle.OfZIO</a></li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle$$LiftF.html">Lifecycle.LiftF</a></li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle$$Make.html">Lifecycle.Make</a></li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle$$Make_.html">Lifecycle.Make_</a></li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle$$MakePair.html">Lifecycle.MakePair</a></li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle$$FromAutoCloseable.html">Lifecycle.FromAutoCloseable</a></li>
</ul>
<p>The main reason to employ them is to workaround a limitation in Scala 2&rsquo;s eta-expansion whereby when converting a method to a function value, Scala would always try to fulfill implicit parameters eagerly instead of making them parameters in the function value, this limitation makes it harder to inject implicits using <code>distage</code>. However, if instead of eta-expanding manually as in <code>make[A].fromResource(A.resource[F] _)</code>, you use <code>distage</code>&rsquo;s type-based constructor syntax: <code>make[A].fromResource[A.Resource[F]]</code>, this limitation is lifted, injecting the implicit parameters of class <code>A.Resource</code> from the object graph instead of summoning them in-place. Therefore, you can convert an expression based resource-constructor such as:</p>
<pre class="prettyprint"><code class="language-scala">import distage.Lifecycle, cats.Monad

class A
object A {
  def resource[F[_]](implicit F: Monad[F]): Lifecycle[F, A] = Lifecycle.pure[F, A](new A)
}
</code></pre>
<p>Into class-based form:</p>
<pre class="prettyprint"><code class="language-scala">import distage.Lifecycle, cats.Monad

class A
object A {
final class Resource[F[_]](implicit F: Monad[F])
  extends Lifecycle.Of(
    Lifecycle.pure[F, A](new A)
  )
}
</code></pre>
<p>And inject successfully using <code>make[A].fromResource[A.Resource[F]]</code> syntax of <a href="/latest/snapshot/api/izumi/distage/model/definition/dsl/ModuleDefDSL.html">ModuleDefDSL</a>.</p>
<p>The following helpers ease defining <code>Lifecycle</code> sub-classes using traditional inheritance where <code>acquire</code>/<code>release</code> parts are defined as methods:</p>
<ul>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle$$Basic.html">Lifecycle.Basic</a></li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle$$Simple.html">Lifecycle.Simple</a></li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle$$Mutable.html">Lifecycle.Mutable</a></li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle$$Self.html">Lifecycle.Self</a></li>
  <li><a href="/latest/snapshot/api/izumi/distage/model/definition/Lifecycle$$SelfNoClose.html">Lifecycle.SelfNoClose</a></li>
</ul>
<h3><a href="#set-bindings" name="set-bindings" class="anchor"><span class="anchor-link"></span></a>Set Bindings</h3>
<p>Set bindings are useful for implementing listeners, plugins, hooks, http routes, healthchecks, migrations, etc. Everywhere where a collection of components is required, a Set Binding is appropriate.</p>
<p>To define a Set binding use <code>.many</code> and <code>.add</code> methods of the <a href="/latest/snapshot/api/izumi/distage/model/definition/ModuleDef.html">ModuleDef</a> DSL.</p>
<p>As an example, we may declare multiple command handlers and use them to interpret user input in a REPLL</p>
<pre class="prettyprint"><code class="language-scala">import distage.ModuleDef

final case class CommandHandler(
  handle: PartialFunction[String, String]
)

val additionHandler = CommandHandler {
  case s&quot;$x + $y&quot; =&gt; s&quot;${x.toInt + y.toInt}&quot;
}
// additionHandler: CommandHandler = CommandHandler(&lt;function1&gt;)

object AdditionModule extends ModuleDef {
  many[CommandHandler]
    .add(additionHandler)
}
</code></pre>
<p>We&rsquo;ve used <code>many</code> method to declare an open <code>Set</code> of command handlers and then added one handler to it. When module definitions are combined, elements for the same type of <code>Set</code> will be merged together into a larger set. You can summon a Set binding by summoning a scala <code>Set</code>, as in <code>Set[CommandHandler]</code>.</p>
<p>Let&rsquo;s define a new module with another handler:</p>
<pre class="prettyprint"><code class="language-scala">val subtractionHandler = CommandHandler { 
  case s&quot;$x - $y&quot; =&gt; s&quot;${x.toInt - y.toInt}&quot; 
}
// subtractionHandler: CommandHandler = CommandHandler(&lt;function1&gt;)

object SubtractionModule extends ModuleDef {  
  many[CommandHandler]
    .add(subtractionHandler)
}
</code></pre>
<p>Now it&rsquo;s the time to define our main flow that exposes all the different command handlers as a command-line application:</p>
<pre class="prettyprint"><code class="language-scala">import distage.Injector

trait App {
  def interpret(input: String): String
}
object App {
  final class Impl(
    handlers: Set[CommandHandler]
  ) extends App {
    override def interpret(input: String): String = {
      handlers.map(_.handle).reduce(_ orElse _).lift(input) match {
        case Some(answer) =&gt; s&quot;ANSWER: $answer&quot;
        case None         =&gt; &quot;?&quot;
      }
    }
  }
}

object AppModule extends ModuleDef {
  // include all the previous module definitions
  include(AdditionModule)
  include(SubtractionModule)
  
  // add a help handler
  many[CommandHandler].add(CommandHandler {
    case &quot;help&quot; =&gt; &quot;Please input an arithmetic expression!&quot; 
  })

  // bind App
  make[App].from[App.Impl]
}

// wire the graph and get the app

val app = Injector().produceGet[App](AppModule).unsafeGet()
// app: App = repl.MdocSession$App15$App$Impl@57abe5b1

// check how it works

app.interpret(&quot;1 + 5&quot;)
// res16: String = &quot;ANSWER: 6&quot;

app.interpret(&quot;7 - 11&quot;)
// res17: String = &quot;ANSWER: -4&quot;

app.interpret(&quot;1 / 3&quot;)
// res18: String = &quot;?&quot;

app.interpret(&quot;help&quot;)
// res19: String = &quot;ANSWER: Please input an arithmetic expression!&quot;
</code></pre>
<p>If we wire the app while excluding <code>SubtractionModule</code> our app will expectedly lose the ability to subtract:</p>
<pre class="prettyprint"><code class="language-scala">Injector().produceRun(AppModule -- SubtractionModule.keys) {
  app: App =&gt;
    app.interpret(&quot;10 - 1&quot;)
}
// res20: String = &quot;?&quot;
</code></pre>
<p>Further reading: the same concept is called <a href="https://github.com/google/guice/wiki/Multibindings">Multibindings</a> in Guice.</p>
<h3><a href="#effect-bindings" name="effect-bindings" class="anchor"><span class="anchor-link"></span></a>Effect Bindings</h3>
<p>Sometimes we want to effectfully create a component, but the resulting component or data does not need to be deallocated. An example might be a global <code>Semaphore</code> to limit the parallelism of the entire application based on configuration, or a test implementation of some service made with <code>Ref</code>s.</p>
<p>In these cases we can use <code>.fromEffect</code> to create a value using an effectful constructor.</p>
<p>Example with a <code>Ref</code>-based Tagless Final <code>KVStore</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Roots, ModuleDef, Injector}
import izumi.functional.bio.{BIOMonadError, BIOPrimitives, F}
import zio.{Task, IO}

trait KVStore[F[_, _]] {
  def get(key: String): F[NoSuchElementException, String]
  def put(key: String, value: String): F[Nothing, Unit]
}

def dummyKVStore[F[+_, +_]: BIOMonadError: BIOPrimitives]: F[Nothing, KVStore[F]] = {
  for {
    ref &lt;- F.mkRef(Map.empty[String, String])
  } yield new KVStore[F] {
    def put(key: String, value: String): F[Nothing, Unit] = {
      ref.update_(_ + (key -&gt; value))
    }
  
    def get(key: String): F[NoSuchElementException, String] = {
      for {
        map &lt;- ref.get
        res &lt;- map.get(key) match {
          case Some(value) =&gt; F.pure(value)
          case None        =&gt; F.fail(new NoSuchElementException(key))
        }
      } yield res
    }
  }
}

def kvStoreModule = new ModuleDef {
  make[KVStore[IO]].fromEffect(dummyKVStore[IO])
}

val io = Injector[Task]()
  .produceRun[String](kvStoreModule) {
    kv: KVStore[IO] =&gt;
      for {
        _    &lt;- kv.put(&quot;apple&quot;, &quot;pie&quot;)
        res1 &lt;- kv.get(&quot;apple&quot;)
        _    &lt;- kv.put(&quot;apple&quot;, &quot;ipad&quot;)
        res2 &lt;- kv.get(&quot;apple&quot;)
      } yield res1 + res2
  }
// io: Task[String] = zio.ZIO$CheckInterrupt@11d8305

zio.Runtime.default.unsafeRun(io)
// res22: String = pieipad
</code></pre>
<p>You need to specify your effect type when constructing <code>Injector</code>, as in <code>Injector[F]()</code>, to use effect bindings in chosen <code>F[_]</code>.</p>
<h3><a href="#zio-has-bindings" name="zio-has-bindings" class="anchor"><span class="anchor-link"></span></a>ZIO Has Bindings</h3>
<p>You can inject into ZIO Environment using <code>make[_].fromHas</code> syntax for <code>ZLayer</code>, <code>ZManaged</code>, <code>ZIO</code> or any <code>F[_, _, _]: BIOLocal</code>:</p>
<pre class="prettyprint"><code class="language-scala">import zio._
import distage._

def zioEnvCtor: URIO[Has[Dep1] with Has[Dep2], X] = ZIO.succeed(X)
def zmanagedEnvCtor: URManaged[Has[Dep1] with Has[Dep2], X] = ZManaged.succeed(X)
def zlayerEnvCtor: URLayer[Has[Dep1] with Has[Dep2], Has[X]] = ZLayer.succeed(X)

def module1 = new ModuleDef {
  make[X].fromHas(zioEnvCtor)
  // or
  make[X].fromHas(zmanagedEnvCtor)
  // or
  make[X].fromHas(zlayerEnvCtor)
}
</code></pre>
<p>You can also mix environment and parameter dependencies at the same time in one constructor:</p>
<pre class="prettyprint"><code class="language-scala">def zioArgEnvCtor(a: Arg1, b: Arg2): URLayer[Has[Dep1], Has[X]] = ZLayer.fromService(dep1 =&gt; X(a, b, dep1))

def module2 = new ModuleDef {
  make[X].fromHas(zioArgEnvCtor _)
}
</code></pre>
<p><code>zio.Has</code> values are derived at compile-time by <a href="/latest/snapshot/api/izumi/distage/constructors/HasConstructor.html">HasConstructor</a> macro and can be summoned at need. </p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{DIKey, ModuleDef, Injector, Functoid, Tag}
import izumi.distage.constructors.TraitConstructor
import zio.console.{putStrLn, Console}
import zio.{UIO, URIO, ZIO, Ref, Task, Has}

trait Hello {
  def hello: UIO[String]
}
trait World {
  def world: UIO[String]
}

// Environment forwarders that allow
// using service functions from everywhere

val hello: URIO[Has[Hello], String] = ZIO.accessM(_.get.hello)
// hello: URIO[Has[Hello], String] = zio.ZIO$Read@5df14d3d

val world: URIO[Has[World], String] = ZIO.accessM(_.get.world)
// world: URIO[Has[World], String] = zio.ZIO$Read@2b16e27c

// service implementations

val makeHello = {
  (for {
    _     &lt;- putStrLn(&quot;Creating Enterprise Hellower...&quot;)
    hello = new Hello { val hello = UIO(&quot;Hello&quot;) }
  } yield hello).toManaged { _ =&gt;
    putStrLn(&quot;Shutting down Enterprise Hellower&quot;)
  }
}
// makeHello: zio.ZManaged[Console, Nothing, AnyRef with Hello{val hello: zio.UIO[String]}] = zio.ZManaged$$anon$2@75cf168d

val makeWorld = {
  for {
    counter &lt;- Ref.make(0)
  } yield new World {
    val world = counter.get.map(c =&gt; if (c &lt; 1) &quot;World&quot; else &quot;THE World&quot;)
  }
}
// makeWorld: ZIO[Any, Nothing, AnyRef with World{val world: zio.ZIO[Any,Nothing,String]}] = zio.ZIO$FlatMap@18a7b69a

// the main function

val turboFunctionalHelloWorld: URIO[Has[Hello] with Has[World] with Has[Console.Service], Unit] = {
  for {
    hello &lt;- hello
    world &lt;- world
    _     &lt;- putStrLn(s&quot;$hello $world&quot;)
  } yield ()
}
// turboFunctionalHelloWorld: URIO[Has[Hello] with Has[World] with Has[Console.Service], Unit] = zio.ZIO$FlatMap@4fe88816

def module = new ModuleDef {
  make[Hello].fromHas(makeHello)
  make[World].fromHas(makeWorld)
  make[Console.Service].fromHas(Console.live)
  make[Unit].fromHas(turboFunctionalHelloWorld)
}

val main = Injector[Task]()
  .produceRun[Unit](module)((_: Unit) =&gt; Task.unit)
// main: Task[Unit] = zio.ZIO$CheckInterrupt@53f19695

zio.Runtime.default.unsafeRun(main)
// Creating Enterprise Hellower...
// Hello World
// Shutting down Enterprise Hellower
</code></pre>
<h4><a href="#converting-between-zio-environment-dependencies-and-parameters" name="converting-between-zio-environment-dependencies-and-parameters" class="anchor"><span class="anchor-link"></span></a>Converting between ZIO environment dependencies and parameters</h4>
<p>Any ZIO Service that requires an environment can be turned into a service without an environment dependency by providing the dependency in each method. This pattern can be generalized by implementing an instance of <code>cats.Contravariant</code> (or <code>cats.tagless.FunctorK</code>) for your services and using it to turn environment dependencies into constructor parameters â that way ZIO Environment can be used uniformly for declaration of dependencies, but the dependencies used inside the service do not leak to other services calling it. Details: <a href="https://gitter.im/ZIO/Core?at=5dbb06a86570b076740f6db2">https://gitter.im/ZIO/Core?at=5dbb06a86570b076740f6db2</a></p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import cats.Contravariant
import distage.{Roots, Injector, ModuleDef, Functoid, Tag, TagK, HasConstructor}
import zio.{Task, UIO, URIO, ZIO, Has}

trait Dependee[-R] {
  def x(y: String): URIO[R, Int]
}
trait Depender[-R] {
  def y: URIO[R, String]
}
implicit val contra1: Contravariant[Dependee] = new Contravariant[Dependee] {
  def contramap[A, B](fa: Dependee[A])(f: B =&gt; A): Dependee[B] = new Dependee[B] { def x(y: String) = fa.x(y).provideSome(f) }
}
// contra1: Contravariant[Dependee] = repl.MdocSession$App26$$anon$15@5e878918
implicit val contra2: Contravariant[Depender] = new Contravariant[Depender] {
  def contramap[A, B](fa: Depender[A])(f: B =&gt; A): Depender[B] = new Depender[B] { def y = fa.y.provideSome(f) }
}
// contra2: Contravariant[Depender] = repl.MdocSession$App26$$anon$17@7bb1e734

type DependeeR = Has[Dependee[Any]]
type DependerR = Has[Depender[Any]]
object dependee extends Dependee[DependeeR] { def x(y: String) = ZIO.accessM(_.get.x(y)) }
object depender extends Depender[DependerR] { def y            = ZIO.accessM(_.get.y) }

// cycle
object dependerImpl extends Depender[DependeeR] {
  def y: URIO[DependeeR, String] = dependee.x(&quot;hello&quot;).map(_.toString)
}
object dependeeImpl extends Dependee[DependerR] {
  def x(y: String): URIO[DependerR, Int] = {
    if (y == &quot;hello&quot;) UIO(5) 
    else depender.y.map(y.length + _.length)
  }
}

/** Fulfill the environment dependencies of a service from the object graph */
def fullfill[R: Tag: HasConstructor, M[_]: TagK: Contravariant](service: M[R]): Functoid[M[Any]] = {
  HasConstructor[R]
    .map(depsCakeR =&gt; Contravariant[M].contramap(service)(_ =&gt; depsCakeR))
}

def module = new ModuleDef {
  make[Depender[Any]].from(fullfill(dependerImpl))
  make[Dependee[Any]].from(fullfill(dependeeImpl))
}

Injector()
  .produceRun(module) {
    HasConstructor[DependeeR].map {
      (for {
        r &lt;- dependee.x(&quot;zxc&quot;)
        _ &lt;- Task(println(s&quot;result: $r&quot;))
      } yield ()).provide(_)
    }
  }.fold(_ =&gt; 1, _ =&gt; 0)
// res27: URIO[Any, Int] = &lt;function1&gt;
</code></pre>
<h3><a href="#auto-traits" name="auto-traits" class="anchor"><span class="anchor-link"></span></a>Auto-Traits</h3>
<p>distage can instantiate traits and structural types. All unimplemented fields in a trait, or a refinement are filled in from the object graph.</p>
<p>Trait implementations are derived at compile-time by <a href="/latest/snapshot/api/izumi/distage/constructors/TraitConstructor.html">TraitConstructor</a> macro and can be summoned at need. </p>
<p>If a suitable trait is specified as an implementation class for a binding, <code>TraitConstructor</code> will be used automatically:</p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{ModuleDef, Id, Injector}

trait Trait1 {
  def a: Int @Id(&quot;a&quot;)
}
trait Trait2 {
  def b: Int @Id(&quot;b&quot;)
}

/** All methods in this trait are implemented,
  * so a constructor for it will be generated
  * even though it&#39;s not a class */
trait Pluser {
  def plus(a: Int, b: Int) = a + b
}

trait PlusedInt {
  def result(): Int
}
object PlusedInt {

  /**
    * Besides the dependency on `Pluser`,
    * this class defines 2 more dependencies
    * to be injected from the object graph:
    *
    * `def a: Int @Id(&quot;a&quot;)` and
    * `def b: Int @Id(&quot;b&quot;)`
    * 
    * When an abstract type is declared as an implementation,
    * its no-argument abstract defs &amp; vals are considered as
    * dependency parameters by TraitConstructor. (empty-parens and
    * parameterized methods are not considered parameters)
    *
    * Here, using an abstract class directly as an implementation
    * lets us avoid writing a lengthier constructor, like this one:
    * 
    * {{{
    *   final class Impl(
    *     pluser: Pluser,
    *     override val a: Int @Id(&quot;a&quot;),
    *     override val b: Int @Id(&quot;b&quot;),
    *   ) extends PlusedInt with Trait1 with Trait2
    * }}}
    */
  abstract class Impl(
    pluser: Pluser
  ) extends PlusedInt
    with Trait1
    with Trait2 {
    override def result(): Int = {
      pluser.plus(a, b)
    }
  }

}

Injector()
  .produceRun(new ModuleDef {
    make[Int].named(&quot;a&quot;).from(1)
    make[Int].named(&quot;b&quot;).from(2)
    make[Pluser]
    make[PlusedInt].from[PlusedInt.Impl]
  }) {
    plusedInt: PlusedInt =&gt; 
      plusedInt.result
  }
// res29: izumi.fundamentals.platform.functional.package.Identity[Int] = 3
</code></pre>
<p>Abstract classes or traits without obvious concrete subclasses may hinder the readability of a codebase, if you still want to use them to avoid writing the full constructor, you may use an optional <a href="/latest/snapshot/api/izumi/distage/model/definition/impl.html">@impl</a> documenting annotation to aid the reader in understanding your intention.</p>
<pre class="prettyprint"><code class="language-scala">import distage.impl

@impl abstract class Impl(
  pluser: Pluser
) extends PlusedInt
</code></pre>
<h3><a href="#auto-factories" name="auto-factories" class="anchor"><span class="anchor-link"></span></a>Auto-Factories</h3>
<p><code>distage</code> can instantiate &lsquo;factory&rsquo; classes from suitable traits. This feature is especially useful with <code>Akka</code>. All unimplemented methods <em>with parameters</em> in a trait will be filled by factory methods:</p>
<p>Given a class <code>ActorFactory</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.ModuleDef
import java.util.UUID

class SessionStorage

class UserActor(sessionId: UUID, sessionStorage: SessionStorage)

trait ActorFactory {
  // UserActor will be created as follows:
  //   sessionId argument is provided by the user
  //   sessionStorage argument is wired from the object graph
  def createActor(sessionId: UUID): UserActor
}
</code></pre>
<p>And a binding of <code>ActorFactory</code> <em>without</em> an implementation</p>
<pre class="prettyprint"><code class="language-scala">class ActorModule extends ModuleDef {
  make[ActorFactory]
}
</code></pre>
<p><code>distage</code> will derive and bind the following implementation for <code>ActorFactory</code>:</p>
<pre class="prettyprint"><code class="language-scala">class ActorFactoryImpl(sessionStorage: SessionStorage) extends ActorFactory {
  override def createActor(sessionId: UUID): UserActor = {
    new UserActor(sessionId, sessionStorage)
  }
}
</code></pre>
<p><code>@With</code> annotation can be used to specify the implementation class, to avoid leaking the implementation type in factory method result:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{ModuleDef, Injector, With}

trait Actor { 
  def receive(msg: Any): Unit
}

object Actor {
  trait Factory {
    def newActor(id: String): Actor @With[Actor.Impl]
  }

  final class Impl(id: String, config: Actor.Configuration) extends Actor {
    def receive(msg: Any) = {
      val response = s&quot;Actor `$id` received a message: $msg&quot;
      println(if (config.allCaps) response.toUpperCase else response)
    }
  }

  final case class Configuration(allCaps: Boolean)
}

val factoryModule = new ModuleDef {
  make[Actor.Factory]
  make[Actor.Configuration].from(Actor.Configuration(allCaps = false))
}
// factoryModule: AnyRef with ModuleDef = 
// make[{type.repl.MdocSession::repl.MdocSession.App30::repl.MdocSession.App30.Actor::repl.MdocSession.App30.Actor.Configuration}].from(call(Æ:&lt;function0&gt;(): repl.MdocSession::repl.MdocSession.App30::repl.MdocSession.App30.Actor::repl.MdocSession.App30.Actor.Configuration)) ((basics.md:916))
// make[{type.repl.MdocSession::repl.MdocSession.App30::repl.MdocSession.App30.Actor::repl.MdocSession.App30.Actor.Factory}].from(call(Ï:Factory(repl.MdocSession::repl.MdocSession.App30::repl.MdocSession.App30.Actor::repl.MdocSession.App30.Actor.Configuration): repl.MdocSession::repl.MdocSession.App30::repl.MdocSession.App30.Actor::repl.MdocSession.App30.Actor.Factory)) ((basics.md:915))

Injector()
  .produceGet[Actor.Factory](factoryModule)
  .use(_.newActor(&quot;Martin Odersky&quot;).receive(&quot;ping&quot;))
// Actor `Martin Odersky` received a message: ping
// res31: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()
</code></pre>
<p>You can use this feature to concisely provide non-Singleton semantics for some of your components.</p>
<p>Factory implementations are derived at compile-time by <a href="/latest/snapshot/api/izumi/distage/constructors/FactoryConstructor.html">FactoryConstructor</a> macro and can be summoned at need.</p>
<h3><a href="#tagless-final-style" name="tagless-final-style" class="anchor"><span class="anchor-link"></span></a>Tagless Final Style</h3>
<p>Tagless Final is one of the popular patterns for structuring purely-functional applications.</p>
<p>Brief introduction to tagless final:</p>
<ul>
  <li><a href="https://medium.com/@calvin.l.fer/deferring-commitments-tagless-final-704d768f15cb">Deferring Commitments: Tagless Final</a></li>
  <li><a href="https://www.beyondthelines.net/programming/introduction-to-tagless-final/">Introduction to Tagless Final</a></li>
</ul>
<p>Advantages of <code>distage</code> as a driver for TF compared to implicits:</p>
<ul>
  <li>easy explicit overrides</li>
  <li>easy <a href="basics.html#effect-bindings">effectful instantiation</a> and <a href="basics.html#resource-bindings-lifecycle">resource management</a></li>
  <li>extremely easy &amp; scalable <a href="distage-testkit.html#testkit">test</a> context setup due to the above</li>
  <li>multiple different implementations for a type using disambiguation by <code>@Id</code></li>
</ul>
<p>For example, let&rsquo;s take <a href="http://frees.io/docs/core/handlers/#tagless-interpretation">freestyle&rsquo;s tagless example</a> and make it safer and more flexible by replacing dependencies on global <code>import</code>ed implementations from with explicit modules.</p>
<p>First, the program we want to write:</p>
<pre class="prettyprint"><code class="language-scala">import cats.Monad
import cats.effect.{Sync, IO}
import cats.syntax.all._
import distage.{Roots, Module, ModuleDef, Injector, Tag, TagK, TagKK}

trait Validation[F[_]] {
  def minSize(s: String, n: Int): F[Boolean]
  def hasNumber(s: String): F[Boolean]
}
def Validation[F[_]: Validation]: Validation[F] = implicitly

trait Interaction[F[_]] {
  def tell(msg: String): F[Unit]
  def ask(prompt: String): F[String]
}
def Interaction[F[_]: Interaction]: Interaction[F] = implicitly

class TaglessProgram[F[_]: Monad: Validation: Interaction] {
  def program: F[Unit] = for {
    userInput &lt;- Interaction[F].ask(&quot;Give me something with at least 3 chars and a number on it&quot;)
    valid     &lt;- (Validation[F].minSize(userInput, 3), Validation[F].hasNumber(userInput)).mapN(_ &amp;&amp; _)
    _         &lt;- if (valid) Interaction[F].tell(&quot;awesomesauce!&quot;)
                 else       Interaction[F].tell(s&quot;$userInput is not valid&quot;)
  } yield ()
}

def ProgramModule[F[_]: TagK: Monad] = new ModuleDef {
  make[TaglessProgram[F]]
  addImplicit[Monad[F]]
}
</code></pre>
<p><a href="/latest/snapshot/api/izumi/reflect/TagK.html">TagK</a> is <code>distage</code>&rsquo;s analogue of <code>TypeTag</code> for higher-kinded types such as <code>F[_]</code>, it allows preserving type-information at runtime for type parameters. You&rsquo;ll need to add a <a href="/latest/snapshot/api/izumi/reflect/TagK.html">TagK</a> context bound to create a module parameterized by an abstract <code>F[_]</code>. To parameterize by non-higher-kinded types, use just <a href="/latest/snapshot/api/izumi/reflect/Tag.html">Tag</a>.</p>
<p>Now the interpreters for <code>Validation</code> and <code>Interaction</code>:</p>
<pre class="prettyprint"><code class="language-scala">final class SyncValidation[F[_]](implicit F: Sync[F]) extends Validation[F] {
  def minSize(s: String, n: Int): F[Boolean] = F.delay(s.size &gt;= n)
  def hasNumber(s: String): F[Boolean]       = F.delay(s.exists(c =&gt; &quot;0123456789&quot;.contains(c)))
}
  
final class SyncInteraction[F[_]](implicit F: Sync[F]) extends Interaction[F] {
  def tell(s: String): F[Unit]  = F.delay(println(s))
  def ask(s: String): F[String] = F.delay(&quot;This could have been user input 1&quot;)
}

def SyncInterpreters[F[_]: TagK: Sync] = {
  new ModuleDef {
    make[Validation[F]].from[SyncValidation[F]]
    make[Interaction[F]].from[SyncInteraction[F]]
    addImplicit[Sync[F]]
  }
}

// combine all modules

def SyncProgram[F[_]: TagK: Sync] = ProgramModule[F] ++ SyncInterpreters[F]

// create object graph Resource

val objectsResource = Injector[IO]().produce(SyncProgram[IO], Roots.Everything)
// objectsResource: izumi.distage.model.definition.Lifecycle[IO, izumi.distage.model.Locator] = izumi.distage.model.definition.Lifecycle$$anon$11@7092686c

// run

objectsResource.use(_.get[TaglessProgram[IO]].program).unsafeRunSync()
// awesomesauce!
</code></pre>
<p>The program module is polymorphic over effect type. It can be instantiated by a different effect:</p>
<pre class="prettyprint"><code class="language-scala">import zio.interop.catz._
import zio.Task

val ZIOProgram = ProgramModule[Task] ++ SyncInterpreters[Task]
// ZIOProgram: Module = 
// make[{type.cats.effect.Sync[=Î» %0 â ZIO[-Any,+Throwable,+0]]}].from(value(zio.interop.CatsConcurrent@637f2b4: cats.effect.Sync[=Î» %0 â ZIO[-Any,+Throwable,+0]])) ((basics.md:996))
// make[{type.repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.Validation[=Î» %0 â ZIO[-Any,+Throwable,+0]]}].from(call(Ï:Class(cats.effect.Sync[=Î» %0 â ZIO[-Any,+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.SyncValidation[=Î» %0 â ZIO[-Any,+Throwable,+0]])) ((basics.md:994))
// make[{type.repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.Interaction[=Î» %0 â ZIO[-Any,+Throwable,+0]]}].from(call(Ï:Class(cats.effect.Sync[=Î» %0 â ZIO[-Any,+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.SyncInteraction[=Î» %0 â ZIO[-Any,+Throwable,+0]])) ((basics.md:995))
// make[{type.repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.TaglessProgram[=Î» %0 â ZIO[-Any,+Throwable,+0]]}].from(call(Ï:Class(cats.Monad[=Î» %0 â ZIO[-Any,+Throwable,+0]], repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.Validation[=Î» %0 â ZIO[-Any,+Throwable,+0]], repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.Interaction[=Î» %0 â ZIO[-Any,+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.TaglessProgram[=Î» %0 â ZIO[-Any,+Throwable,+0]])) ((basics.md:972))
// make[{type.cats.Monad[=Î» %0 â ZIO[-Any,+Throwable,+0]]}].from(value(zio.interop.CatsConcurrent@637f2b4: cats.Monad[=Î» %0 â ZIO[-Any,+Throwable,+0]])) ((basics.md:973))
</code></pre>
<p>We may even choose different interpreters at runtime:</p>
<pre class="prettyprint"><code class="language-scala">import zio.RIO
import zio.console.{Console, getStrLn, putStrLn}
import distage.Activation

object RealInteractionZIO extends Interaction[RIO[Console, ?]] {
  def tell(s: String): RIO[Console, Unit]  = putStrLn(s)
  def ask(s: String): RIO[Console, String] = putStrLn(s) *&gt; getStrLn
}

val RealInterpretersZIO = {
  SyncInterpreters[RIO[Console, ?]] overriddenBy new ModuleDef {
    make[Interaction[RIO[Console, ?]]].from(RealInteractionZIO)
  }
}
// RealInterpretersZIO: Module = 
// make[{type.repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.Validation[=Î» %0 â ZIO[-Has[=package::Console::Service],+Throwable,+0]]}].from(call(Ï:Class(cats.effect.Sync[=Î» %0 â ZIO[-Has[=package::Console::Service],+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.SyncValidation[=Î» %0 â ZIO[-Has[=package::Console::Service],+Throwable,+0]])) ((basics.md:994))
// make[{type.repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.Interaction[=Î» %1:0 â ZIO[-Has[=package::Console::Service],+Throwable,+1:0]]}].from(call(Æ:&lt;function0&gt;(): repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.RealInteractionZIO)) ((basics.md:1042))
// make[{type.cats.effect.Sync[=Î» %0 â ZIO[-Has[=package::Console::Service],+Throwable,+0]]}].from(value(zio.interop.CatsConcurrent@637f2b4: cats.effect.Sync[=Î» %0 â ZIO[-Has[=package::Console::Service],+Throwable,+0]])) ((basics.md:996))

def chooseInterpreters(isDummy: Boolean) = {
  val interpreters = if (isDummy) SyncInterpreters[RIO[Console, ?]]
                     else         RealInterpretersZIO
  val module = ProgramModule[RIO[Console, ?]] ++ interpreters
  
  Injector[RIO[Console, ?]]()
    .produceGet[TaglessProgram[RIO[Console, ?]]](module, Activation.empty)
}

// execute

chooseInterpreters(true)
// res34: izumi.distage.model.definition.Lifecycle[zio.ZIO[zio.Has[Console.Service], Throwable, Î²$5$], TaglessProgram[zio.ZIO[zio.Has[Console.Service], Throwable, Î²$6$]]] = izumi.distage.model.definition.Lifecycle$$anon$10@395948b2
</code></pre>
<p>Modules can be polymorphic over arbitrary kinds - use <code>TagKK</code> to abstract over bifunctors:</p>
<pre class="prettyprint"><code class="language-scala">class BifunctorIOModule[F[_, _]: TagKK] extends ModuleDef
</code></pre>
<p>Or use <code>Tag.auto.T</code> to abstract over any kind:</p>
<pre class="prettyprint"><code class="language-scala">class MonadTransModule[F[_[_], _]: Tag.auto.T] extends ModuleDef
</code></pre>
<pre class="prettyprint"><code class="language-scala">class TrifunctorModule[F[_, _, _]: Tag.auto.T] extends ModuleDef
</code></pre>
<pre class="prettyprint"><code class="language-scala">class EldritchModule[F[+_, -_[_, _], _[_[_, _], _], _]: Tag.auto.T] extends ModuleDef
</code></pre>
<p>consult <a href="/latest/snapshot/api/izumi/fundamentals/reflection/WithTags.html#HKTag">HKTag</a> docs for more details.</p>
<h3><a href="#cats-zio-integration" name="cats-zio-integration" class="anchor"><span class="anchor-link"></span></a>Cats &amp; ZIO Integration</h3>
<p>Cats &amp; ZIO instances and syntax are available automatically in <code>distage-core</code>, without wildcard imports, if your project depends on <code>cats-core</code>, <code>cats-effect</code> or <code>zio</code>. However, distage <em>won&rsquo;t</em> bring in <code>cats</code> or <code>zio</code> as dependencies if you don&rsquo;t already depend on them. (see <a href="https://blog.7mind.io/no-more-orphans.html">No More Orphans</a> blog post for details on how that works)</p>
<p><a href="basics.html#resource-bindings-lifecycle">Cats Resource &amp; ZIO ZManaged Bindings</a> also work out of the box without any magic imports.</p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import cats.syntax.semigroup._
import cats.effect.{ExitCode, IO, IOApp}
import distage.{DIKey, Roots, Injector, Activation}

trait AppEntrypoint {
  def run: IO[Unit]
}

object Main extends App {
  def run(args: List[String]): IO[ExitCode] = {
    
    // `distage.Module` has a Monoid instance

    val myModules = ProgramModule[IO] |+| SyncInterpreters[IO]

    val plan = Injector().plan(myModules, Activation.empty, Roots(DIKey[AppEntrypoint]))

    for {
      // resolveImportsF can effectfully add missing instances to an existing plan
      // (You can also create instances effectfully inside `ModuleDef` via `make[_].fromEffect` bindings)

      newPlan &lt;- plan.resolveImportsF[IO] {
        case i if i.target == DIKey[DBConnection] =&gt;
           DBConnection.create[IO]
      }

      // Effects used in Resource and Effect Bindings 
      // should match the effect `F[_]` in `Injector[F]()`

      _ &lt;- Injector[IO]().produce(newPlan).use {
        classes =&gt;
          classes.get[AppEntrypoint].run
      }
    } yield ExitCode.Success
  }
}
</code></pre>
</div>
<div>
<a href="https://github.com/7mind/izumi/tree/master/doc/microsite/target/mdoc/distage/basics.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
0.11.0*
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../distage/index.html" title="distage: Staged Dependency Injection" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
distage: Staged Dependency Injection
</span>
</div>
</a>
<a href="../distage/advanced-features.html" title="Advanced Features" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Advanced Features
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
7mind.io
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
