{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Izumi Project"},{"location":"/index.html#izumi-project","text":"Izumi (*jp. 泉水, spring*) is an ecosystem of independent libraries and frameworks allowing you to significantly increase productivity of your Scala development.\nincluding the following components:\ndistage – Transparent and debuggable Dependency Injection framework for pure FP Scala, distage-testkit – Hyper-pragmatic pure FP Test framework. Shares heavy resources globally across all test suites; lets you easily swap implementations of component; uses your effect type for parallelism. distage-framework-docker – A distage extension for using docker containers in tests or for local application runs, comes with example Postgres, Cassandra, Kafka & DynamoDB containers. LogStage – Automatic structural logs from Scala string interpolations, BIO - A typeclass hierarchy for tagless final style with Bifunctor and Trifunctor effect types. Focused on ergonomics and ease of use with zero boilerplate. izumi-reflect (moved to zio/izumi-reflect) - Portable, lightweight and kind-polymorphic alternative to scala-reflect’s Typetag for Scala, Scala.js, Scala Native and (soon) Dotty IdeaLingua (moved to 7mind/idealingua-v1) – API Definition, Data Modeling and RPC language, optimized for fast prototyping – like gRPC or Swagger, but with a human face. Generates RPC servers and clients for Go, TypeScript, C# and Scala, Opinionated SBT plugins (moved to 7mind/sbtgen) – Reduces verbosity of SBT builds and introduces new features – inter-project shared test scopes and BOM plugins (from Maven) Percept-Plan-Execute-Repeat (PPER) – A pattern that enables modeling very complex domains and orchestrate deadly complex processes a lot easier than you’re used to.","title":"Izumi Project"},{"location":"/index.html#dependencies","text":"To use, add the following into project/build.sbt,\nlibraryDependencies ++= Seq(\n  // distage core library\n  \"io.7mind.izumi\" %% \"distage-core\" % \"0.10.16\",\n  // distage-testkit for ScalaTest\n  \"io.7mind.izumi\" %% \"distage-testkit-scalatest\" % \"0.10.16\" % Test,\n  // distage-framework: Roles, Entrypoints, Effect modules\n  \"io.7mind.izumi\" %% \"distage-framework\" % \"0.10.16\",\n  // Typesafe Config support\n  \"io.7mind.izumi\" %% \"distage-extension-config\" % \"0.10.16\",\n  // Classpath discovery support\n  \"io.7mind.izumi\" %% \"distage-extension-plugins\" % \"0.10.16\",\n  // LogStage integration with DIStage\n  \"io.7mind.izumi\" %% \"distage-extension-logstage\" % \"0.10.16\",\n  \n  // LogStage core library\n  \"io.7mind.izumi\" %% \"logstage-core\" % \"0.10.16\",\n  // Write logs as JSON\n  \"io.7mind.izumi\" %% \"logstage-rendering-circe \" % \"0.10.16\",\n  // Route Slf4J logs to LogStage\n  \"io.7mind.izumi\" %% \"logstage-adapter-slf4j \" % \"0.10.16\",\n  // Route LogStage logs to Slf4J\n  \"io.7mind.izumi\" %% \"logstage-sink-slf4j \" % \"0.10.16\",\n\n)","title":"Dependencies"},{"location":"/index.html#development","text":"GitHub","title":"Development"},{"location":"/index.html#documentation","text":"Scaladoc Documentation SNAPSHOT documentation","title":"Documentation"},{"location":"/index.html#further-reading","text":"Example projects:\nDIStage Example Project Idealingua Example Project with TypeScript and Scala\nSupport Chats:\nIzumi on Gitter Izumi User Group [RU] on Telegram Izumi User Group [EN] on Telegram\nSlides:\nHyper-pragmatic Pure FP Testing with distage-testkit distage: Staged Dependency Injection logstage: Zero-cost Structured Logging More slides\nVideos:\nHyper-pragmatic Pure FP Testing with distage-testkit, Functional Scala, London Livecoding: DIStage & Bifunctor Tagless Final on Youtube","title":"Further reading"},{"location":"/index.html#credits","text":"YourKit supports open source projects with innovative and intelligent tools for monitoring and profiling Java and .NET applications. YourKit is the creator of YourKit Java Profiler YourKit .NET Profiler and YourKit YouMonitor.","title":"Credits"},{"location":"/distage/index.html","text":"","title":"distage: Staged Dependency Injection"},{"location":"/distage/index.html#distage-staged-dependency-injection","text":"distage is a pragmatic module system for FP Scala & Scala.js. It combines simplicity and expressiveness of pure FP with the flexibility and extreme late-binding, traditionally associated with object-oriented dependency injection frameworks, such as Guice.\ndistage is suitable for wiring Tagless Final Style, ZIO Environment style and ZLayer-based applications, and imperative Scala style applications.","title":"distage: Staged Dependency Injection"},{"location":"/distage/index.html#why-distage-","text":"Faster applications and tests: distage guarantees that no unnecessary instantiations will happen during your tests or application startup. Quick failure detection: distage performs all the integration checks for your application and tests even before any instantiations happened. Simple tests: distage eliminates all the hard work of setting up your test environments, especially configurable ones. Better integration tests: distage-testkit allows you to reuse expensive resources (like database connections and docker containers) across multiple integration tests, gaining performance and without sacrificing correctness. Simple development workflow: distage-framework allows you to develop Role-Based Applications, a fusion of Microservices and Monoliths, letting you run all your services in one process for development purposes (and even switch to mock implementations with a single commandline argument). Fast compile times and low mental overhead: Unlike fully compile-time DIs, distage does not impose a compile time penalty. distage extensions are simple to write and do not require type-level programming. Simple debugging: distage provides you important insights about your application and allows you to introspect and modify it on the fly, before any instantiations happen. High Correctness: distage supports resources and lifecycle natively and guarantees proper cleanups even when something went wrong. No reflection: distage generates constructors and type information at compile-time and does not use Scala reflection. As such, it’s compatible with Graal Native Image and Scala.js. Non-invasive: distage is designed to not impact the way your Scala code is written, it just removes all the initialization boilerplate. You don’t need to learn magic tricks to write components in a distage application.\ndistage is recommended by industry leaders:\nGiven its native support for type classes and higher-kinded types – both features indispensable to functional programming – distage is one of the leading dependency injection libraries out there. Bonus points for being built by a wicked-smart team that contributes to ZIO! -– John A. De Goes","title":"Why distage?"},{"location":"/distage/index.html#faq","text":"Q: How to pronounce distage?\nA: ‘Dee-stage’\nQ: Isn’t it unsafe to use runtime dependency injection?\nA: distage is split into two stages, first a wiring plan is calculated, only afterwards it is executed. Because of this, you can test the Plan for errors very fast, without executing any effects of your wiring – if tests pass, the wiring will succeed at runtime. Testing can also be performed at compile-time – distage-framework module a few experimental macros for aborting compilation on planning errors.\nQ: How do I switch between production and test implementations of components?\nA: Use Activation Axis","title":"FAQ"},{"location":"/distage/index.html#documentation","text":"Basics Advanced features Debugging distage-framework distage-framework-docker distage-testkit Syntax summary","title":"Documentation"},{"location":"/distage/index.html#further-reading","text":"Example projects:\nDIStage Example Project Idealingua Example Project with TypeScript and Scala\nSupport Chats:\nIzumi on Gitter Izumi User Group [RU] on Telegram Izumi User Group [EN] on Telegram\nSlides:\nHyper-pragmatic Pure FP Testing with distage-testkit distage: Staged Dependency Injection logstage: Zero-cost Structured Logging More slides\nVideos:\nHyper-pragmatic Pure FP Testing with distage-testkit, Functional Scala, London Livecoding: DIStage & Bifunctor Tagless Final on Youtube","title":"Further reading"},{"location":"/distage/basics.html","text":"","title":"Basics"},{"location":"/distage/basics.html#basics","text":"Quick Start Activation Axis Multi-dimensionality Resource Bindings, Lifecycle Set Bindings Effect Bindings ZIO Has Bindings Converting between ZIO environment dependencies and parameters Auto-Traits Auto-Factories Tagless Final Style Cats & ZIO Integration","title":"Basics"},{"location":"/distage/basics.html#quick-start","text":"Suppose we have an abstract Greeter component and some other components that depend on it:\nimport distage.{ModuleDef, Injector, Roots}\n\ntrait Greeter {\n  def hello(name: String): Unit\n}\n\nfinal class PrintGreeter extends Greeter {\n  override def hello(name: String) = println(s\"Hello $name!\") \n}\n\ntrait Byer {\n  def bye(name: String): Unit\n}\n\nfinal class PrintByer extends Byer {  \n  override def bye(name: String) = println(s\"Bye $name!\")\n}\n\nfinal class HelloByeApp(greeter: Greeter, byer: Byer) {\n  def run(): Unit = {\n    println(\"What's your name?\")\n    val name = readLine()\n    \n    greeter.hello(name)\n    byer.bye(name)\n  }\n}\nTo actually run the HelloByeApp, we have to wire implementations of Greeter and Byer into it. We will not do it directly. First we’ll only declare the component interfaces we have and the implementations we want for them:\nval HelloByeModule = new ModuleDef {\n  make[Greeter].from[PrintGreeter]\n  make[Byer].from[PrintByer]\n  make[HelloByeApp] // `.from` is not required for concrete classes \n}\n// HelloByeModule: AnyRef with ModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer}].from(call(Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintByer)) ((basics.md:67))\n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.HelloByeApp}].from(call(Class(repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter, repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.HelloByeApp)) ((basics.md:68))\n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintGreeter)) ((basics.md:66))\nModuleDef merely contains a description of the desired object graph, let’s transform that high-level description into an actionable series of steps - an OrderedPlan, a datatype we can inspect, test or verify at compile-time – without actually creating any objects or executing any effects.\nval plan = Injector().plan(HelloByeModule, Roots.Everything)\n// plan: izumi.distage.model.plan.OrderedPlan = \n// {type.Activation} (InjectorDefaultImpl.scala:67) := value izumi.distage.model.definition.Activation#-1609326920\n// {type.MdocSession::App0::Byer} (basics.md:67) := call(Class(): MdocSession::App0::PrintByer) {}\n// {type.InjectorFactory} (InjectorDefaultImpl.scala:65) := value distage.Injector$#1884454729\n// {type.MdocSession::App0::Greeter} (basics.md:66) := call(Class(): MdocSession::App0::PrintGreeter) {}\n// {type.BootstrapModule} (InjectorDefaultImpl.scala:66) := value izumi.distage.model.definition.BootstrapModule$$anon$1#1250235420\n// {type.PlannerInput} (InjectorDefaultImpl.scala:64) := value izumi.distage.model.PlannerInput#303061989\n// {type.Bootloader} (InjectorDefaultImpl.scala:68) := call(Class(BootstrapModule, Activation, PlannerInput, InjectorFactory): Bootloader) {\n//   arg bootstrapModule: BootstrapModule = lookup({type.BootstrapModule})\n//   arg activation: Activation = lookup({type.Activation})\n//   arg input: PlannerInput = lookup({type.PlannerInput})\n//   arg injectorFactory: InjectorFactory = lookup({type.InjectorFactory})\n// }\n// {type.MdocSession::App0::HelloByeApp} (basics.md:68) := call(Class(MdocSession::App0::Greeter, MdocSession::App0::Byer): MdocSession::App0::HelloByeApp) {\n//   arg greeter: MdocSession::App0::Greeter = lookup({type.MdocSession::App0::Greeter})\n//   arg byer: MdocSession::App0::Byer = lookup({type.MdocSession::App0::Byer})\n// }\nThe series of steps must be executed to produce the object graph. Injector.produce will interpret the steps into a Resource value, that holds the lifecycle of the object graph:\n// Interpret into DIResource\n\nval resource = Injector().produce(plan)\n// resource: izumi.distage.model.definition.DIResource.DIResourceBase[izumi.fundamentals.platform.functional.package.Identity, izumi.distage.model.Locator] = izumi.distage.model.definition.DIResource$$anon$11@5a746674\n\n// Use the object graph:\n// After `.use` exits, all objects will be deallocated,\n// and all allocated resources will be freed.\n\nresource.use {\n  objects =>\n    objects.get[HelloByeApp].run()\n}\n// What's your name?\n// > izumi\n// Hello izumi!\n// Bye izumi!\n// res1: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\ndistage always creates components exactly once, even if multiple other objects depend on them. There is only a “Singleton” scope. It’s impossible to create non-singletons in distage. If you need multiple singleton instances of the same type, you can create named instances and disambiguate between them using @Id annotation.\nimport distage.Id\n\nnew ModuleDef {\n  make[Byer].named(\"byer-1\").from[PrintByer]\n  make[Byer].named(\"byer-2\").from {\n    otherByer: Byer @Id(\"byer-1\") =>\n      new Byer {\n        def bye(name: String) = otherByer.bye(s\"NOT-$name\")\n      }\n  }\n}\n// res2: AnyRef with ModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer@byer-1}].from(call(Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintByer)) ((basics.md:97))\n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer@byer-2}].from(call(<function1>(repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer)) ((basics.md:98))\nYou can abstract over annotations using type aliases or string constants:\nobject Ids {\n  final val byer1Id = \"byer-1\"\n  type Byer1 = Byer @Id(byer1Id)\n}\nTo create non-singleton components you must use explicit factory classes. You can use Auto-Factories implementations for these factories.","title":"Quick Start"},{"location":"/distage/basics.html#activation-axis","text":"You can choose between different implementations of a component using Axis tags:\nimport distage.{Axis, Activation, ModuleDef, Injector, Roots}\n\nclass AllCapsGreeter extends Greeter {\n  def hello(name: String) = println(s\"HELLO ${name.toUpperCase}\")\n}\n\n// declare the configuration axis for our components\n\nobject Style extends Axis {\n  case object AllCaps extends AxisValueDef\n  case object Normal extends AxisValueDef\n}\n\n// Declare a module with several implementations of Greeter\n// but in different environments\n\nval TwoImplsModule = new ModuleDef {\n  make[Greeter].tagged(Style.Normal)\n    .from[PrintGreeter]\n  \n  make[Greeter].tagged(Style.AllCaps)\n    .from[AllCapsGreeter]\n}\n// TwoImplsModule: AnyRef with ModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.AllCapsGreeter)).tagged(Set(AxisTag(style:allcaps))) ((basics.md:137))\n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintGreeter)).tagged(Set(AxisTag(style:normal))) ((basics.md:134))\n\n// Combine previous `HelloByeModule` with our new module\n// While overriding `make[Greeter]` bindings from the first module \n\nval CombinedModule = HelloByeModule overridenBy TwoImplsModule\n// CombinedModule: izumi.distage.model.definition.Module = \n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer}].from(call(Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintByer)) ((basics.md:67))\n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.HelloByeApp}].from(call(Class(repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter, repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.HelloByeApp)) ((basics.md:68))\n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.AllCapsGreeter)).tagged(Set(AxisTag(style:allcaps))) ((basics.md:137))\n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintGreeter)).tagged(Set(AxisTag(style:normal))) ((basics.md:134))\n\n// Choose component configuration when making an Injector:\n\nval capsInjector = Injector(Activation(Style -> Style.AllCaps))\n// capsInjector: Injector = izumi.distage.InjectorDefaultImpl@17cfa994\n\n// Check the result:\n\ncapsInjector\n  .produceGet[HelloByeApp](CombinedModule)\n  .use(_.run())\n// What's your name?\n// > kai\n// HELLO KAI\n// Bye kai!\n// res3: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\n\n// Check that result changes with a different configuration:\n\nInjector(Activation(Style -> Style.Normal))\n  .produceGet[HelloByeApp](CombinedModule)\n  .use(_.run())\n// What's your name?\n// > Pavel\n// Hello Pavel!\n// Bye Pavel!\n// res4: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\ndistage.StandardAxis contains bundled Axes for back-end development: Repo.Prod/Dummy, Env.Prod/Test & ExternalApi.Prod/Mock\nIn distage-framework’s RoleAppLauncher, you can choose axes using the -u command-line parameter:\n./launcher -u repo:dummy -u env:prod app1\nIn distage-testkit, specify axes via TestConfig:\nimport distage.StandardAxis.Repo\nimport izumi.distage.testkit.TestConfig\nimport izumi.distage.testkit.scalatest.DistageBIOSpecScalatest\n\nclass AxisTest extends DistageBIOSpecScalatest[zio.IO] {\n  override protected def config: TestConfig = super.config.copy(\n    // choose implementations tagged `Repo.Dummy` when multiple implementations with `Repo.*` tags are available\n    activation = Activation(Repo -> Repo.Dummy)\n  )\n}","title":"Activation Axis"},{"location":"/distage/basics.html#multi-dimensionality","text":"There may be many configuration axes in an application and components can specify multiple axis choices at once:\nimport distage.StandardAxis.Env\n\nclass TestPrintGreeter extends Greeter {\n  def hello(name: String) = println(s\"Test 1 2, hello $name\")\n}\n\n// declare 3 possible implementations\n\nval TestModule = new ModuleDef {\n  make[Greeter].tagged(Style.Normal, Env.Prod).from[PrintGreeter]\n  make[Greeter].tagged(Style.Normal, Env.Test).from[TestPrintGreeter]\n  make[Greeter].tagged(Style.AllCaps).from[AllCapsGreeter]\n}\n// TestModule: AnyRef with ModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.AllCapsGreeter)).tagged(Set(AxisTag(style:allcaps))) ((basics.md:192))\n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.TestPrintGreeter)).tagged(Set(AxisTag(style:normal), AxisTag(env:test))) ((basics.md:191))\n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintGreeter)).tagged(Set(AxisTag(style:normal), AxisTag(env:prod))) ((basics.md:190))\n\ndef runWith(activation: Activation) =\n  Injector(activation).produceRun(TestModule) {\n    greeter: Greeter => greeter.hello(\"$USERNAME\")\n  }\n\n// Production Normal Greeter\n\nrunWith(Activation(Style -> Style.Normal, Env -> Env.Prod))\n// Hello $USERNAME!\n\n// Test Normal Greeter\n\nrunWith(Activation(Style -> Style.Normal, Env -> Env.Test))\n// Test 1 2, hello $USERNAME\n\n// Both Production and Test Caps Greeters are the same:\n\nrunWith(Activation(Style -> Style.AllCaps, Env -> Env.Prod))\n// HELLO $USERNAME\n\nrunWith(Activation(Style -> Style.AllCaps, Env -> Env.Test))\n// HELLO $USERNAME","title":"Multi-dimensionality"},{"location":"/distage/basics.html#resource-bindings-lifecycle","text":"You can specify object lifecycle by injecting cats.effect.Resource, zio.ZManaged or distage.DIResource values that specify the allocation and finalization actions for an object.\nInjector itself only returns a DIResource value that can be used to create and finalize the object graph, this value is pure and can be reused multiple times. A DIResource is consumed using its .use method, the function passed to use will receive an allocated resource and when the function exits the resource will be deallocated.\nExample with cats.effect.Resource:\nimport distage.{Roots, ModuleDef, Injector}\nimport cats.effect.{Bracket, Resource, IO}\n\nclass DBConnection\nclass MessageQueueConnection\n\nval dbResource = Resource.make(\n  acquire = IO { \n    println(\"Connecting to DB!\")\n    new DBConnection \n})(release = _ => IO(println(\"Disconnecting DB\")))\n// dbResource: Resource[IO, DBConnection] = Allocate(<function1>)\n\nval mqResource = Resource.make(\n  acquire = IO {\n   println(\"Connecting to Message Queue!\")\n   new MessageQueueConnection \n})(release = _ => IO(println(\"Disconnecting Message Queue\")))\n// mqResource: Resource[IO, MessageQueueConnection] = Allocate(<function1>)\n\nclass MyApp(db: DBConnection, mq: MessageQueueConnection) {\n  val run = IO(println(\"Hello World!\"))\n}\n\nval module = new ModuleDef {\n  make[DBConnection].fromResource(dbResource)\n  make[MessageQueueConnection].fromResource(mqResource)\n  addImplicit[Bracket[IO, Throwable]]\n  make[MyApp]\n}\n// module: AnyRef with ModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App9::repl.MdocSession.App9.MyApp}].from(call(Class(repl.MdocSession::repl.MdocSession.App9::repl.MdocSession.App9.DBConnection, repl.MdocSession::repl.MdocSession.App9::repl.MdocSession.App9.MessageQueueConnection): repl.MdocSession::repl.MdocSession.App9::repl.MdocSession.App9.MyApp)) ((basics.md:255))\n// make[{type.repl.MdocSession::repl.MdocSession.App9::repl.MdocSession.App9.DBConnection}].from(allocate[λ %0 → cats.effect.IO[+0]](call(izumi.distage.model.reflection.Provider$ProviderImpl$$Lambda$19037/388770849@5e273233(cats.effect.Bracket[=λ %0 → IO[+0],=Throwable]): izumi.distage.model.definition.DIResource::izumi.distage.model.definition.DIResource.FromCats[=λ %1:0 → IO[+1:0],=MdocSession::App9::DBConnection]))) ((basics.md:252))\n// make[{type.repl.MdocSession::repl.MdocSession.App9::repl.MdocSession.App9.MessageQueueConnection}].from(allocate[λ %0 → cats.effect.IO[+0]](call(izumi.distage.model.reflection.Provider$ProviderImpl$$Lambda$19037/388770849@43a3f9a(cats.effect.Bracket[=λ %0 → IO[+0],=Throwable]): izumi.distage.model.definition.DIResource::izumi.distage.model.definition.DIResource.FromCats[=λ %1:0 → IO[+1:0],=MdocSession::App9::MessageQueueConnection]))) ((basics.md:253))\n// make[{type.cats.effect.Bracket[=λ %1:0 → IO[+1:0],=Throwable]}].from(value(cats.effect.IOLowPriorityInstances$IOEffect@1302b44c: cats.effect.Bracket[=λ %1:0 → IO[+1:0],=Throwable])) ((basics.md:254))\nWill produce the following output:\nimport distage.DIKey\n\nval objectGraphResource = Injector().produceF[IO](module, Roots(root = DIKey[MyApp]))\n// objectGraphResource: izumi.distage.model.definition.DIResource.DIResourceBase[IO, izumi.distage.model.Locator] = izumi.distage.model.definition.DIResource$$anon$11@78f379f0\n\nobjectGraphResource\n  .use(_.get[MyApp].run)\n  .unsafeRunSync()\n// Connecting to Message Queue!\n// Connecting to DB!\n// Hello World!\n// Disconnecting DB\n// Disconnecting Message Queue\nLifecycle management with DIResource is also available without an effect type, via DIResource.Simple and DIResource.Mutable:\nimport distage.{DIResource, Roots, ModuleDef, Injector}\n\nclass Init {\n  var initialized = false\n}\n\nclass InitResource extends DIResource.Simple[Init] {\n  override def acquire = {\n    val init = new Init\n    init.initialized = true\n    init\n  }\n  override def release(init: Init) = {\n    init.initialized = false\n  }\n}\n\nval module = new ModuleDef {\n  make[Init].fromResource[InitResource]\n}\n// module: AnyRef with ModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App11::repl.MdocSession.App11.Init}].from(allocate[λ %0 → 0](call(Class(): repl.MdocSession::repl.MdocSession.App11::repl.MdocSession.App11.InitResource))) ((basics.md:300))\n\nval closedInit = Injector()\n  .produceGet[Init](module)\n  .use {\n    init =>\n      println(init.initialized)\n      init\n}\n// true\n// closedInit: izumi.fundamentals.platform.functional.package.Identity[Init] = repl.MdocSession$App11$Init@7a821f05\n\nprintln(closedInit.initialized)\n// false\nDIResource forms a monad and has the expected .map, .flatMap, .evalMap, .mapK methods.\nYou can convert between DIResource and cats.effect.Resource via .toCats/.fromCats methods, and between zio.ZManaged via .toZIO/.fromZIO.","title":"Resource Bindings, Lifecycle"},{"location":"/distage/basics.html#set-bindings","text":"Set bindings are useful for implementing listeners, plugins, hooks, http routes, healthchecks, migrations, etc. Everywhere where a collection of components is required, a Set Binding is appropriate.\nTo define a Set binding use .many and .add methods of the ModuleDef DSL.\nFor example, we may declare many http4s routes and serve them all from a central router:\nimport cats.implicits._\nimport cats.effect.{Bracket, IO, Resource}\nimport distage.{Roots, ModuleDef, Injector}\nimport org.http4s._\nimport org.http4s.server.Server\nimport org.http4s.client.Client\nimport org.http4s.dsl.io._\nimport org.http4s.implicits._\nimport org.http4s.server.blaze.BlazeServerBuilder\nimport org.http4s.client.blaze.BlazeClientBuilder\n\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nimplicit val contextShift = IO.contextShift(global)\nimplicit val timer = IO.timer(global)\nval homeRoute = HttpRoutes.of[IO] { \n  case GET -> Root / \"home\" => Ok(s\"Home page!\") \n}\n// homeRoute: HttpRoutes[IO] = Kleisli(org.http4s.HttpRoutes$$$Lambda$19080/64992283@1dd31ccc)\n\nobject HomeRouteModule extends ModuleDef {\n  many[HttpRoutes[IO]]\n    .add(homeRoute)\n}\nWe’ve used many method to declare an open Set of http routes and then added one HTTP route into it. When module definitions are combined, Sets for the same binding will be merged together. You can summon a Set Bindings by summoning a scala Set, as in Set[HttpRoutes[IO]].\nLet’s define a new module with another route:\nval blogRoute = HttpRoutes.of[IO] { \n  case GET -> Root / \"blog\" / post => Ok(s\"Blog post ``$post''!\") \n}\n// blogRoute: HttpRoutes[IO] = Kleisli(org.http4s.HttpRoutes$$$Lambda$19080/64992283@48403603)\n\nobject BlogRouteModule extends ModuleDef {  \n  many[HttpRoutes[IO]]\n    .add(blogRoute)\n}\nNow it’s the time to define a Server component to serve all the different routes we have:\ndef makeHttp4sServer(routes: Set[HttpRoutes[IO]]): Resource[IO, Server[IO]] = {\n  // create a top-level router by combining all the routes\n  val router: HttpApp[IO] = routes.toList.foldK.orNotFound\n\n  // return a Resource value that will setup an http4s server \n  BlazeServerBuilder[IO]\n    .bindHttp(8080, \"localhost\")\n    .withHttpApp(router)\n    .resource\n}\n\nobject HttpServerModule extends ModuleDef {\n  make[Server[IO]].fromResource(makeHttp4sServer _)\n  make[Client[IO]].fromResource(BlazeClientBuilder[IO](global).resource)\n  addImplicit[Bracket[IO, Throwable]] // required for cats `Resource` in `fromResource`\n}\n\n// join all the module definitions\ndef finalModule = Seq(\n  HomeRouteModule,\n  BlogRouteModule,\n  HttpServerModule,\n).merge\n\n// wire the graph\nval objects = Injector().produceF[IO](finalModule, Roots.Everything).unsafeGet().unsafeRunSync()\n// objects: izumi.distage.model.Locator = izumi.distage.LocatorDefaultImpl@2b1ffa02\n\nval server = objects.get[Server[IO]]\n// server: Server[IO] = BlazeServer(/127.0.0.1:8080)\nval client = objects.get[Client[IO]]\n// client: Client[IO] = org.http4s.client.Client$$anon$1@418fb253\nCheck if it works:\n// check home page\nclient.expect[String](\"http://localhost:8080/home\").unsafeRunSync()\n// res14: String = Home page!\n\n// check blog page\nclient.expect[String](\"http://localhost:8080/blog/1\").unsafeRunSync()\n// res15: String = Blog post ``1''!\nFurther reading: the same concept is called Multibindings in Guice.","title":"Set Bindings"},{"location":"/distage/basics.html#effect-bindings","text":"Sometimes we want to effectfully create a component, but the resulting component or data does not need to be deallocated. An example might be a global Semaphore to limit the parallelism of the entire application based on configuration, or a test implementation of some service made with Refs.\nIn these cases we can use .fromEffect to create a value using an effectful constructor.\nExample with a Ref-based Tagless Final KVStore:\nimport distage.{Roots, ModuleDef, Injector}\nimport izumi.functional.bio.{BIOMonadError, BIOPrimitives, F}\nimport zio.{Task, IO}\n\ntrait KVStore[F[_, _]] {\n  def get(key: String): F[NoSuchElementException, String]\n  def put(key: String, value: String): F[Nothing, Unit]\n}\n\ndef dummyKVStore[F[+_, +_]: BIOMonadError: BIOPrimitives]: F[Nothing, KVStore[F]] = {\n  for {\n    ref <- F.mkRef(Map.empty[String, String])\n  } yield new KVStore[F] {\n    def put(key: String, value: String): F[Nothing, Unit] = {\n      ref.update_(_ + (key -> value))\n    }\n  \n    def get(key: String): F[NoSuchElementException, String] = {\n      for {\n        map <- ref.get\n        res <- map.get(key) match {\n          case Some(value) => F.pure(value)\n          case None        => F.fail(new NoSuchElementException(key))\n        }\n      } yield res\n    }\n  }\n}\n\ndef kvStoreModule = new ModuleDef {\n  make[KVStore[IO]].fromEffect(dummyKVStore[IO])\n}\n\nval io = Injector()\n  .produceRunF[Task, String](kvStoreModule) {\n    kv: KVStore[IO] =>\n      for {\n        _    <- kv.put(\"apple\", \"pie\")\n        res1 <- kv.get(\"apple\")\n        _    <- kv.put(\"apple\", \"ipad\")\n        res2 <- kv.get(\"apple\")\n      } yield res1 + res2\n  }\n// io: Task[String] = zio.ZIO$CheckInterrupt@443fe3d2\n\nzio.Runtime.default.unsafeRun(io)\n// res18: String = pieipad\nYou need to use effect-aware Injector.produceF method to use effect bindings.","title":"Effect Bindings"},{"location":"/distage/basics.html#zio-has-bindings","text":"You can inject into ZIO Environment using make[_].fromHas syntax for ZLayer, ZManaged, ZIO or any F[_, _, _]: BIOLocal:\nimport zio._\nimport distage._\n\ndef zioEnvCtor: URIO[Has[Dep1] with Has[Dep2], X] = ZIO.succeed(X)\ndef zmanagedEnvCtor: URManaged[Has[Dep1] with Has[Dep2], X] = ZManaged.succeed(X)\ndef zlayerEnvCtor: URLayer[Has[Dep1] with Has[Dep2], Has[X]] = ZLayer.succeed(X)\n\ndef module1 = new ModuleDef {\n  make[X].fromHas(zioEnvCtor)\n  // or\n  make[X].fromHas(zmanagedEnvCtor)\n  // or\n  make[X].fromHas(zlayerEnvCtor)\n}\nYou can also mix environment and parameter dependencies at the same time in one constructor:\ndef zioArgEnvCtor(a: Arg1, b: Arg2): URLayer[Has[Dep1], Has[X]] = ZLayer.fromService(dep1 => X(a, b, dep1))\n\ndef module2 = new ModuleDef {\n  make[X].fromHas(zioArgEnvCtor _)\n}\nzio.Has implementations are derived at compile-time by HasConstructor macro and can be summoned at need.\nExample:\nimport distage.{DIKey, ModuleDef, Injector, ProviderMagnet, Tag}\nimport izumi.distage.constructors.TraitConstructor\nimport zio.console.{putStrLn, Console}\nimport zio.{UIO, URIO, ZIO, Ref, Task, Has}\n\ntrait Hello {\n  def hello: UIO[String]\n}\ntrait World {\n  def world: UIO[String]\n}\n\n// Environment forwarders that allow\n// using service functions from everywhere\n\nval hello: URIO[Has[Hello], String] = ZIO.accessM(_.get.hello)\n// hello: URIO[Has[Hello], String] = zio.ZIO$Read@d863578\n\nval world: URIO[Has[World], String] = ZIO.accessM(_.get.world)\n// world: URIO[Has[World], String] = zio.ZIO$Read@599d1120\n\n// service implementations\n\nval makeHello = {\n  (for {\n    _     <- putStrLn(\"Creating Enterprise Hellower...\")\n    hello = new Hello { val hello = UIO(\"Hello\") }\n  } yield hello).toManaged { _ =>\n    putStrLn(\"Shutting down Enterprise Hellower\")\n  }\n}\n// makeHello: zio.ZManaged[Console, Nothing, AnyRef with Hello{val hello: zio.UIO[String]}] = zio.ZManaged@653c3d6a\n\nval makeWorld = {\n  for {\n    counter <- Ref.make(0)\n  } yield new World {\n    val world = counter.get.map(c => if (c < 1) \"World\" else \"THE World\")\n  }\n}\n// makeWorld: ZIO[Any, Nothing, AnyRef with World{val world: zio.ZIO[Any,Nothing,String]}] = zio.ZIO$FlatMap@5ea6636c\n\n// the main function\n\nval turboFunctionalHelloWorld: URIO[Has[Hello] with Has[World] with Has[Console.Service], Unit] = {\n  for {\n    hello <- hello\n    world <- world\n    _     <- putStrLn(s\"$hello $world\")\n  } yield ()\n}\n// turboFunctionalHelloWorld: URIO[Has[Hello] with Has[World] with Has[Console.Service], Unit] = zio.ZIO$FlatMap@62b7a035\n\ndef module = new ModuleDef {\n  make[Hello].fromHas(makeHello)\n  make[World].fromHas(makeWorld)\n  make[Console.Service].fromHas(Console.live)\n  make[Unit].fromHas(turboFunctionalHelloWorld)\n}\n\nval main = Injector()\n  .produceRunF[Task, Unit](module)((_: Unit) => Task.unit)\n// main: Task[Unit] = zio.ZIO$CheckInterrupt@5392b952\n\nzio.Runtime.default.unsafeRun(main)\n// Creating Enterprise Hellower...\n// Hello World\n// Shutting down Enterprise Hellower","title":"ZIO Has Bindings"},{"location":"/distage/basics.html#converting-between-zio-environment-dependencies-and-parameters","text":"Any ZIO Service that requires an environment can be turned into a service without an environment dependency by providing the dependency in each method. This pattern can be generalized by implementing an instance of cats.Contravariant (or cats.tagless.FunctorK) for your services and using it to turn environment dependencies into constructor parameters – that way ZIO Environment can be used uniformly for declaration of dependencies, but the dependencies used inside the service do not leak to other services calling it. Details: https://gitter.im/ZIO/Core?at=5dbb06a86570b076740f6db2\nExample:\nimport cats.Contravariant\nimport distage.{Roots, Injector, ModuleDef, ProviderMagnet, Tag, TagK, HasConstructor}\nimport zio.{Task, UIO, URIO, ZIO, Has}\n\ntrait Dependee[-R] {\n  def x(y: String): URIO[R, Int]\n}\ntrait Depender[-R] {\n  def y: URIO[R, String]\n}\nimplicit val contra1: Contravariant[Dependee] = new Contravariant[Dependee] {\n  def contramap[A, B](fa: Dependee[A])(f: B => A): Dependee[B] = new Dependee[B] { def x(y: String) = fa.x(y).provideSome(f) }\n}\n// contra1: Contravariant[Dependee] = repl.MdocSession$App22$$anon$15@57c11927\nimplicit val contra2: Contravariant[Depender] = new Contravariant[Depender] {\n  def contramap[A, B](fa: Depender[A])(f: B => A): Depender[B] = new Depender[B] { def y = fa.y.provideSome(f) }\n}\n// contra2: Contravariant[Depender] = repl.MdocSession$App22$$anon$17@3a91adb0\n\ntype DependeeR = Has[Dependee[Any]]\ntype DependerR = Has[Depender[Any]]\nobject dependee extends Dependee[DependeeR] { def x(y: String) = ZIO.accessM(_.get.x(y)) }\nobject depender extends Depender[DependerR] { def y            = ZIO.accessM(_.get.y) }\n\n// cycle\nobject dependerImpl extends Depender[DependeeR] {\n  def y: URIO[DependeeR, String] = dependee.x(\"hello\").map(_.toString)\n}\nobject dependeeImpl extends Dependee[DependerR] {\n  def x(y: String): URIO[DependerR, Int] = {\n    if (y == \"hello\") UIO(5) \n    else depender.y.map(y.length + _.length)\n  }\n}\n\n/** Fulfill the environment dependencies of a service from the object graph */\ndef fullfill[R: Tag: HasConstructor, M[_]: TagK: Contravariant](service: M[R]): ProviderMagnet[M[Any]] = {\n  HasConstructor[R]\n    .map(depsCakeR => Contravariant[M].contramap(service)(_ => depsCakeR))\n}\n\ndef module = new ModuleDef {\n  make[Depender[Any]].from(fullfill(dependerImpl))\n  make[Dependee[Any]].from(fullfill(dependeeImpl))\n}\n\nInjector()\n  .produceRunF(module) {\n    HasConstructor[DependeeR].map {\n      (for {\n        r <- dependee.x(\"zxc\")\n        _ <- Task(println(s\"result: $r\"))\n      } yield ()).provide(_)\n    }\n  }.fold(_ => 1, _ => 0)\n// res23: URIO[Any, Int] = <function1>","title":"Converting between ZIO environment dependencies and parameters"},{"location":"/distage/basics.html#auto-traits","text":"distage can instantiate traits and structural types. All unimplemented fields in a trait or a refinement are filled in from the object graph.\nTrait implementations are derived at compile-time by TraitConstructor macro and can be summoned at need.\nIf a suitable trait is specified as an implementation class for a binding, TraitConstructor will be used automatically:\nExample:\nimport distage.{ModuleDef, Id, Injector}\n\ntrait Trait1 {\n  def a: Int @Id(\"a\")\n}\ntrait Trait2 {\n  def b: Int @Id(\"b\")\n}\n\n/** All methods in this trait are implemented,\n  * so a constructor for it will be generated\n  * even though it's not a class */\ntrait Pluser {\n  def plus(a: Int, b: Int) = a + b\n}\n\ntrait PlusedInt {\n  def result(): Int\n}\nobject PlusedInt {\n\n  /**\n    * Besides the dependency on `Pluser`,\n    * this class defines 2 more dependencies\n    * to be injected from the object graph:\n    *\n    * `def a: Int @Id(\"a\")` and\n    * `def b: Int @Id(\"b\")`\n    * \n    * When an abstract type is declared as an implementation,\n    * its no-argument abstract defs & vals are considered as\n    * dependency parameters by TraitConstructor. (empty-parens and\n    * parameterized methods are not considered parameters)\n    *\n    * Here, using an abstract class directly as an implementation\n    * lets us avoid writing a lengthier constructor, like this one:\n    * \n    * {{{\n    *   final class Impl(\n    *     pluser: Pluser,\n    *     override val a: Int @Id(\"a\"),\n    *     override val b: Int @Id(\"b\"),\n    *   ) extends PlusedInt with Trait1 with Trait2\n    * }}}\n    */\n  abstract class Impl(\n    pluser: Pluser\n  ) extends PlusedInt\n    with Trait1\n    with Trait2 {\n    override def result(): Int = {\n      pluser.plus(a, b)\n    }\n  }\n\n}\n\nInjector()\n  .produceRun(new ModuleDef {\n    make[Int].named(\"a\").from(1)\n    make[Int].named(\"b\").from(2)\n    make[Pluser]\n    make[PlusedInt].from[PlusedInt.Impl]\n  }) {\n    plusedInt: PlusedInt => \n      plusedInt.result\n  }\n// res25: Int = 3\nAbstract classes or traits without obvious concrete subclasses may hinder the readability of a codebase, if you still want to use them to avoid writing the full constructor, you may use an optional @impl documenting annotation to aid the reader in understanding your intention.\nimport distage.impl\n\n@impl abstract class Impl(\n  pluser: Pluser\n) extends PlusedInt","title":"Auto-Traits"},{"location":"/distage/basics.html#auto-factories","text":"distage can instantiate ‘factory’ classes from suitable traits. This feature is especially useful with Akka. All unimplemented methods with parameters in a trait will be filled by factory methods:\nGiven a class ActorFactory:\nimport distage.ModuleDef\nimport java.util.UUID\n\nclass SessionStorage\n\nclass UserActor(sessionId: UUID, sessionStorage: SessionStorage)\n\ntrait ActorFactory {\n  // UserActor will be created as follows:\n  //   sessionId argument is provided by the user\n  //   sessionStorage argument is wired from the object graph\n  def createActor(sessionId: UUID): UserActor\n}\nAnd a binding of ActorFactory without an implementation\nclass ActorModule extends ModuleDef {\n  make[ActorFactory]\n}\ndistage will derive and bind the following implementation for ActorFactory:\nclass ActorFactoryImpl(sessionStorage: SessionStorage) extends ActorFactory {\n  override def createActor(sessionId: UUID): UserActor = {\n    new UserActor(sessionId, sessionStorage)\n  }\n}\n@With annotation can be used to specify the implementation class, to avoid leaking the implementation type in factory method result:\nimport distage.{ModuleDef, Injector, With}\n\ntrait Actor { \n  def receive(msg: Any): Unit\n}\n\nobject Actor {\n  trait Factory {\n    def newActor(id: String): Actor @With[Actor.Impl]\n  }\n\n  final class Impl(id: String, config: Actor.Configuration) extends Actor {\n    def receive(msg: Any) = {\n      val response = s\"Actor `$id` received a message: $msg\"\n      println(if (config.allCaps) response.toUpperCase else response)\n    }\n  }\n\n  final case class Configuration(allCaps: Boolean)\n}\n\nval factoryModule = new ModuleDef {\n  make[Actor.Factory]\n  make[Actor.Configuration].from(Actor.Configuration(allCaps = false))\n}\n// factoryModule: AnyRef with ModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App26::repl.MdocSession.App26.Actor::repl.MdocSession.App26.Actor.Factory}].from(call(Factory(repl.MdocSession::repl.MdocSession.App26::repl.MdocSession.App26.Actor::repl.MdocSession.App26.Actor.Configuration): repl.MdocSession::repl.MdocSession.App26::repl.MdocSession.App26.Actor::repl.MdocSession.App26.Actor.Factory)) ((basics.md:891))\n// make[{type.repl.MdocSession::repl.MdocSession.App26::repl.MdocSession.App26.Actor::repl.MdocSession.App26.Actor.Configuration}].from(call(izumi.distage.model.definition.dsl.ModuleDefDSL$MakeDSLBase$$Lambda$19802/1248558164@657804df(): repl.MdocSession::repl.MdocSession.App26::repl.MdocSession.App26.Actor::repl.MdocSession.App26.Actor.Configuration)) ((basics.md:892))\n\nInjector()\n  .produceGet[Actor.Factory](factoryModule)\n  .use(_.newActor(\"Martin Odersky\").receive(\"ping\"))\n// Actor `Martin Odersky` received a message: ping\n// res27: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\nYou can use this feature to concisely provide non-Singleton semantics for some of your components.\nFactory implementations are derived at compile-time by FactoryConstructor macro and can be summoned at need.","title":"Auto-Factories"},{"location":"/distage/basics.html#tagless-final-style","text":"Tagless Final is one of the popular patterns for structuring purely-functional applications. If you’re not familiar with tagless final you can skip this section.\nBrief introduction to tagless final:\nDeferring Commitments: Tagless Final Introduction to Tagless Final\nAdvantages of distage as a driver for TF compared to implicits:\neasy explicit overrides easy effectful instantiation and resource management extremely easy & scalable test context setup due to the above multiple different implementations for a type using disambiguation by @Id\nFor example, let’s take freestyle’s tagless example and make it safer and more flexible by replacing dependencies on global imported implementations from with explicit modules.\nFirst, the program we want to write:\nimport cats.Monad\nimport cats.effect.{Sync, IO}\nimport cats.syntax.all._\nimport distage.{Roots, Module, ModuleDef, Injector, Tag, TagK, TagKK}\n\ntrait Validation[F[_]] {\n  def minSize(s: String, n: Int): F[Boolean]\n  def hasNumber(s: String): F[Boolean]\n}\ndef Validation[F[_]: Validation]: Validation[F] = implicitly\n\ntrait Interaction[F[_]] {\n  def tell(msg: String): F[Unit]\n  def ask(prompt: String): F[String]\n}\ndef Interaction[F[_]: Interaction]: Interaction[F] = implicitly\n\nclass TaglessProgram[F[_]: Monad: Validation: Interaction] {\n  def program: F[Unit] = for {\n    userInput <- Interaction[F].ask(\"Give me something with at least 3 chars and a number on it\")\n    valid     <- (Validation[F].minSize(userInput, 3), Validation[F].hasNumber(userInput)).mapN(_ && _)\n    _         <- if (valid) Interaction[F].tell(\"awesomesauce!\")\n                 else       Interaction[F].tell(s\"$userInput is not valid\")\n  } yield ()\n}\n\ndef ProgramModule[F[_]: TagK: Monad] = new ModuleDef {\n  make[TaglessProgram[F]]\n  addImplicit[Monad[F]]\n}\nTagK is distage’s analogue of TypeTag for higher-kinded types such as F[_], it allows preserving type-information at runtime for type parameters. You’ll need to add a TagK context bound to create a module parameterized by an abstract F[_]. To parameterize by non-higher-kinded types, use just Tag.\nNow the interpreters for Validation and Interaction:\nfinal class SyncValidation[F[_]](implicit F: Sync[F]) extends Validation[F] {\n  def minSize(s: String, n: Int): F[Boolean] = F.delay(s.size >= n)\n  def hasNumber(s: String): F[Boolean]       = F.delay(s.exists(c => \"0123456789\".contains(c)))\n}\n  \nfinal class SyncInteraction[F[_]](implicit F: Sync[F]) extends Interaction[F] {\n  def tell(s: String): F[Unit]  = F.delay(println(s))\n  def ask(s: String): F[String] = F.delay(\"This could have been user input 1\")\n}\n\ndef SyncInterpreters[F[_]: TagK: Sync] = {\n  new ModuleDef {\n    make[Validation[F]].from[SyncValidation[F]]\n    make[Interaction[F]].from[SyncInteraction[F]]\n    addImplicit[Sync[F]]\n  }\n}\n\n// combine all modules\n\ndef SyncProgram[F[_]: TagK: Sync] = ProgramModule[F] ++ SyncInterpreters[F]\n\n// create object graph Resource\n\nval objectsResource = Injector().produceF[IO](SyncProgram[IO], Roots.Everything)\n// objectsResource: izumi.distage.model.definition.DIResource.DIResourceBase[IO, izumi.distage.model.Locator] = izumi.distage.model.definition.DIResource$$anon$11@2366690b\n\n// run\n\nobjectsResource.use(_.get[TaglessProgram[IO]].program).unsafeRunSync()\n// awesomesauce!\nThe program module is polymorphic over effect type. It can be instantiated by a different effect:\nimport zio.interop.catz._\nimport zio.Task\n\nval ZIOProgram = ProgramModule[Task] ++ SyncInterpreters[Task]\n// ZIOProgram: Module = \n// make[{type.repl.MdocSession::repl.MdocSession.App28::repl.MdocSession.App28.TaglessProgram[=λ %0 → ZIO[-Any,+Throwable,+0]]}].from(call(Class(cats.Monad[=λ %0 → ZIO[-Any,+Throwable,+0]], repl.MdocSession::repl.MdocSession.App28::repl.MdocSession.App28.Validation[=λ %0 → ZIO[-Any,+Throwable,+0]], repl.MdocSession::repl.MdocSession.App28::repl.MdocSession.App28.Interaction[=λ %0 → ZIO[-Any,+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App28::repl.MdocSession.App28.TaglessProgram[=λ %0 → ZIO[-Any,+Throwable,+0]])) ((basics.md:948))\n// make[{type.repl.MdocSession::repl.MdocSession.App28::repl.MdocSession.App28.Interaction[=λ %0 → ZIO[-Any,+Throwable,+0]]}].from(call(Class(cats.effect.Sync[=λ %0 → ZIO[-Any,+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App28::repl.MdocSession.App28.SyncInteraction[=λ %0 → ZIO[-Any,+Throwable,+0]])) ((basics.md:971))\n// make[{type.repl.MdocSession::repl.MdocSession.App28::repl.MdocSession.App28.Validation[=λ %0 → ZIO[-Any,+Throwable,+0]]}].from(call(Class(cats.effect.Sync[=λ %0 → ZIO[-Any,+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App28::repl.MdocSession.App28.SyncValidation[=λ %0 → ZIO[-Any,+Throwable,+0]])) ((basics.md:970))\n// make[{type.cats.Monad[=λ %0 → ZIO[-Any,+Throwable,+0]]}].from(value(zio.interop.CatsConcurrent@62cdd50f: cats.Monad[=λ %0 → ZIO[-Any,+Throwable,+0]])) ((basics.md:949))\n// make[{type.cats.effect.Sync[=λ %0 → ZIO[-Any,+Throwable,+0]]}].from(value(zio.interop.CatsConcurrent@62cdd50f: cats.effect.Sync[=λ %0 → ZIO[-Any,+Throwable,+0]])) ((basics.md:972))\nWe may even choose different interpreters at runtime:\nimport zio.RIO\nimport zio.console.{Console, getStrLn, putStrLn}\n\nobject RealInteractionZIO extends Interaction[RIO[Console, ?]] {\n  def tell(s: String): RIO[Console, Unit]  = putStrLn(s)\n  def ask(s: String): RIO[Console, String] = putStrLn(s) *> getStrLn\n}\n\nval RealInterpretersZIO = {\n  SyncInterpreters[RIO[Console, ?]] overridenBy new ModuleDef {\n    make[Interaction[RIO[Console, ?]]].from(RealInteractionZIO)\n  }\n}\n// RealInterpretersZIO: Module = \n// make[{type.repl.MdocSession::repl.MdocSession.App28::repl.MdocSession.App28.Interaction[=λ %1:0 → ZIO[-Has[=package::Console::Service],+Throwable,+1:0]]}].from(call(izumi.distage.model.definition.dsl.ModuleDefDSL$MakeDSLBase$$Lambda$19802/1248558164@7c315461(): repl.MdocSession::repl.MdocSession.App28::repl.MdocSession.App28.RealInteractionZIO)) ((basics.md:1015))\n// make[{type.repl.MdocSession::repl.MdocSession.App28::repl.MdocSession.App28.Validation[=λ %0 → ZIO[-Has[=package::Console::Service],+Throwable,+0]]}].from(call(Class(cats.effect.Sync[=λ %0 → ZIO[-Has[=package::Console::Service],+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App28::repl.MdocSession.App28.SyncValidation[=λ %0 → ZIO[-Has[=package::Console::Service],+Throwable,+0]])) ((basics.md:970))\n// make[{type.cats.effect.Sync[=λ %0 → ZIO[-Has[=package::Console::Service],+Throwable,+0]]}].from(value(zio.interop.CatsConcurrent@62cdd50f: cats.effect.Sync[=λ %0 → ZIO[-Has[=package::Console::Service],+Throwable,+0]])) ((basics.md:972))\n\ndef chooseInterpreters(isDummy: Boolean) = {\n  val interpreters = if (isDummy) SyncInterpreters[RIO[Console, ?]]\n                     else         RealInterpretersZIO\n  val module = ProgramModule[RIO[Console, ?]] ++ interpreters\n  Injector().produceGetF[RIO[Console, ?], TaglessProgram[RIO[Console, ?]]](module)\n}\n\n// execute\n\nchooseInterpreters(true)\n// res30: izumi.distage.model.definition.DIResource.DIResourceBase[zio.ZIO[zio.Has[Console.Service], Throwable, β$5$], TaglessProgram[zio.ZIO[zio.Has[Console.Service], Throwable, β$6$]]] = izumi.distage.model.definition.DIResource$$anon$10@7e3f23cc\nModules can be polymorphic over arbitrary kinds - use TagKK to abstract over bifunctors:\nclass BifunctorIOModule[F[_, _]: TagKK] extends ModuleDef\nOr use Tag.auto.T to abstract over any kind:\nclass MonadTransModule[F[_[_], _]: Tag.auto.T] extends ModuleDef\nclass TrifunctorModule[F[_, _, _]: Tag.auto.T] extends ModuleDef\nclass EldritchModule[F[+_, -_[_, _], _[_[_, _], _], _]: Tag.auto.T] extends ModuleDef\nconsult HKTag docs for more details.","title":"Tagless Final Style"},{"location":"/distage/basics.html#cats-zio-integration","text":"Cats & ZIO instances and syntax are available automatically in distage-core, without wildcard imports, if your project depends on cats-core, cats-effect or zio. But distage won’t bring in cats or zio as dependencies if you don’t already depend on them. (No More Orphans blog post details how that works)\nCats Resource & ZIO ZManaged Bindings also work out of the box without any magic imports.\nExample:\nimport cats.syntax.semigroup._\nimport cats.effect.{ExitCode, IO, IOApp}\nimport distage.{DIKey, Roots, Injector}\n\ntrait AppEntrypoint {\n  def run: IO[Unit]\n}\n\nobject Main extends App {\n  def run(args: List[String]): IO[ExitCode] = {\n    \n    // `distage.Module` has a Monoid instance\n\n    val myModules = ProgramModule[IO] |+| SyncInterpreters[IO]\n\n    val plan = Injector().plan(myModules, Roots(DIKey[AppEntrypoint]))\n\n    for {\n      // resolveImportsF can effectfully add missing instances to an existing plan\n      // (You can also create instances effectfully inside `ModuleDef` via `make[_].fromEffect` bindings)\n\n      newPlan <- plan.resolveImportsF[IO] {\n        case i if i.target == DIKey[DBConnection] =>\n           DBConnection.create[IO]\n      }\n\n      // `produceF` specifies an Effect to run in.\n      // Effects used in Resource and Effect Bindings \n      // should match the effect in `produceF`\n\n      _ <- Injector().produceF[IO](newPlan).use {\n        classes =>\n          classes.get[AppEntrypoint].run\n      }\n    } yield ExitCode.Success\n  }\n}","title":"Cats & ZIO Integration"},{"location":"/distage/advanced-features.html","text":"","title":"Advanced Features"},{"location":"/distage/advanced-features.html#advanced-features","text":"Garbage Collection Circular Dependencies Support Automatic Resolution with generated proxies Manual Resolution with by-name parameters Auto-Sets Weak Sets Inner Classes and Path-Dependent Types Depending on Locator","title":"Advanced Features"},{"location":"/distage/advanced-features.html#garbage-collection","text":"A garbage collector is included in distage by default. Given a set of GC root keys, GC will remove all bindings that are neither direct nor transitive dependencies of the supplied roots – these bindings will be thrown out and never instantiated.\nGC serves two important purposes:\nIt enables faster tests by omitting unrequired instantiations and initialization of potentially heavy resources, It enables multiple independent applications, aka “Roles” to be hosted within a single .jar file.\nTo use garbage collector, pass GC roots as an argument to Injector.produce* methods:\nimport distage._\n\nclass A(b: B) {\n  println(\"A!\")\n}\nclass B() {\n  println(\"B!\")\n}\nclass C() {\n  println(\"C!\")\n}\n\nval module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n// module: AnyRef with ModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B}].from(call(Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B)) ((advanced-features.md:31))\n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.C}].from(call(Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.C)) ((advanced-features.md:32))\n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A}].from(call(Class(repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A)) ((advanced-features.md:30))\n\n// declare `A` as a GC root\n\nval gc = Roots(root = DIKey[A])\n// gc: Roots = Of(NonEmptySet({type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A}))\n\n// create an object graph from description in `module`\n// with `A` as a GC root\n\nval objects = Injector().produce(module, gc).unsafeGet()\n// B!\n// A!\n// objects: izumi.fundamentals.platform.functional.package.Identity[Locator] = izumi.distage.LocatorDefaultImpl@3b3a71d4\n\n// A and B are in the object graph\n\nobjects.find[A]\n// res1: Option[A] = Some(repl.MdocSession$App0$A@5007b617)\n\nobjects.find[B]\n// res2: Option[B] = Some(repl.MdocSession$App0$B@1ad1d2f)\n\n// C is missing\n\nobjects.find[C]\n// res3: Option[C] = None\nClass C was removed because neither B nor A depended on it. It’s not present in the Locator and the \"C!\" message has never been printed. If class B had a C parameter, like class B(c: C); C would have been retained, because A - the GC root, would depend on B, and B would depend on C.\nclass B(c: C) {\n  println(\"B!\")\n}\n\nval objects = Injector().produce(module, Roots(DIKey[A])).unsafeGet()\n// C!\n// B!\n// A!\n// objects: izumi.fundamentals.platform.functional.package.Identity[Locator] = izumi.distage.LocatorDefaultImpl@7fe236bd\n\nobjects.find[C]\n// res5: Option[C] = Some(repl.MdocSession$App4$C@173e5c44)","title":"Garbage Collection"},{"location":"/distage/advanced-features.html#circular-dependencies-support","text":"distage automatically resolves arbitrary circular dependencies, including self-references:\nimport distage.{Roots, ModuleDef, Injector}\n\nclass A(val b: B)\nclass B(val a: A)  \nclass C(val c: C)\n\nval objects = Injector().produce(new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}, Roots.Everything).unsafeGet()\n// objects: izumi.fundamentals.platform.functional.package.Identity[izumi.distage.model.Locator] = izumi.distage.LocatorDefaultImpl@7ae4e7ba\n\nobjects.get[A] eq objects.get[B].a\n// res7: Boolean = true\nobjects.get[B] eq objects.get[A].b\n// res8: Boolean = true\nobjects.get[C] eq objects.get[C].c\n// res9: Boolean = true","title":"Circular Dependencies Support"},{"location":"/distage/advanced-features.html#automatic-resolution-with-generated-proxies","text":"The above strategy depends on distage-core-proxy-cglib module which is a default dependency of distage-core.\nIf you want to disable it, use NoProxies bootstrap configuration:\nInjector.NoProxies()\n// res10: Injector = izumi.distage.InjectorDefaultImpl@1349c9ac\nProxies are not supported on Scala.js.","title":"Automatic Resolution with generated proxies"},{"location":"/distage/advanced-features.html#manual-resolution-with-by-name-parameters","text":"Most cycles can be resolved without proxies, using By-Name parameters:\nimport distage.{Roots, ModuleDef, Injector}\n\nclass A(b0: => B) {\n  def b: B = b0\n}\n\nclass B(a0: => A) {\n  def a: A = a0\n}\n\nclass C(self: => C) {\n  def c: C = self\n}\n\nval module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n// module: AnyRef with ModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App11::repl.MdocSession.App11.C}].from(call(Class(repl.MdocSession::repl.MdocSession.App11::repl.MdocSession.App11.C): repl.MdocSession::repl.MdocSession.App11::repl.MdocSession.App11.C)) ((advanced-features.md:158))\n// make[{type.repl.MdocSession::repl.MdocSession.App11::repl.MdocSession.App11.B}].from(call(Class(repl.MdocSession::repl.MdocSession.App11::repl.MdocSession.App11.A): repl.MdocSession::repl.MdocSession.App11::repl.MdocSession.App11.B)) ((advanced-features.md:157))\n// make[{type.repl.MdocSession::repl.MdocSession.App11::repl.MdocSession.App11.A}].from(call(Class(repl.MdocSession::repl.MdocSession.App11::repl.MdocSession.App11.B): repl.MdocSession::repl.MdocSession.App11::repl.MdocSession.App11.A)) ((advanced-features.md:156))\n\n// disable proxies and execute the module\n\nval locator = Injector.NoProxies()\n  .produce(module, Roots.Everything)\n  .unsafeGet()\n// locator: izumi.fundamentals.platform.functional.package.Identity[izumi.distage.model.Locator] = izumi.distage.LocatorDefaultImpl@7d7052a6\n\nlocator.get[A].b eq locator.get[B]\n// res12: Boolean = true\nlocator.get[B].a eq locator.get[A]\n// res13: Boolean = true\nlocator.get[C].c eq locator.get[C]\n// res14: Boolean = true\nThe proxy generation via cglib is enabled by default, because in scenarios with extreme late-binding cycles can emerge unexpectedly, out of control of the origin module.\nNote: Currently a limitation applies to by-names - ALL dependencies of a class engaged in a by-name circular dependency must be by-name, otherwise distage will revert to generating proxies.","title":"Manual Resolution with by-name parameters"},{"location":"/distage/advanced-features.html#auto-sets","text":"AutoSet Planner Hooks can traverse the plan and collect all future objects that match a predicate.\nUsing Auto-Sets you can e.g. collect all AutoCloseable classes and .close() them after the application has finished work. NOTE: please use Resource bindings for real lifecycle, this is just an example.\nimport distage.{BootstrapModuleDef, ModuleDef, Injector, Roots}\nimport izumi.distage.model.planning.PlanningHook\nimport izumi.distage.planning.AutoSetHook\n\nclass PrintResource(name: String) {\n  def start(): Unit = println(s\"$name started\")\n  def stop(): Unit = println(s\"$name stopped\")\n}\n\nclass A extends PrintResource(\"A\")\nclass B(val a: A) extends PrintResource(\"B\")\nclass C(val b: B) extends PrintResource(\"C\")\n\nval bootstrapModule = new BootstrapModuleDef {\n  many[PlanningHook]\n    .add(new AutoSetHook[PrintResource, PrintResource](identity))\n}\n// bootstrapModule: AnyRef with BootstrapModuleDef = \n// many[{type.scala.collection.immutable.Set[=PlanningHook]}] ((advanced-features.md:207))\n// many[{type.scala.collection.immutable.Set[=PlanningHook]}].add[{type.izumi.distage.planning.AutoSetHook[=MdocSession::App15::PrintResource,=MdocSession::App15::PrintResource]}].from(call(izumi.distage.model.definition.dsl.ModuleDefDSL$SetDSLBase$$Lambda$18583/296849990@4d0a0d68(): izumi.distage.planning.AutoSetHook[=MdocSession::App15::PrintResource,=MdocSession::App15::PrintResource])) ((advanced-features.md:208))\n\nval appModule = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n// appModule: AnyRef with ModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App15::repl.MdocSession.App15.C}].from(call(Class(repl.MdocSession::repl.MdocSession.App15::repl.MdocSession.App15.B): repl.MdocSession::repl.MdocSession.App15::repl.MdocSession.App15.C)) ((advanced-features.md:215))\n// make[{type.repl.MdocSession::repl.MdocSession.App15::repl.MdocSession.App15.A}].from(call(Class(): repl.MdocSession::repl.MdocSession.App15::repl.MdocSession.App15.A)) ((advanced-features.md:213))\n// make[{type.repl.MdocSession::repl.MdocSession.App15::repl.MdocSession.App15.B}].from(call(Class(repl.MdocSession::repl.MdocSession.App15::repl.MdocSession.App15.A): repl.MdocSession::repl.MdocSession.App15::repl.MdocSession.App15.B)) ((advanced-features.md:214))\n\nval resources = Injector(bootstrapModule)\n  .produce(appModule, Roots.Everything)\n  .use(_.get[Set[PrintResource]])\n// resources: izumi.fundamentals.platform.functional.package.Identity[Set[PrintResource]] = ListSet(repl.MdocSession$App15$A@3098bdf6, repl.MdocSession$App15$B@7e6aeb2e, repl.MdocSession$App15$C@1486bb91)\n\nresources.foreach(_.start())\n// A started\n// B started\n// C started\nresources.toSeq.reverse.foreach(_.stop())\n// C stopped\n// B stopped\n// A stopped\nCalling .foreach on an auto-set is safe; the actions will be executed in order of dependencies. Auto-Sets preserve ordering, they use ListSet under the hood, unlike user-defined Sets. e.g. If C depends on B depends on A, autoset order is: A, B, C, to start call: A, B, C, to close call: C, B, A. When you use auto-sets for finalization, you must .reverse the autoset.\nNote: Auto-Sets are NOT subject to Garbage Collection, they are assembled after garbage collection is done, as such they can’t contain garbage by construction. Because of that they also cannot be used as GC Roots.\nSee also: same concept in MacWire","title":"Auto-Sets"},{"location":"/distage/advanced-features.html#weak-sets","text":"Set bindings can contain weak references. References designated as weak will be retained only if there are other dependencies on the referred bindings, NOT if there’s a dependency only on the entire Set.\nExample:\nimport distage._\n\nsealed trait Elem\n\nfinal case class Strong() extends Elem {\n  println(\"Strong constructed\")\n}\n\nfinal case class Weak() extends Elem {\n  println(\"Weak constructed\")\n}\n\nval module = new ModuleDef {\n  make[Strong]\n  make[Weak]\n  \n  many[Elem]\n    .ref[Strong]\n    .weak[Weak]\n}\n// module: AnyRef with ModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App18::repl.MdocSession.App18.Strong}].from(call(Class(): repl.MdocSession::repl.MdocSession.App18::repl.MdocSession.App18.Strong)) ((advanced-features.md:253))\n// many[{type.scala.collection.immutable.Set[=MdocSession::App18::Elem]}].add[{type.repl.MdocSession::repl.MdocSession.App18::repl.MdocSession.App18.Strong}].from(using[{type.repl.MdocSession::repl.MdocSession.App18::repl.MdocSession.App18.Strong}: repl.MdocSession::repl.MdocSession.App18::repl.MdocSession.App18.Strong]) ((advanced-features.md:257))\n// many[{type.scala.collection.immutable.Set[=MdocSession::App18::Elem]}] ((advanced-features.md:256))\n// many[{type.scala.collection.immutable.Set[=MdocSession::App18::Elem]}].add[{type.repl.MdocSession::repl.MdocSession.App18::repl.MdocSession.App18.Weak}].from(weak[{type.repl.MdocSession::repl.MdocSession.App18::repl.MdocSession.App18.Weak}]) ((advanced-features.md:258))\n// make[{type.repl.MdocSession::repl.MdocSession.App18::repl.MdocSession.App18.Weak}].from(call(Class(): repl.MdocSession::repl.MdocSession.App18::repl.MdocSession.App18.Weak)) ((advanced-features.md:254))\n\n// Designate Set[Elem] as the garbage collection root,\n// everything that Set[Elem] does not strongly depend on will be garbage collected\n// and will not be constructed. \n\nval roots = Set[DIKey](DIKey[Set[Elem]])\n// roots: Set[DIKey] = Set({type.scala.collection.immutable.Set[=MdocSession::App18::Elem]})\n\nval objects = Injector().produce(PlannerInput(module, roots)).unsafeGet()\n// Strong constructed\n// objects: izumi.fundamentals.platform.functional.package.Identity[Locator] = izumi.distage.LocatorDefaultImpl@9fa9524\n\n// Strong is around\n\nobjects.find[Strong]\n// res19: Option[Strong] = Some(Strong())\n\n// Weak is not\n\nobjects.find[Strong]\n// res20: Option[Strong] = Some(Strong())\n\n// There's only Strong in the Set\n\nobjects.get[Set[Elem]]\n// res21: Set[Elem] = Set(Strong())\nThe Weak class was not required by any dependency of Set[Elem], so it was pruned. The Strong class remained, because the reference to it was strong, so it was counted as a dependency of Set[Elem].\nIf we change Strong to depend on the Weak, then Weak will be retained:\nfinal class Strong(weak: Weak) extends Elem {\n  println(\"Strong constructed\")\n}\n\nval objects = Injector().produce(PlannerInput(module, roots)).unsafeGet()\n// Weak constructed\n// Strong constructed\n// objects: izumi.fundamentals.platform.functional.package.Identity[Locator] = izumi.distage.LocatorDefaultImpl@7c78eee0\n\n// Weak is around\n\nobjects.find[Weak]\n// res23: Option[Weak] = Some(repl.MdocSession$App22$Weak@556259da)\n\n// both Strong and Weak are in the Set\n\nobjects.get[Set[Elem]]\n// res24: Set[Elem] = Set(repl.MdocSession$App22$Strong@74192ad4, repl.MdocSession$App22$Weak@556259da)","title":"Weak Sets"},{"location":"/distage/advanced-features.html#inner-classes-and-path-dependent-types","text":"Path-dependent types with a value prefix will be instantiated normally:\nimport distage.{Roots, ModuleDef, Injector}\n\nclass Path {\n  class A\n}\nval path = new Path\n// path: Path = repl.MdocSession$App25$Path@2997d2c6\n\ndef module = new ModuleDef {\n  make[path.A]\n}\n\nInjector()\n  .produce(module, Roots.Everything)\n  .use(_.get[path.A])\n// res26: izumi.fundamentals.platform.functional.package.Identity[path.A] = repl.MdocSession$App25$Path$A@12a336fa\nSince version 0.10, support for path-dependent types with a non-value (type) prefix hasn’t reimplemented after a rewrite of the internals, see issue: https://github.com/7mind/izumi/issues/764\nHowever, there’s a gotcha with value prefixes, when seen by distage they’re based on the literal variable name of the prefix, not the full type information available to the compiler, therefore the following usage will fail:\ndef pathModule(p: Path) = new ModuleDef {\n  make[p.A]\n}\n\nval path1 = new Path\n// path1: Path = repl.MdocSession$App25$Path@55c811fd\nval path2 = new Path\n// path2: Path = repl.MdocSession$App25$Path@68bace1a\nInjector()\n  .produceRun(pathModule(path1) ++ pathModule(path2)) {\n    (p1a: path1.A, p2a: path2.A) =>\n      println((p1a, p2a))\n  }\n// izumi.distage.model.exceptions.ProvisioningException: Provisioner stopped after 1 instances, 2/2 operations failed: \n//  - {type.repl.MdocSession::repl.MdocSession.App25::repl.MdocSession.App25.path1::repl.MdocSession.App25.Path.A} (<unknown>), MissingInstanceException: Instance is not available in the object graph: {type.repl.MdocSession::repl.MdocSession.App25::repl.MdocSession.App25.path1::repl.MdocSession.App25.Path.A}.\n// Required by refs:ø\n//  - {type.repl.MdocSession::repl.MdocSession.App25::repl.MdocSession.App25.path2::repl.MdocSession.App25.Path.A} (<unknown>), MissingInstanceException: Instance is not available in the object graph: {type.repl.MdocSession::repl.MdocSession.App25::repl.MdocSession.App25.path2::repl.MdocSession.App25.Path.A}.\n// Required by refs:ø\n// \tat izumi.distage.model.provisioning.PlanInterpreter$FailedProvision.$anonfun$throwException$2(PlanInterpreter.scala:62)\n// \tat izumi.distage.model.effect.DIEffect$$anon$1.fail(DIEffect.scala:97)\n// \tat izumi.distage.model.provisioning.PlanInterpreter$FailedProvision.throwException(PlanInterpreter.scala:63)\n// \tat izumi.distage.model.provisioning.PlanInterpreter$FailedProvision$FailedProvisionExt$.$anonfun$throwOnFailure$1(PlanInterpreter.scala:70)\n// \tat scala.util.Either.fold(Either.scala:190)\n// \tat izumi.distage.model.provisioning.PlanInterpreter$FailedProvision$FailedProvisionExt$.throwOnFailure$extension(PlanInterpreter.scala:70)\n// \tat izumi.distage.InjectorDefaultImpl.$anonfun$produceFX$1(InjectorDefaultImpl.scala:55)\n// \tat izumi.distage.model.definition.DIResource$.$anonfun$evalMapImpl$2(DIResource.scala:706)\n// \tat izumi.distage.model.definition.DIResource$$anon$1.acquire(DIResource.scala:162)\n// \tat izumi.distage.model.definition.DIResource$$anon$11.$anonfun$acquire$9(DIResource.scala:686)\n// \tat izumi.distage.model.effect.DIEffect$$anon$1.bracketCase(DIEffect.scala:87)\n// \tat izumi.distage.model.definition.DIResource$$anon$11.$anonfun$acquire$8(DIResource.scala:672)\n// \tat izumi.distage.model.effect.DIEffect$$anon$1.$anonfun$bracketCase$1(DIEffect.scala:88)\n// \tat scala.util.Try$.apply(Try.scala:210)\n// \tat izumi.distage.model.effect.DIEffect$$anon$1.bracketCase(DIEffect.scala:88)\n// \tat izumi.distage.model.definition.DIResource$$anon$11.acquire(DIResource.scala:672)\n// \tat izumi.distage.model.definition.DIResource$DIResourceUse$.$anonfun$use$extension$1(DIResource.scala:144)\n// \tat izumi.distage.model.effect.DIEffect$$anon$1.bracket(DIEffect.scala:83)\n// \tat izumi.distage.model.Injector.produceRunF(Injector.scala:52)\n// \tat izumi.distage.model.Injector.produceRunF$(Injector.scala:51)\n// \tat izumi.distage.InjectorDefaultImpl.produceRunF(InjectorDefaultImpl.scala:15)\n// \tat izumi.distage.model.Injector.produceRun(Injector.scala:156)\n// \tat izumi.distage.model.Injector.produceRun$(Injector.scala:156)\n// \tat izumi.distage.InjectorDefaultImpl.produceRun(InjectorDefaultImpl.scala:15)\n// \tat repl.MdocSession$App25$$anonfun$65.apply$mcV$sp(advanced-features.md:370)\n// \tat repl.MdocSession$App25$$anonfun$65.apply(advanced-features.md:370)\n// \tat repl.MdocSession$App25$$anonfun$65.apply(advanced-features.md:370)\n// \tSuppressed: izumi.distage.model.exceptions.MissingInstanceException: Instance is not available in the object graph: {type.repl.MdocSession::repl.MdocSession.App25::repl.MdocSession.App25.path1::repl.MdocSession.App25.Path.A}.\n// Required by refs:ø\n// \t\tat izumi.distage.provisioning.strategies.ImportStrategyDefaultImpl.importDependency(ImportStrategyDefaultImpl.scala:15)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.execute(PlanInterpreterDefaultRuntimeImpl.scala:145)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.$anonfun$instantiateImpl$3(PlanInterpreterDefaultRuntimeImpl.scala:77)\n// \t\tat izumi.distage.model.effect.DIEffect$$anon$1.definitelyRecover(DIEffect.scala:75)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.$anonfun$instantiateImpl$2(PlanInterpreterDefaultRuntimeImpl.scala:79)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.$anonfun$instantiateImpl$2$adapted(PlanInterpreterDefaultRuntimeImpl.scala:69)\n// \t\tat izumi.distage.model.effect.DIEffect$$anon$1.flatMap(DIEffect.scala:71)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.processStep$1(PlanInterpreterDefaultRuntimeImpl.scala:68)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.$anonfun$instantiateImpl$14(PlanInterpreterDefaultRuntimeImpl.scala:117)\n// \t\tat izumi.distage.model.effect.DIEffect.$anonfun$traverse_$2(DIEffect.scala:44)\n// \t\tat izumi.distage.model.effect.DIEffect$$anon$1.flatMap(DIEffect.scala:71)\n// \t\tat izumi.distage.model.effect.DIEffect.$anonfun$traverse_$1(DIEffect.scala:44)\n// \t\tat scala.collection.IterableOnceOps.foldLeft(IterableOnce.scala:638)\n// \t\tat scala.collection.IterableOnceOps.foldLeft$(IterableOnce.scala:634)\n// \t\tat scala.collection.AbstractIterable.foldLeft(Iterable.scala:920)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.instantiateImpl(PlanInterpreterDefaultRuntimeImpl.scala:117)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.$anonfun$instantiate$1(PlanInterpreterDefaultRuntimeImpl.scala:42)\n// \t\tat izumi.distage.model.definition.DIResource$$anon$1.acquire(DIResource.scala:162)\n// \t\tat izumi.distage.model.definition.DIResource$$anon$11.$anonfun$acquire$6(DIResource.scala:683)\n// \t\tat izumi.distage.model.effect.DIEffect$$anon$1.bracketCase(DIEffect.scala:87)\n// \t\tat izumi.distage.model.definition.DIResource$$anon$11.acquire(DIResource.scala:672)\n// \t\tat izumi.distage.model.definition.DIResource$DIResourceUse$.$anonfun$use$extension$1(DIResource.scala:144)\n// \t\tat izumi.distage.model.effect.DIEffect$$anon$1.bracket(DIEffect.scala:83)\n// \t\tat izumi.distage.model.Injector.produceRunF(Injector.scala:52)\n// \t\tat izumi.distage.model.Injector.produceRunF$(Injector.scala:51)\n// \t\tat izumi.distage.InjectorDefaultImpl.produceRunF(InjectorDefaultImpl.scala:15)\n// \t\tat izumi.distage.model.Injector.produceRun(Injector.scala:156)\n// \t\tat izumi.distage.model.Injector.produceRun$(Injector.scala:156)\n// \t\tat izumi.distage.InjectorDefaultImpl.produceRun(InjectorDefaultImpl.scala:15)\n// \t\tat repl.MdocSession$App25$$anonfun$65.apply$mcV$sp(advanced-features.md:370)\n// \t\tat repl.MdocSession$App25$$anonfun$65.apply(advanced-features.md:370)\n// \t\tat repl.MdocSession$App25$$anonfun$65.apply(advanced-features.md:370)\n// \t\tat mdoc.internal.document.DocumentBuilder$$doc$.crash(DocumentBuilder.scala:69)\n// \t\tat repl.MdocSession$App25.<init>(advanced-features.md:370)\n// \t\tat repl.MdocSession$App22$.<clinit>(advanced-features.md:324)\n// \t\tat repl.MdocSession$App18$.<clinit>(advanced-features.md:277)\n// \t\tat repl.MdocSession$App15.<init>(advanced-features.md:230)\n// \t\tat repl.MdocSession$App11.<init>(advanced-features.md:176)\n// \t\tat repl.MdocSession$App6$.<clinit>(advanced-features.md:131)\n// \t\tat repl.MdocSession$App4$.<clinit>(advanced-features.md:91)\n// \t\tat repl.MdocSession$App0.<init>(advanced-features.md:51)\n// \t\tat repl.MdocSession$App.<init>(advanced-features.md:5)\n// \t\tat repl.MdocSession$.app(advanced-features.md:3)\n// \t\tat mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:82)\n// \t\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)\n// \t\tat scala.util.DynamicVariable.withValue(DynamicVariable.scala:59)\n// \t\tat scala.Console$.withErr(Console.scala:193)\n// \t\tat mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:82)\n// \t\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)\n// \t\tat scala.util.DynamicVariable.withValue(DynamicVariable.scala:59)\n// \t\tat scala.Console$.withOut(Console.scala:164)\n// \t\tat mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:81)\n// \t\tat mdoc.internal.markdown.MarkdownCompiler$.buildDocument(MarkdownCompiler.scala:61)\n// \t\tat mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:183)\n// \t\tat mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:150)\n// \t\tat mdoc.internal.markdown.Processor.processDocument(Processor.scala:52)\n// \t\tat mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:126)\n// \t\tat mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:81)\n// \t\tat mdoc.internal.cli.MainOps.handleFile(MainOps.scala:109)\n// \t\tat mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:156)\n// \t\tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:168)\n// \t\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:164)\n// \t\tat scala.collection.immutable.List.foldLeft(List.scala:79)\n// \t\tat mdoc.internal.cli.MainOps.generateCompleteSite(MainOps.scala:154)\n// \t\tat mdoc.internal.cli.MainOps.run(MainOps.scala:177)\n// \t\tat mdoc.internal.cli.MainOps$.process(MainOps.scala:269)\n// \t\tat mdoc.Main$.process(Main.scala:26)\n// \t\tat mdoc.Main$.process(Main.scala:21)\n// \t\tat mdoc.Main$.main(Main.scala:16)\n// \t\tat mdoc.Main.main(Main.scala)\n// \t\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n// \t\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n// \t\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n// \t\tat java.lang.reflect.Method.invoke(Method.java:498)\n// \t\tat sbt.Run.invokeMain(Run.scala:115)\n// \t\tat sbt.Run.execute$1(Run.scala:79)\n// \t\tat sbt.Run.$anonfun$runWithLoader$4(Run.scala:92)\n// \t\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n// \t\tat sbt.util.InterfaceUtil$$anon$1.get(InterfaceUtil.scala:10)\n// \t\tat sbt.TrapExit$App.run(TrapExit.scala:257)\n// \t\tat java.lang.Thread.run(Thread.java:748)\n// \tSuppressed: izumi.distage.model.exceptions.MissingInstanceException: Instance is not available in the object graph: {type.repl.MdocSession::repl.MdocSession.App25::repl.MdocSession.App25.path2::repl.MdocSession.App25.Path.A}.\n// Required by refs:ø\n// \t\tat izumi.distage.provisioning.strategies.ImportStrategyDefaultImpl.importDependency(ImportStrategyDefaultImpl.scala:15)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.execute(PlanInterpreterDefaultRuntimeImpl.scala:145)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.$anonfun$instantiateImpl$3(PlanInterpreterDefaultRuntimeImpl.scala:77)\n// \t\tat izumi.distage.model.effect.DIEffect$$anon$1.definitelyRecover(DIEffect.scala:75)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.$anonfun$instantiateImpl$2(PlanInterpreterDefaultRuntimeImpl.scala:79)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.$anonfun$instantiateImpl$2$adapted(PlanInterpreterDefaultRuntimeImpl.scala:69)\n// \t\tat izumi.distage.model.effect.DIEffect$$anon$1.flatMap(DIEffect.scala:71)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.processStep$1(PlanInterpreterDefaultRuntimeImpl.scala:68)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.$anonfun$instantiateImpl$14(PlanInterpreterDefaultRuntimeImpl.scala:117)\n// \t\tat izumi.distage.model.effect.DIEffect.$anonfun$traverse_$2(DIEffect.scala:44)\n// \t\tat izumi.distage.model.effect.DIEffect$$anon$1.flatMap(DIEffect.scala:71)\n// \t\tat izumi.distage.model.effect.DIEffect.$anonfun$traverse_$1(DIEffect.scala:44)\n// \t\tat scala.collection.IterableOnceOps.foldLeft(IterableOnce.scala:638)\n// \t\tat scala.collection.IterableOnceOps.foldLeft$(IterableOnce.scala:634)\n// \t\tat scala.collection.AbstractIterable.foldLeft(Iterable.scala:920)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.instantiateImpl(PlanInterpreterDefaultRuntimeImpl.scala:117)\n// \t\tat izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl.$anonfun$instantiate$1(PlanInterpreterDefaultRuntimeImpl.scala:42)\n// \t\tat izumi.distage.model.definition.DIResource$$anon$1.acquire(DIResource.scala:162)\n// \t\tat izumi.distage.model.definition.DIResource$$anon$11.$anonfun$acquire$6(DIResource.scala:683)\n// \t\tat izumi.distage.model.effect.DIEffect$$anon$1.bracketCase(DIEffect.scala:87)\n// \t\tat izumi.distage.model.definition.DIResource$$anon$11.acquire(DIResource.scala:672)\n// \t\tat izumi.distage.model.definition.DIResource$DIResourceUse$.$anonfun$use$extension$1(DIResource.scala:144)\n// \t\tat izumi.distage.model.effect.DIEffect$$anon$1.bracket(DIEffect.scala:83)\n// \t\tat izumi.distage.model.Injector.produceRunF(Injector.scala:52)\n// \t\tat izumi.distage.model.Injector.produceRunF$(Injector.scala:51)\n// \t\tat izumi.distage.InjectorDefaultImpl.produceRunF(InjectorDefaultImpl.scala:15)\n// \t\tat izumi.distage.model.Injector.produceRun(Injector.scala:156)\n// \t\tat izumi.distage.model.Injector.produceRun$(Injector.scala:156)\n// \t\tat izumi.distage.InjectorDefaultImpl.produceRun(InjectorDefaultImpl.scala:15)\n// \t\tat repl.MdocSession$App25$$anonfun$65.apply$mcV$sp(advanced-features.md:370)\n// \t\tat repl.MdocSession$App25$$anonfun$65.apply(advanced-features.md:370)\n// \t\tat repl.MdocSession$App25$$anonfun$65.apply(advanced-features.md:370)\n// \t\tat mdoc.internal.document.DocumentBuilder$$doc$.crash(DocumentBuilder.scala:69)\n// \t\tat repl.MdocSession$App25.<init>(advanced-features.md:370)\n// \t\tat repl.MdocSession$App22$.<clinit>(advanced-features.md:324)\n// \t\tat repl.MdocSession$App18$.<clinit>(advanced-features.md:277)\n// \t\tat repl.MdocSession$App15.<init>(advanced-features.md:230)\n// \t\tat repl.MdocSession$App11.<init>(advanced-features.md:176)\n// \t\tat repl.MdocSession$App6$.<clinit>(advanced-features.md:131)\n// \t\tat repl.MdocSession$App4$.<clinit>(advanced-features.md:91)\n// \t\tat repl.MdocSession$App0.<init>(advanced-features.md:51)\n// \t\tat repl.MdocSession$App.<init>(advanced-features.md:5)\n// \t\tat repl.MdocSession$.app(advanced-features.md:3)\n// \t\tat mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$2(DocumentBuilder.scala:82)\n// \t\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)\n// \t\tat scala.util.DynamicVariable.withValue(DynamicVariable.scala:59)\n// \t\tat scala.Console$.withErr(Console.scala:193)\n// \t\tat mdoc.internal.document.DocumentBuilder$$doc$.$anonfun$build$1(DocumentBuilder.scala:82)\n// \t\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)\n// \t\tat scala.util.DynamicVariable.withValue(DynamicVariable.scala:59)\n// \t\tat scala.Console$.withOut(Console.scala:164)\n// \t\tat mdoc.internal.document.DocumentBuilder$$doc$.build(DocumentBuilder.scala:81)\n// \t\tat mdoc.internal.markdown.MarkdownCompiler$.buildDocument(MarkdownCompiler.scala:61)\n// \t\tat mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:183)\n// \t\tat mdoc.internal.markdown.Processor.processScalaInputs(Processor.scala:150)\n// \t\tat mdoc.internal.markdown.Processor.processDocument(Processor.scala:52)\n// \t\tat mdoc.internal.markdown.Markdown$.toMarkdown(Markdown.scala:126)\n// \t\tat mdoc.internal.cli.MainOps.handleMarkdown(MainOps.scala:81)\n// \t\tat mdoc.internal.cli.MainOps.handleFile(MainOps.scala:109)\n// \t\tat mdoc.internal.cli.MainOps.$anonfun$generateCompleteSite$1(MainOps.scala:156)\n// \t\tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:168)\n// \t\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:164)\n// \t\tat scala.collection.immutable.List.foldLeft(List.scala:79)\n// \t\tat mdoc.internal.cli.MainOps.generateCompleteSite(MainOps.scala:154)\n// \t\tat mdoc.internal.cli.MainOps.run(MainOps.scala:177)\n// \t\tat mdoc.internal.cli.MainOps$.process(MainOps.scala:269)\n// \t\tat mdoc.Main$.process(Main.scala:26)\n// \t\tat mdoc.Main$.process(Main.scala:21)\n// \t\tat mdoc.Main$.main(Main.scala:16)\n// \t\tat mdoc.Main.main(Main.scala)\n// \t\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n// \t\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n// \t\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n// \t\tat java.lang.reflect.Method.invoke(Method.java:498)\n// \t\tat sbt.Run.invokeMain(Run.scala:115)\n// \t\tat sbt.Run.execute$1(Run.scala:79)\n// \t\tat sbt.Run.$anonfun$runWithLoader$4(Run.scala:92)\n// \t\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\n// \t\tat sbt.util.InterfaceUtil$$anon$1.get(InterfaceUtil.scala:10)\n// \t\tat sbt.TrapExit$App.run(TrapExit.scala:257)\n// \t\tat java.lang.Thread.run(Thread.java:748)\nThis will fail because while path1.A and p.A inside new ModuleDef are the same type, the varialbes path1 & p are spelled differently and this causes a mismatch.\nThere’s one way to workaround this - turn the type member A into a type parameter using the Aux Pattern, and then for that type parameter in turn, summon the type information using Tag implicit (as described in Tagless Final Style chapter) and summon the constructor using the ClassConstructor implicit, example:\nimport distage.{ClassConstructor, Roots, ModuleDef, Injector, Tag}\n\nobject Path {\n  type Aux[A0] = Path { type A = A0 }\n}\n\ndef pathModule[A: Tag: ClassConstructor](p: Path.Aux[A]) = new ModuleDef {\n  make[A]\n}\n\nval path1 = new Path\n// path1: Path = repl.MdocSession$App27$Path@5b3caab8\nval path2 = new Path\n// path2: Path = repl.MdocSession$App27$Path@a995608\n\nInjector()\n  .produceRun(pathModule(path1) ++ pathModule(path2)) {\n    (p1a: path1.A, p2a: path2.A) =>\n      println((p1a, p2a))\n  }\n// (repl.MdocSession$App27$Path$A@3ae71662,repl.MdocSession$App27$Path$A@6f2825a3)\nNow the example works, because the A inside pathModule is path1.A & path2.A respectively, the same as it is later in produceRun","title":"Inner Classes and Path-Dependent Types"},{"location":"/distage/advanced-features.html#depending-on-locator","text":"Objects can depend on the outer object graph that contains them (Locator), by including a LocatorRef parameter:\nimport distage.{ModuleDef, LocatorRef, Injector, Roots}\n\nclass A(\n  objects: LocatorRef\n) {\n  def c = objects.get.get[C]\n}\nclass B\nclass C\n\ndef module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n\nval objects = Injector().produce(module, Roots.Everything).unsafeGet()\n// objects: izumi.fundamentals.platform.functional.package.Identity[izumi.distage.model.Locator] = izumi.distage.LocatorDefaultImpl@40b3baf4\n\n// A took C from the object graph\n\nobjects.get[A].c\n// res30: C = repl.MdocSession$App29$C@a9a9fc\n\n// this C is the same C as in this `objects` value\n\nval thisC = objects.get[C]\n// thisC: C = repl.MdocSession$App29$C@a9a9fc\nval thatC = objects.get[A].c\n// thatC: C = repl.MdocSession$App29$C@a9a9fc\n\nassert(thisC == thatC)\nLocator contains metadata about the plan and the bindings from which it was ultimately created:\nimport distage.{OrderedPlan, ModuleBase}\n\n// Plan that created this locator (after GC)\n\nval plan: OrderedPlan = objects.plan\n// plan: OrderedPlan = \n// {type.LocatorRef} (advanced-features.md:440) := import {type.izumi.distage.model.recursive.LocatorRef} // required for {type.MdocSession::App29::A}\n// {type.Activation} (InjectorDefaultImpl.scala:67) := value izumi.distage.model.definition.Activation#-1609326920\n// {type.MdocSession::App29::B} (advanced-features.md:441) := call(Class(): MdocSession::App29::B) {}\n// {type.MdocSession::App29::C} (advanced-features.md:442) := call(Class(): MdocSession::App29::C) {}\n// {type.InjectorFactory} (InjectorDefaultImpl.scala:65) := value distage.Injector$#1884454729\n// {type.BootstrapModule} (InjectorDefaultImpl.scala:66) := value izumi.distage.model.definition.BootstrapModule$$anon$1#1250235420\n// {type.PlannerInput} (InjectorDefaultImpl.scala:64) := value izumi.distage.model.PlannerInput#-43881630\n// {type.MdocSession::App29::A} (advanced-features.md:440) := call(Class(LocatorRef): MdocSession::App29::A) {\n//   arg objects: LocatorRef = lookup({type.LocatorRef})\n// }\n// {type.Bootloader} (InjectorDefaultImpl.scala:68) := call(Class(BootstrapModule, Activation, PlannerInput, InjectorFactory): Bootloader) {\n//   arg bootstrapModule: BootstrapModule = lookup({type.BootstrapModule})\n//   arg activation: Activation = lookup({type.Activation})\n//   arg input: PlannerInput = lookup({type.PlannerInput})\n//   arg injectorFactory: InjectorFactory = lookup({type.InjectorFactory})\n// }\n\n// Bindings from which the Plan was built (after GC)\n\nval bindings: ModuleBase = plan.definition\n// bindings: ModuleBase = \n// make[{type.repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.B}].from(call(Class(): repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.B)) ((advanced-features.md:441))\n// make[{type.repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.A}].from(call(Class(izumi.distage.model.recursive.LocatorRef): repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.A)) ((advanced-features.md:440))\n// make[{type.izumi.distage.model.definition.BootstrapModule}].from(value(\n// make[{type.izumi.distage.model.planning.PlanningHook}].from(call(Class(scala.collection.immutable.Set[=PlanningHook]): izumi.distage.planning.PlanningHookAggregate)) ((BootstrapLocator.scala:150))\n// make[{type.izumi.distage.model.provisioning.strategies.SetStrategy}].from(call(Class(): izumi.distage.provisioning.strategies.SetStrategyDefaultImpl)) ((BootstrapLocator.scala:137))\n// make[{type.izumi.distage.planning.BindingTranslator}].from(call(Class(izumi.distage.model.planning.PlanningHook): izumi.distage.planning.BindingTranslator::izumi.distage.planning.BindingTranslator.Impl)) ((BootstrapLocator.scala:152))\n// make[{type.izumi.distage.model.provisioning.strategies.ProviderStrategy}].from(call(Class(): izumi.distage.provisioning.strategies.ProviderStrategyDefaultImpl)) ((BootstrapLocator.scala:138))\n// make[{type.izumi.distage.model.planning.PlanAnalyzer}].from(call(Class(): izumi.distage.planning.PlanAnalyzerDefaultImpl)) ((BootstrapLocator.scala:132))\n// make[{type.izumi.distage.model.provisioning.strategies.ProxyStrategy}].from(call(Class(izumi.distage.model.provisioning.proxies.ProxyProvider, izumi.distage.model.reflection.MirrorProvider): izumi.distage.provisioning.strategies.ProxyStrategyDefaultImpl)) ((BootstrapLocator.scala:154))\n// make[{type.izumi.distage.model.planning.ForwardingRefResolver}].from(call(Class(izumi.distage.model.planning.PlanAnalyzer, scala.Boolean): izumi.distage.planning.ForwardingRefResolverDefaultImpl)) ((BootstrapLocator.scala:134))\n// make[{type.izumi.distage.model.provisioning.ProvisioningFailureInterceptor}].from(call(Class(): izumi.distage.model.provisioning.ProvisioningFailureInterceptor::izumi.distage.model.provisioning.ProvisioningFailureInterceptor.DefaultImpl)) ((BootstrapLocator.scala:144))\n// make[{type.izumi.distage.model.definition.Activation}].from(value(Activation(Map()): izumi.distage.model.definition.Activation)) ((BootstrapLocator.scala:34))\n// make[{type.izumi.distage.model.provisioning.strategies.EffectStrategy}].from(call(Class(): izumi.distage.provisioning.strategies.EffectStrategyDefaultImpl)) ((BootstrapLocator.scala:141))\n// make[{type.izumi.distage.model.provisioning.PlanInterpreter}].from(call(Class(izumi.distage.model.provisioning.strategies.SetStrategy, izumi.distage.model.provisioning.strategies.ProxyStrategy, izumi.distage.model.provisioning.strategies.ProviderStrategy, izumi.distage.model.provisioning.strategies.ImportStrategy, izumi.distage.model.provisioning.strategies.InstanceStrategy, izumi.distage.model.provisioning.strategies.EffectStrategy, izumi.distage.model.provisioning.strategies.ResourceStrategy, izumi.distage.model.provisioning.ProvisioningFailureInterceptor, izumi.distage.provisioning.ProvisionOperationVerifier): izumi.distage.provisioning.PlanInterpreterDefaultRuntimeImpl)) ((BootstrapLocator.scala:143))\n// make[{type.izumi.distage.model.planning.SanityChecker}].from(call(Class(izumi.distage.model.planning.PlanAnalyzer): izumi.distage.planning.SanityCheckerDefaultImpl)) ((BootstrapLocator.scala:135))\n// make[{type.izumi.distage.model.provisioning.strategies.ResourceStrategy}].from(call(Class(): izumi.distage.provisioning.strategies.ResourceStrategyDefaultImpl)) ((BootstrapLocator.scala:142))\n// make[{type.izumi.distage.model.provisioning.strategies.InstanceStrategy}].from(call(Class(): izumi.distage.provisioning.strategies.InstanceStrategyDefaultImpl)) ((BootstrapLocator.scala:140))\n// many[{type.scala.collection.immutable.Set[=PlanningHook]}] ((BootstrapLocator.scala:147))\n// make[{type.izumi.distage.model.provisioning.proxies.ProxyProvider}].from(call(Class(): izumi.distage.provisioning.strategies.cglib.CglibProxyProvider)) ((CglibBootstrap.scala:11))\n// many[{type.scala.collection.immutable.Set[=PlanningObserver]}] ((BootstrapLocator.scala:146))\n// make[{type.izumi.distage.model.planning.DIGarbageCollector}].from(call(Singleton(): izumi.distage.planning.gc.TracingDIGC)) ((BootstrapLocator.scala:130))\n// make[{type.izumi.distage.model.Planner}].from(call(Class(izumi.distage.model.planning.ForwardingRefResolver, izumi.distage.model.planning.SanityChecker, izumi.distage.model.planning.DIGarbageCollector, izumi.distage.model.planning.PlanningObserver, izumi.distage.model.planning.PlanMergingPolicy, izumi.distage.model.planning.PlanningHook, izumi.distage.planning.BindingTranslator, izumi.distage.model.planning.PlanAnalyzer, izumi.distage.model.reflection.MirrorProvider): izumi.distage.planning.PlannerDefaultImpl)) ((BootstrapLocator.scala:136))\n// make[{type.izumi.distage.model.provisioning.strategies.ImportStrategy}].from(call(Class(): izumi.distage.provisioning.strategies.ImportStrategyDefaultImpl)) ((BootstrapLocator.scala:139))\n// make[{type.izumi.distage.model.planning.PlanMergingPolicy}].from(call(Class(izumi.distage.model.definition.Activation): izumi.distage.planning.PruningPlanMergingPolicyDefaultImpl)) ((BootstrapLocator.scala:133))\n// make[{type.izumi.distage.model.reflection.MirrorProvider}].from(value(izumi.distage.model.reflection.MirrorProvider$Impl$@102ab816: izumi.distage.model.reflection.MirrorProvider::izumi.distage.model.reflection.MirrorProvider.Impl)) ((BootstrapLocator.scala:129))\n// make[{type.izumi.distage.provisioning.ProvisionOperationVerifier}].from(call(Class(izumi.distage.model.reflection.MirrorProvider): izumi.distage.provisioning.ProvisionOperationVerifier::izumi.distage.provisioning.ProvisionOperationVerifier.Default)) ((BootstrapLocator.scala:127))\n// make[{type.izumi.distage.model.planning.PlanningObserver}].from(call(Class(scala.collection.immutable.Set[=PlanningObserver]): izumi.distage.planning.PlanningObserverAggregate)) ((BootstrapLocator.scala:149))\n// make[{type.scala.Boolean@distage.init-proxies-asap}].from(value(true: scala.Boolean)) ((BootstrapLocator.scala:125)): izumi.distage.model.definition.BootstrapModule)) ((InjectorDefaultImpl.scala:66))\n// make[{type.izumi.distage.model.PlannerInput}].from(value(PlannerInput(\n// make[{type.repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.B}].from(call(Class(): repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.B)) ((advanced-features.md:441))\n// make[{type.repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.A}].from(call(Class(izumi.distage.model.recursive.LocatorRef): repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.A)) ((advanced-features.md:440))\n// make[{type.repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.C}].from(call(Class(): repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.C)) ((advanced-features.md:442)),Everything): izumi.distage.model.PlannerInput)) ((InjectorDefaultImpl.scala:64))\n// make[{type.izumi.distage.model.definition.Activation}].from(value(Activation(Map()): izumi.distage.model.definition.Activation)) ((InjectorDefaultImpl.scala:67))\n// make[{type.repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.C}].from(call(Class(): repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.C)) ((advanced-features.md:442))\n// make[{type.izumi.distage.InjectorFactory}].from(value(distage.Injector$@70527f49: izumi.distage.InjectorFactory)) ((InjectorDefaultImpl.scala:65))\n// make[{type.izumi.distage.model.recursive.Bootloader}].from(call(Class(izumi.distage.model.definition.BootstrapModule, izumi.distage.model.definition.Activation, izumi.distage.model.PlannerInput, izumi.distage.InjectorFactory): izumi.distage.model.recursive.Bootloader)) ((InjectorDefaultImpl.scala:68))\nThe plan and bindings in Locator are saved in the state they were AFTER Garbage Collection has been performed. Objects can request the original input via a PlannerInput parameter:\nimport distage.{DIKey, Roots, ModuleDef, PlannerInput, Injector}\n\nclass InjectionInfo(val plannerInput: PlannerInput)\n\nval module = new ModuleDef {\n  make[InjectionInfo]\n}\n// module: AnyRef with ModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.InjectionInfo}].from(call(Class(izumi.distage.model.PlannerInput): repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.InjectionInfo)) ((advanced-features.md:486))\n\nval input = PlannerInput(module, Roots(root = DIKey[InjectionInfo]))\n// input: PlannerInput = PlannerInput(\n// make[{type.repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.InjectionInfo}].from(call(Class(izumi.distage.model.PlannerInput): repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.InjectionInfo)) ((advanced-features.md:486)),Of(NonEmptySet({type.repl.MdocSession::repl.MdocSession.App32::repl.MdocSession.App32.InjectionInfo})))\n\nval injectionInfo = Injector().produce(input).unsafeGet().get[InjectionInfo]\n// injectionInfo: InjectionInfo = repl.MdocSession$App32$InjectionInfo@7c8b0e2\n\n// the PlannerInput in `InjectionInfo` is the same as `input`\n\nassert(injectionInfo.plannerInput == input)\nBootloader is another summonable parameter that contains the above information in aggregate and lets you create another object graph from the same inputs as the current or with alterations.","title":"Depending on Locator"},{"location":"/distage/debugging.html","text":"","title":"Debugging"},{"location":"/distage/debugging.html#debugging","text":"Testing Plans Pretty-printing plans Graphviz rendering","title":"Debugging"},{"location":"/distage/debugging.html#testing-plans","text":"Use OrderedPlan#assertImportsResolvedOrThrow method to test whether all dependencies in a given plan are present and the plan will execute correctly when passed to Injector#produce.\nimport distage.{DIKey, Roots, ModuleDef, Injector}\n\nclass A(b: B)\nclass B\n\nval badModule = new ModuleDef {\n  make[A]\n}\n// badModule: AnyRef with ModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A}].from(call(Class(repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A)) ((debugging.md:21))\n\nval badPlan = Injector().plan(badModule, Roots.Everything)\n// badPlan: izumi.distage.model.plan.OrderedPlan = \n// {type.MdocSession::App0::B} (debugging.md:21) := import {type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B} // required for {type.MdocSession::App0::A}\n// {type.Activation} (InjectorDefaultImpl.scala:67) := value izumi.distage.model.definition.Activation#-1609326920\n// {type.InjectorFactory} (InjectorDefaultImpl.scala:65) := value distage.Injector$#1884454729\n// {type.BootstrapModule} (InjectorDefaultImpl.scala:66) := value izumi.distage.model.definition.BootstrapModule$$anon$1#1250235420\n// {type.PlannerInput} (InjectorDefaultImpl.scala:64) := value izumi.distage.model.PlannerInput#130417567\n// {type.MdocSession::App0::A} (debugging.md:21) := call(Class(MdocSession::App0::B): MdocSession::App0::A) {\n//   arg b: MdocSession::App0::B = lookup({type.MdocSession::App0::B})\n// }\n// {type.Bootloader} (InjectorDefaultImpl.scala:68) := call(Class(BootstrapModule, Activation, PlannerInput, InjectorFactory): Bootloader) {\n//   arg bootstrapModule: BootstrapModule = lookup({type.BootstrapModule})\n//   arg activation: Activation = lookup({type.Activation})\n//   arg input: PlannerInput = lookup({type.PlannerInput})\n//   arg injectorFactory: InjectorFactory = lookup({type.InjectorFactory})\n// }\nbadPlan.assertImportsResolvedOrThrow\n// izumi.distage.model.exceptions.InvalidPlanException: \n// - Instance is not available in the object graph: {type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B}.\n// Required by refs:\n//  * {type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A}\n// \tat izumi.distage.model.plan.impl.OrderedPlanOps.$anonfun$assertImportsResolved$1(OrderedPlanOps.scala:43)\n// \tat scala.util.Either$LeftProjection.map(Either.scala:614)\n// \tat izumi.distage.model.plan.impl.OrderedPlanOps.assertImportsResolved(OrderedPlanOps.scala:42)\n// \tat izumi.distage.model.plan.impl.OrderedPlanOps.assertImportsResolved$(OrderedPlanOps.scala:39)\n// \tat izumi.distage.model.plan.OrderedPlan.assertImportsResolved(AbstractPlan.scala:38)\n// \tat izumi.distage.model.plan.impl.OrderedPlanOps.assertImportsResolvedOrThrow(OrderedPlanOps.scala:53)\n// \tat izumi.distage.model.plan.impl.OrderedPlanOps.assertImportsResolvedOrThrow$(OrderedPlanOps.scala:52)\n// \tat repl.MdocSession$App0$$anonfun$4.apply$mcV$sp(debugging.md:32)\n// \tat repl.MdocSession$App0$$anonfun$4.apply(debugging.md:32)\n// \tat repl.MdocSession$App0$$anonfun$4.apply(debugging.md:32)\nval goodModule = new ModuleDef {\n  make[A]\n  make[B]\n}\n// goodModule: AnyRef with ModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B}].from(call(Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B)) ((debugging.md:41))\n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A}].from(call(Class(repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A)) ((debugging.md:40))\n\nval plan = Injector().plan(goodModule, Roots.Everything)\n// plan: izumi.distage.model.plan.OrderedPlan = \n// {type.Activation} (InjectorDefaultImpl.scala:67) := value izumi.distage.model.definition.Activation#-1609326920\n// {type.MdocSession::App0::B} (debugging.md:41) := call(Class(): MdocSession::App0::B) {}\n// {type.InjectorFactory} (InjectorDefaultImpl.scala:65) := value distage.Injector$#1884454729\n// {type.BootstrapModule} (InjectorDefaultImpl.scala:66) := value izumi.distage.model.definition.BootstrapModule$$anon$1#1250235420\n// {type.PlannerInput} (InjectorDefaultImpl.scala:64) := value izumi.distage.model.PlannerInput#-2018675589\n// {type.MdocSession::App0::A} (debugging.md:40) := call(Class(MdocSession::App0::B): MdocSession::App0::A) {\n//   arg b: MdocSession::App0::B = lookup({type.MdocSession::App0::B})\n// }\n// {type.Bootloader} (InjectorDefaultImpl.scala:68) := call(Class(BootstrapModule, Activation, PlannerInput, InjectorFactory): Bootloader) {\n//   arg bootstrapModule: BootstrapModule = lookup({type.BootstrapModule})\n//   arg activation: Activation = lookup({type.Activation})\n//   arg input: PlannerInput = lookup({type.PlannerInput})\n//   arg injectorFactory: InjectorFactory = lookup({type.InjectorFactory})\n// }\n\nplan.assertImportsResolvedOrThrow","title":"Testing Plans"},{"location":"/distage/debugging.html#pretty-printing-plans","text":"You can print the output of plan.render() to get detailed info on what will happen during instantiation. The printout includes source and line numbers so your IDE can show you where the binding was defined!\nprintln(plan.render())\n// {type.Activation} (InjectorDefaultImpl.scala:67) := value izumi.distage.model.definition.Activation#-1609326920\n// {type.MdocSession::App0::B} (debugging.md:41) := call(Class(): MdocSession::App0::B) {}\n// {type.InjectorFactory} (InjectorDefaultImpl.scala:65) := value distage.Injector$#1884454729\n// {type.BootstrapModule} (InjectorDefaultImpl.scala:66) := value izumi.distage.model.definition.BootstrapModule$$anon$1#1250235420\n// {type.PlannerInput} (InjectorDefaultImpl.scala:64) := value izumi.distage.model.PlannerInput#-2018675589\n// {type.MdocSession::App0::A} (debugging.md:40) := call(Class(MdocSession::App0::B): MdocSession::App0::A) {\n//   arg b: MdocSession::App0::B = lookup({type.MdocSession::App0::B})\n// }\n// {type.Bootloader} (InjectorDefaultImpl.scala:68) := call(Class(BootstrapModule, Activation, PlannerInput, InjectorFactory): Bootloader) {\n//   arg bootstrapModule: BootstrapModule = lookup({type.BootstrapModule})\n//   arg activation: Activation = lookup({type.Activation})\n//   arg input: PlannerInput = lookup({type.PlannerInput})\n//   arg injectorFactory: InjectorFactory = lookup({type.InjectorFactory})\n// }\nYou can also query a plan to see the dependencies and reverse dependencies of a specific class and their order of instantiation:\n// Print dependencies\nprintln(plan.topology.dependencies.tree(DIKey[A]))\n// DepNode({type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A},DependencyGraph(HashMap({type.izumi.distage.model.definition.Activation} -> Set(), {type.izumi.distage.model.recursive.Bootloader} -> Set({type.izumi.distage.model.PlannerInput}, {type.izumi.distage.model.definition.Activation}, {type.izumi.distage.model.definition.BootstrapModule}, {type.izumi.distage.InjectorFactory}), {type.izumi.distage.InjectorFactory} -> Set(), {type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B} -> Set(), {type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A} -> Set({type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B}), {type.izumi.distage.model.definition.BootstrapModule} -> Set(), {type.izumi.distage.model.PlannerInput} -> Set()),Depends),0,None,Set())\n\n// Print reverse dependencies\nprintln(plan.topology.dependees.tree(DIKey[B]))\n// DepNode({type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B},DependencyGraph(HashMap({type.izumi.distage.model.definition.Activation} -> Set({type.izumi.distage.model.recursive.Bootloader}), {type.izumi.distage.model.recursive.Bootloader} -> Set(), {type.izumi.distage.InjectorFactory} -> Set({type.izumi.distage.model.recursive.Bootloader}), {type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B} -> Set({type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A}), {type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A} -> Set(), {type.izumi.distage.model.definition.BootstrapModule} -> Set({type.izumi.distage.model.recursive.Bootloader}), {type.izumi.distage.model.PlannerInput} -> Set({type.izumi.distage.model.recursive.Bootloader})),Required),0,None,Set())\nThe printer highlights circular dependencies:\nTo debug macros used by distage you may use the following Java Properties:\nsbt -Dizumi.debug.macro.rtti=true compile # fundamentals-reflection & LightTypeTag macros\nsbt -Dizumi.debug.macro.distage.constructors=true compile # izumi.distage.constructors.* macros\nsbt -Dizumi.debug.macro.distage.providermagnet=true compile # ProviderMagnet macro","title":"Pretty-printing plans"},{"location":"/distage/debugging.html#graphviz-rendering","text":"Add GraphDumpBootstrapModule to your Injector’s configuration to enable dumping of graphviz files with a graphical representation of the Plan.\nimport distage.GraphDumpBootstrapModule\n\nval injector = Injector(GraphDumpBootstrapModule())\n// injector: Injector = izumi.distage.InjectorDefaultImpl@5e331aa3\nData will be saved dumped to ./target/plan-last-full.gv and ./target/plan-last-nogc.gv in current working directory.\nYou’ll need a GraphViz installation to render these files into a viewable PNG images:\ndot -Tpng target/plan-last-nogc.gv -o out.png","title":"Graphviz rendering"},{"location":"/distage/distage-framework.html","text":"","title":"distage-framework"},{"location":"/distage/distage-framework.html#distage-framework","text":"Roles Typesafe Config Plugins Compile-time checks","title":"distage-framework"},{"location":"/distage/distage-framework.html#roles","text":"A “Role” is an entrypoint for a specific application hosted in a larger software suite. Bundling multiple roles in a single .jar file can simplify deployment and operations.\ndistage-framework module contains the distage Role API:\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-framework\" % \"0.10.16\"\nWith default RoleAppLauncherImpl, roles to launch are specified on the command-line: ./launcher role1 role2 role3. Only the components required by the specified roles will be created, everything else will be pruned. (see: GC)\nTwo roles are bundled by default: Help and ConfigWriter.\nFurther reading: Roles: a viable alternative to Microservices","title":"Roles"},{"location":"/distage/distage-framework.html#typesafe-config","text":"distage-extension-config library allows summoning case classes and sealed traits from typesafe-config configuration\nTo use it, add distage-extension-config library:\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-extension-config\" % \"0.10.16\"\nUse helper functions in ConfigModuleDef to parse the Typesafe Config instance bound to AppConfig into case classes:\nimport distage.{DIKey, Roots, ModuleDef, Id, Injector}\nimport distage.config.{AppConfig, ConfigModuleDef}\nimport com.typesafe.config.ConfigFactory\n\nfinal case class Conf(name: String, age: Int)\n\nfinal case class OtherConf(other: Boolean)\n\nfinal class ConfigPrinter(conf: Conf, otherConf: OtherConf @Id(\"other\")) {\n  def print() = {\n    println(s\"name: ${conf.name}, age: ${conf.age}, other: ${otherConf.other}\")\n  }\n}\n\nval module = new ConfigModuleDef {\n  make[ConfigPrinter]\n\n  // declare paths to parse\n  makeConfig[Conf](\"conf\")\n  makeConfig[OtherConf](\"conf\").named(\"other\")\n \n  // add config instance\n  make[AppConfig].from(AppConfig(ConfigFactory.parseString(\n    \"\"\"conf {\n      |  name = \"John\"\n      |  age = 33\n      |  other = true\n      |}\"\"\".stripMargin\n  )))\n}\n// module: AnyRef with ConfigModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.OtherConf@other}].from(call(izumi.distage.config.ConfigModuleDef$$$Lambda$20331/822049352@6666a6a6(izumi.distage.config.model.AppConfig): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.OtherConf)).tagged(Set(ConfTag(conf))) ((distage-framework.md:38))\n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.ConfigPrinter}].from(call(Class(repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Conf, repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.OtherConf): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.ConfigPrinter)) ((distage-framework.md:34))\n// make[{type.izumi.distage.config.model.AppConfig}].from(call(izumi.distage.model.definition.dsl.ModuleDefDSL$MakeDSLBase$$Lambda$19802/1248558164@50b7248c(): izumi.distage.config.model.AppConfig)) ((distage-framework.md:41))\n// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Conf}].from(call(izumi.distage.config.ConfigModuleDef$$$Lambda$20331/822049352@6892ff09(izumi.distage.config.model.AppConfig): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Conf)).tagged(Set(ConfTag(conf))) ((distage-framework.md:37))\n\nInjector().produceRun(module) {\n  configPrinter: ConfigPrinter =>\n    configPrinter.print()\n} \n// name: John, age: 33, other: true\nAutomatic derivation of config codecs is based on pureconfig-magnolia. Pureconfig codecs for a type will be used if they exist.\nYou don’t have to explicitly make[AppConfig] in distage-testkit’s tests and in distage-framework’s Roles, unless you want to override default behavior. By default, tests and roles will try to read the configurations from resources with the following names, in order:\n- $roleName.conf\n- $roleName-reference.conf\n- $roleName-reference-dev.conf\n- application.conf\n- application-reference.conf\n- application-reference-dev.conf\n- common.conf\n- common-reference.conf\n- common-reference-dev.conf\nWhere distage-testkit uses TestConfig#testBaseName instead of roleName","title":"Typesafe Config"},{"location":"/distage/distage-framework.html#plugins","text":"distage-extension-plugins module adds classpath discovery for modules that inherit a marker trait PluginBase. Plugins enable extreme late-binding; e.g. they allow a program to extend itself at launch time with new Plugin classes on the classpath. Plugins are compatible with compile-time checks as long as they’re defined in a separate module.\nTo use plugins, first add the distage-extension-plugins library:\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-extension-plugins\" % \"0.10.16\"\nCreate a module extending the PluginDef trait instead of ModuleDef:\n// package com.example.petstore\n\nimport distage._\nimport distage.plugins._\n\nobject PetStorePlugin extends PluginDef {\n  make[PetRepository]\n  make[PetStoreService]\n  make[PetStoreController]\n}\nCollect all PluginDefs in a package:\nval pluginConfig = PluginConfig.cached(\n  packagesEnabled = Seq(\"com.example.petstore\") // packages to scan\n)\n// pluginConfig: PluginConfig = PluginConfig(List(com.example.petstore),List(),true,false,List(),List())\n\nval appModules = PluginLoader().load(pluginConfig)\n// appModules: Seq[PluginBase] = List(\n// make[{type.com.example.petstore.PetRepository}].from(call(Class(): com.example.petstore.PetRepository)) ((PetStorePlugin.scala:6))\n// make[{type.com.example.petstore.PetStoreController}].from(call(Class(): com.example.petstore.PetStoreController)) ((PetStorePlugin.scala:8))\n// make[{type.com.example.petstore.PetStoreService}].from(call(Class(): com.example.petstore.PetStoreService)) ((PetStorePlugin.scala:7)))\nExecute collected modules as usual:\n// combine all modules into one\n\nval appModule = appModules.merge\n// appModule: PluginBase = \n// make[{type.com.example.petstore.PetRepository}].from(call(Class(): com.example.petstore.PetRepository)) ((PetStorePlugin.scala:6))\n// make[{type.com.example.petstore.PetStoreController}].from(call(Class(): com.example.petstore.PetStoreController)) ((PetStorePlugin.scala:8))\n// make[{type.com.example.petstore.PetStoreService}].from(call(Class(): com.example.petstore.PetStoreService)) ((PetStorePlugin.scala:7))\n\n// launch\n\nInjector()\n  .produceGet[PetStoreController](appModule)\n  .use(_.run())\n// PetStoreController: running!\n// res4: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()","title":"Plugins"},{"location":"/distage/distage-framework.html#compile-time-checks","text":"An experimental compile-time verification API is available in the distage-framework module.\nTo use it add distage-framework library:\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-framework\" % \"0.10.16\"\nOnly plugins defined in a different module can be checked at compile-time, test scope counts as a different module.\nExample:\nIn main scope:\n// package com.example\n\nimport distage.DIKey\nimport distage.StandardAxis.Env\nimport distage.config.ConfigModuleDef\nimport distage.plugins.PluginDef\nimport izumi.distage.staticinjector.plugins.ModuleRequirements\n\nfinal case class HostPort(host: String, port: Int)\n\nfinal case class Config(hostPort: HostPort)\n\nfinal class Service(conf: Config, otherService: OtherService)\nfinal class OtherService\n\n// error: OtherService is not bound here, even though Service depends on it\nfinal class AppPlugin extends PluginDef with ConfigModuleDef {\n  tag(Env.Prod)\n  \n  make[Service]\n  makeConfig[Config](\"config\")\n}\n\n// Declare OtherService as an external dependency\nfinal class AppRequirements extends ModuleRequirements(\n  // If we remove this line, compilation will rightfully break\n  Set(DIKey[OtherService])\n)\nIn config:\n// src/main/resources/application.conf\nconfig {\n  host = localhost\n  port = 8080\n}\nIn test scope:\n// package com.example.test\n\nimport com.example._\nimport org.scalatest.wordspec.AnyWordSpec\nimport izumi.distage.staticinjector.plugins.StaticPluginChecker\n\nfinal class AppPluginTest extends AnyWordSpec {\n  \"App plugin will work (if OtherService is provided later)\" in {\n    StaticPluginChecker.checkWithConfig[AppPlugin, AppRequirements](\"env:prod\", \".*.application.conf\")   \n  }\n}\ncheckWithConfig will run at compile-time whenever AppPluginTest is recompiled.\nNote: Since version 0.10.0, configuration files are no longer checked for correctness by the compile-time checker, see: https://github.com/7mind/izumi/issues/763","title":"Compile-time checks"},{"location":"/distage/distage-framework-docker.html","text":"","title":"distage-framework-docker"},{"location":"/distage/distage-framework-docker.html#distage-framework-docker","text":"Key Features Dependencies Overview Setup 1. Create a ContainerDef 2. Declare Container Components 3. Include the DockerSupportModule Config API modifyConfig dependOnDocker Availability and Health Checks Usage in Integration Tests Docker Container Environment Docker Metadata Docker Container Networks 1. Create a ContainerNetworkDef 2. Add to Container Config Container Network Reuse Docker Client Configuration Container Reuse Matching Containers for Reuse Configuring Reuse Improving Reuse Performance Examples Tips Troubleshooting References","title":"distage-framework-docker"},{"location":"/distage/distage-framework-docker.html#key-features","text":"Provides Docker containers as resources Reasonable defaults with flexible configuration Excellent for providing Docker implementations of services for integration tests","title":"Key Features"},{"location":"/distage/distage-framework-docker.html#dependencies","text":"Add the distage-framework-docker library:\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-framework-docker\" % \"0.10.16\"","title":"Dependencies"},{"location":"/distage/distage-framework-docker.html#overview","text":"Usage of distage-framework-docker generally follows these steps:\nCreate ContainerDefs for the containers the application requires Create a module that declares the container component Include the DockerSupportModule in the application’s modules","title":"Overview"},{"location":"/distage/distage-framework-docker.html#setup","text":"Required imports:\nimport izumi.distage.docker.ContainerDef\nimport izumi.distage.docker.Docker\nimport izumi.distage.model.definition.ModuleDef\nimport izumi.reflect.TagK","title":"Setup"},{"location":"/distage/distage-framework-docker.html#1-create-a-containerdef","text":"The ContainerDef is a trait used to define a Docker container. Extend this trait and provide an implementation of the config method.\nThe required parameters for Config are:\nimage - the docker image to use ports - ports to map on the docker container\nSee Docker.ContainerConfig[Tag] for additional parameters.\nExample postgres container definition:\nobject PostgresDocker extends ContainerDef {\n  val primaryPort: Docker.DockerPort = Docker.DockerPort.TCP(5432)\n\n  override def config: Config = {\n    Config(\n      image = \"library/postgres:12.2\",\n      ports = Seq(primaryPort),\n      env = Map(\"POSTGRES_PASSWORD\" -> \"postgres\"),\n    )\n  }\n}","title":"1. Create a ContainerDef"},{"location":"/distage/distage-framework-docker.html#2-declare-container-components","text":"To use this container, a module that declares this component is required:\nUse make for binding in a ModuleDef:\nclass PostgresDockerModule[F[_]: TagK] extends ModuleDef {\n  make[PostgresDocker.Container].fromResource {\n    PostgresDocker.make[F]\n  }\n}\nobject PostgresDockerModule {\n  def apply[F[_]: TagK] = new PostgresDockerModule[F]\n}","title":"2. Declare Container Components"},{"location":"/distage/distage-framework-docker.html#3-include-the-dockersupportmodule","text":"Include the izumi.distage.docker.modules.DockerSupportModule module in the application modules. This module contains required component declarations and initializes the Docker.ClientConfig.\nimport cats.effect.IO\nimport com.typesafe.config.ConfigFactory\nimport distage.Injector\nimport izumi.distage.config.AppConfigModule\nimport izumi.distage.docker.modules.DockerSupportModule\nimport izumi.distage.effect.modules.CatsDIEffectModule\nimport izumi.logstage.api.routing.StaticLogRouter\nimport izumi.logstage.distage.LogIOModule\n\nval distageFrameworkModules = new ModuleDef {\n  // required for docker\n  include(DockerSupportModule[IO])\n\n  // standard distage framework modules\n  include(AppConfigModule(ConfigFactory.defaultApplication))\n  include(CatsDIEffectModule)\n  include(new LogIOModule[IO](StaticLogRouter.instance, false))\n}\nThe required framework modules plus PostgresDockerModule is sufficient to depend on Docker containers:\ndef minimalExample = {\n  val applicationModules = new ModuleDef {\n    include(PostgresDockerModule[IO])\n    include(distageFrameworkModules)\n  }\n\n  Injector().produceGetF[IO, PostgresDocker.Container](applicationModules).use { container =>\n    val port = container.availablePorts.first(PostgresDocker.primaryPort)\n    IO(println(s\"postgres is available on port ${port}\"))\n  }\n}\n\nminimalExample.unsafeRunSync()\n// postgres is available on port AvailablePort(172.17.0.2,5432)\nIf the DockerSupportModule is not included in an application then a get of a Docker container dependent resource will fail with a izumi.distage.model.exceptions.ProvisioningException.","title":"3. Include the DockerSupportModule"},{"location":"/distage/distage-framework-docker.html#config-api","text":"The DockerProviderExtensions provides additional APIs for modiying the container definition.","title":"Config API"},{"location":"/distage/distage-framework-docker.html#modifyconfig","text":"Use modifyConfig to modify the configuration of a container. The modifier is instantiated to a ProviderMagnet, which will summon any additional dependencies.\nFor example, to change the user of the PostgreSQL container:\nclass PostgresRunAsAdminModule[F[_]: TagK] extends ModuleDef {\n  make[PostgresDocker.Container].fromResource {\n    PostgresDocker.make[F].modifyConfig { () => (old: PostgresDocker.Config) =>\n      old.copy(user = Some(\"admin\"))\n    }\n  }\n}\nSuppose HostPostgresData is a component provided by the application modules. This path can be added to the PostgreSQL container’s mounts by adding to the additional dependencies of the provider magnet:\ncase class HostPostgresData(path: String)\n\nclass PostgresWithMountsDockerModule[F[_]: TagK] extends ModuleDef {\n  make[PostgresDocker.Container].fromResource {\n    PostgresDocker.make[F].modifyConfig {\n      (hostPostgresData: HostPostgresData) =>\n        (old: PostgresDocker.Config) =>\n          val dataMount = Docker.Mount(hostPostgresData.path, \"/var/lib/postgresql/data\")\n          old.copy(mounts = old.mounts :+ dataMount)\n    }\n  }\n}","title":"modifyConfig"},{"location":"/distage/distage-framework-docker.html#dependondocker","text":"dependOnDocker adds a dependency on a given Docker container. distage ensures the requested container is available before the dependent is provided.\nFor example, suppose a system under test requires both PostgreSQL and Elasticsearch. One option is to use dependOnDocker to declare the Elasticsearch container depends on the PostgreSQL container:\nobject ElasticSearchDocker extends ContainerDef {\n  val ports = Seq(9200, 9300)\n\n  override def config: Config = {\n    Config(\n      image = \"docker.elastic.co/elasticsearch/elasticsearch:7.7.0\",\n      ports = ports.map(Docker.DockerPort.TCP(_)),\n      env = Map(\"discovery.type\" -> \"single-node\")\n    )\n  }\n}\n\nclass ElasticSearchPlusPostgresModule[F[_]: TagK] extends ModuleDef {\n  make[PostgresDocker.Container].fromResource {\n    PostgresDocker.make[F]\n  }\n\n  make[ElasticSearchDocker.Container].fromResource {\n    ElasticSearchDocker.make[F].dependOnDocker(PostgresDocker)\n  }\n}\nAnother example of dependencies between containers is in the “Docker Container Networks” section later in this document.","title":"dependOnDocker"},{"location":"/distage/distage-framework-docker.html#availability-and-health-checks","text":"The healthCheck properties of Docker.ContainerConfig configure the health checks. A container resource will not be provided if the health checks did not succeed at acquire time. These are used to determine if an existing container can be used and if starting a fresh container succeeded.\nBy default, the healthCheck is a port check of the ports from the container config. There are several standard checks provided in ContainerHealthCheck that can be combined to cover many common cases.\nThe availablePorts property of the container resource are the mapped ports that passed the health check. This is a map from a Docker.DockerPort provided in the config to a host and port. For example:\nval port = container.availablePorts.first(PostgresDocker.primaryPort)\nwould be a host and port mapped to the Postgres container’s primary port that have passed the health check.","title":"Availability and Health Checks"},{"location":"/distage/distage-framework-docker.html#usage-in-integration-tests","text":"A common use case is using Docker containers to provide service implementations for integration test, such as using a PostgreSQL container for verifying an application that uses a PostgreSQL database. distage container resources are easy to integrate as providers.\nConsider the example application below. This application is written to depend on a doobie Transactor, which is constructed from a PostgresServerConfig.\nimport doobie.Transactor\nimport doobie.syntax.connectionio._\nimport doobie.syntax.string._\n\nclass PostgresExampleApp(xa: Transactor[IO]) {\n  def plusOne(a: Int): IO[Int] = {\n    sql\"select ${a} + 1\".query[Int].unique.transact(xa)\n  }\n\n  val run: IO[Unit] = {\n    for {\n      v <- plusOne(1)\n      _ <- IO(println(s\"1 + 1 = ${v}.\"))\n    } yield ()\n  }\n}\n\n// the postgres configuration used to construct the Transactor\ncase class PostgresServerConfig(\n  host: String,\n  port: Int,\n  database: String,\n  username: String,\n  password: String,\n)\n\nclass TransactorFromConfigModule extends ModuleDef {\n  make[Transactor[IO]].from { config: PostgresServerConfig =>\n    import scala.concurrent.ExecutionContext.global\n\n    implicit val contextShift = IO.contextShift(global)\n    implicit val timer = IO.timer(global)\n\n    Transactor.fromDriverManager[IO](\n      \"org.postgresql.Driver\",\n      s\"jdbc:postgresql://${config.host}:${config.port}/${config.database}\",\n      config.username,\n      config.password,\n    )\n  }\n}\nNote that the above code is agnostic of environment. Provided a PostgresServerConfig, the Transactor needed by PostgresExampleApp can be constructed.\nAn integration test would use a module that provides the PostgresServerConfig from a PostgresDocker.Container:\nclass IntegUsingDockerModule extends ModuleDef {\n  make[PostgresServerConfig].from {\n    container: PostgresDocker.Container => {\n      val knownAddress = container.availablePorts.first(PostgresDocker.primaryPort)\n      PostgresServerConfig(\n        host     = knownAddress.hostV4,\n        port     = knownAddress.port,\n        database = \"postgres\",\n        username = \"postgres\",\n        password = \"postgres\",\n      )\n    }\n  }\n\n  make[PostgresDocker.Container].fromResource {\n    PostgresDocker.make[IO]\n  }\n}\nUsing distage-testkit the test would be written like this:\nimport izumi.distage.testkit.scalatest.{AssertCIO, DistageSpecScalatest}\nimport distage.DIKey\n\nclass PostgresExampleAppIntegTest extends DistageSpecScalatest[IO] with AssertCIO {\n  override def config = super.config.copy(\n    moduleOverrides = new ModuleDef {\n      include(new TransactorFromConfigModule)\n      include(new IntegUsingDockerModule)\n      include(distageFrameworkModules)\n      make[PostgresExampleApp]\n    },\n    memoizationRoots = Set(\n      DIKey[PostgresServerConfig]\n    )\n  )\n\n  \"distage docker\" should {\n    \"support integration tests using containers\" in {\n      app: PostgresExampleApp =>\n        for {\n          v <- app.plusOne(1)\n          _ <- assertIO(v == 2)\n        } yield ()\n    }\n  }\n}\nTypically, this would be run by the test runner. For completeness, the example can be run directly using:\ndef postgresDockerIntegrationExample = {\n  val applicationModules = new ModuleDef {\n    include(new TransactorFromConfigModule)\n    include(new IntegUsingDockerModule)\n    include(distageFrameworkModules)\n    make[PostgresExampleApp]\n  }\n\n  Injector()\n    .produceGetF[IO, PostgresExampleApp](applicationModules)\n    .use(app => app.run)\n}\n\npostgresDockerIntegrationExample.unsafeRunSync()\n// 1 + 1 = 2.","title":"Usage in Integration Tests"},{"location":"/distage/distage-framework-docker.html#docker-container-environment","text":"The container config (Docker.ContainerConfig) defines the container environment. Of note are the environment variables, command of entrypoint, and working directory properties:\nenv: Map[String, String] - environment variables to setup in container cmd: Seq[String] - command of entrypoint cwd: Option[String] - working directory in container\nOnce defined in a ContainerDef the config may be modified by distage modules. See modifyConfig above for one mechanism.\nThe container ports will also add to the configured environment variables:\nDISTAGE_PORT_<protocol>_<originalPort> are the host ports allocated for the container","title":"Docker Container Environment"},{"location":"/distage/distage-framework-docker.html#docker-metadata","text":"The host ports allocated for the container are also added to the container metadata as labels. These labels follow the pattern distage.port.<protocol>.<originalPort>. The value is the integer port number.","title":"Docker Metadata"},{"location":"/distage/distage-framework-docker.html#docker-container-networks","text":"distage-framework-docker can automatically manage Docker networks.\nTo connect containers to the same Docker network, use a ContainerNetworkDef:\nCreate a ContainerNetworkDef. Add the network to each container’s config.\nThis will ensure the containers are all connected to the network. Assuming no reuse, distage will create the required network and add each container to that network.","title":"Docker Container Networks"},{"location":"/distage/distage-framework-docker.html#1-create-a-containernetworkdef","text":"A minimal ContainerNetworkDef uses the default configuration.\nobject TestClusterNetwork extends ContainerNetworkDef {\n  override def config: Config = Config()\n}\nBy default this object identifies the network. The associated tag type uniquely identifies this network within the application. In addition, any created network will have a label with this name in Docker.","title":"1. Create a ContainerNetworkDef"},{"location":"/distage/distage-framework-docker.html#2-add-to-container-config","text":"A container will be connected to all networks in the networks of the config. The method connectToNetwork adds a dependency on a network defined by a ContainerNetworkDef, as in this example:\nclass TestClusterNetworkModule[F[_]: TagK] extends ModuleDef {\n  make[TestClusterNetwork.Network].fromResource {\n    TestClusterNetwork.make[F]\n  }\n  make[PostgresDocker.Container].fromResource {\n    PostgresDocker.make[F].connectToNetwork(TestClusterNetwork)\n  }\n  make[ElasticSearchDocker.Container].fromResource {\n    ElasticSearchDocker.make[F].dependOnDocker(PostgresDocker).connectToNetwork(TestClusterNetwork)\n  }\n}\nThe use of connectToNetwork automatically adds a dependency on TestClusterNetwork.Network to each container.","title":"2. Add to Container Config"},{"location":"/distage/distage-framework-docker.html#container-network-reuse","text":"Container networks, like containers, are reused by default. If there is an existing network that matches a definition then that network will be used. This can be disabled by setting the reuse configuration to false:\nobject AlwaysFreshNetwork extends ContainerNetworkDef {\n  override def config: Config = Config(reuse = false)\n}\nFor an existing network to be reused, the config and object name at time of creation must be the match the current configuration value and object.","title":"Container Network Reuse"},{"location":"/distage/distage-framework-docker.html#docker-client-configuration","text":"The Docker.ClientConfig is the configuration of the Docker client used. Including the module DockerSupportModule will provide a Docker.ClientConfig.\nThere are two primary mechanisms to change the Docker.ClientConfig provided by DockerSupportModule:\nProvide a docker configuration in the application.conf:\n# include the default configuration\ninclude \"docker-reference.conf\"\n\n# override docker object fields\ndocker {\n  readTimeoutMs = 60000\n  allowReuse = false\n}\nOverride the DockerSupportModule using overridenBy:\nimport izumi.distage.docker.Docker\n\nclass CustomDockerConfigExampleModule[F[_]: TagK] extends ModuleDef {\n  include(DockerSupportModule[F] overridenBy new ModuleDef {\n    make[Docker.ClientConfig].from {\n      Docker.ClientConfig(\n        readTimeoutMs    = 10000,\n        connectTimeoutMs = 10000,\n        allowReuse       = false,\n        useRemote        = true,\n        useRegistry      = true,\n        remote           = Some(\n          Docker.RemoteDockerConfig(\n            host      = \"tcp://localhost:2376\",\n            tlsVerify = true,\n            certPath  = \"/home/user/.docker/certs\",\n            config    = \"/home/user/.docker\",\n          )\n        ),\n        registry = Some(\n          Docker.DockerRegistryConfig(\n            url      = \"https://index.docker.io/v1/\",\n            username = \"dockeruser\",\n            password = \"ilovedocker\",\n            email    = \"dockeruser@github.com\",\n          )\n        ),\n      )\n    }\n  })\n}","title":"Docker Client Configuration"},{"location":"/distage/distage-framework-docker.html#container-reuse","text":"By default acquiring a container resource does not always start a fresh container. Likewise on releasing the resource the container will not be destroyed. When a container resource is acquired, the Docker system is inspected to determine if a matching container is already executing. If a matching container is found this container is referenced by the ContainerResource. Otherwise a fresh container is started. In both cases the acquired ContainerResource will have passed configured health checks.","title":"Container Reuse"},{"location":"/distage/distage-framework-docker.html#matching-containers-for-reuse","text":"For an existing container to be reused, all the following must be true:\nThe current client config has allowReuse == true. The container config has reuse == true. The running container was created for reuse. The running container uses the same image as the container config. All ports requested in the container config must be mapped for the running container.","title":"Matching Containers for Reuse"},{"location":"/distage/distage-framework-docker.html#configuring-reuse","text":"The ContainerDef.Config.reuse should be false to disable reuse for a specific container. While Docker.ClientConfig.allowReuse should be false to disable reuse throughout the application.","title":"Configuring Reuse"},{"location":"/distage/distage-framework-docker.html#improving-reuse-performance","text":"When utilizing reuse, the performance cost of inspecting the Docker system can be avoided using memoization roots. For example, in this integration test the container resource is not reconstructed for each test. Because the resource is not reconstructed there is no repeated inspection of the Docker system.\nclass NoReuseByMemoizationExampleTest extends DistageSpecScalatest[IO] {\n  override def config = super.config.copy(\n    moduleOverrides = new ModuleDef {\n      include(distageFrameworkModules)\n      include(PostgresDockerModule[IO])\n    },\n    memoizationRoots = Set(\n      DIKey[PostgresDocker.Container]\n    )\n  )\n\n  \"distage docker\" should {\n    \"provide a fresh container resource\" in { c: PostgresDocker.Container =>\n      val port = c.availablePorts.first(PostgresDocker.primaryPort)\n      IO(println(s\"port ${port}\"))\n    }\n\n    \"provide the same resource\" in { c: PostgresDocker.Container =>\n      val port = c.availablePorts.first(PostgresDocker.primaryPort)\n      IO(println(s\"port ${port}\"))\n    }\n  }\n}","title":"Improving Reuse Performance"},{"location":"/distage/distage-framework-docker.html#examples","text":"The distage-example project uses distage-framework-docker to provide a PostgresDockerModule.\nThe distage-framework-docker project contains example ContainerDefs and modules for various services under izumi.distage.docker.examples namespace.","title":"Examples"},{"location":"/distage/distage-framework-docker.html#tips","text":"To kill all containers spawned by distage, use the following command:\ndocker rm -f $(docker ps -q -a -f 'label=distage.type')","title":"Tips"},{"location":"/distage/distage-framework-docker.html#troubleshooting","text":"// izumi.distage.model.exceptions.ProvisioningException: Provisioner stopped after 1 instances, 2/14 operations failed:\n//  - {type.izumi.distage.docker.DockerClientWrapper[=λ %0 → IO[+0]]} (distage-framework-docker.md:40), MissingInstanceException: Instance is not available in the object graph: {type.izumi.distage.docker.DockerClientWrapper[=λ %0 → IO[+0]]}.\nThe DockerSupportModule was not included in the application modules. The component DockerClientWrapper is provided by izumi.distage.docker.modules.DockerSupportModule.","title":"Troubleshooting"},{"location":"/distage/distage-framework-docker.html#references","text":"Introduced in release 0.9.13 An example PR showing how to use them. The distage-example PostgresDockerModule.","title":"References"},{"location":"/distage/distage-testkit.html","text":"","title":"distage-testkit"},{"location":"/distage/distage-testkit.html#distage-testkit","text":"Testkit Integration Checks","title":"distage-testkit"},{"location":"/distage/distage-testkit.html#testkit","text":"distage Example Project project shows how to use distage-testkit, there’s also an overview in the Hyper-pragmatic Pure FP Testing with distage-testkit talk.\nFurther documentation still TBD: Issue #820\nSome example code from distage-example:\nimport distage.{DIKey, ModuleDef}\nimport izumi.distage.model.definition.Activation\nimport izumi.distage.model.definition.StandardAxis.Repo\nimport izumi.distage.plugins.PluginConfig\nimport izumi.distage.testkit.TestConfig\nimport izumi.distage.testkit.scalatest.{AssertIO, DistageBIOEnvSpecScalatest}\nimport leaderboard.model.{Score, UserId}\nimport leaderboard.repo.{Ladder, Profiles}\nimport leaderboard.zioenv.{ladder, rnd}\nimport zio.{ZIO, IO}\n\nabstract class LeaderboardTest extends DistageBIOEnvSpecScalatest[ZIO] with AssertIO {\n  override def config = super.config.copy(\n    pluginConfig = PluginConfig.cached(packagesEnabled = Seq(\"leaderboard.plugins\")),\n    moduleOverrides = new ModuleDef {\n      make[Rnd[IO]].from[Rnd.Impl[IO]]\n      // For testing, setup a docker container with postgres,\n      // instead of trying to connect to an external database\n      include(PostgresDockerModule)\n    },\n    // instantiate Ladder & Profiles only once per test-run and\n    // share them and all their dependencies across all tests.\n    // this includes the Postgres Docker container above and\n    // table DDLs \n    memoizationRoots = Set(\n      DIKey[Ladder[IO]],\n      DIKey[Profiles[IO]],\n    ),\n  )\n}\n\ntrait DummyTest extends LeaderboardTest {\n  override final def config = super.config.copy(\n    activation = Activation(Repo -> Repo.Dummy),\n  )\n}\n\ntrait ProdTest extends LeaderboardTest {\n  override final def config = super.config.copy(\n    activation = Activation(Repo -> Repo.Prod),\n  )\n}\n\nfinal class LadderTestDummy extends LadderTest with DummyTest\nfinal class LadderTestPostgres extends LadderTest with ProdTest\n\nabstract class LadderTest extends LeaderboardTest {\n\n  \"Ladder\" should {\n    // this test gets dependencies through arguments\n    \"submit & get\" in {\n      (rnd: Rnd[IO], ladder: Ladder[IO]) =>\n        for {\n          user  <- rnd[UserId]\n          score <- rnd[Score]\n          _     <- ladder.submitScore(user, score)\n          res   <- ladder.getScores.map(_.find(_._1 == user).map(_._2))\n          _     <- assertIO(res contains score)\n        } yield ()\n    }\n\n    // other tests get dependencies via ZIO Env:\n    \"assign a higher position in the list to a higher score\" in {\n      for {\n        user1  <- rnd[UserId]\n        score1 <- rnd[Score]\n        user2  <- rnd[UserId]\n        score2 <- rnd[Score]\n\n        _      <- ladder.submitScore(user1, score1)\n        _      <- ladder.submitScore(user2, score2)\n        scores <- ladder.getScores\n\n        user1Rank = scores.indexWhere(_._1 == user1)\n        user2Rank = scores.indexWhere(_._1 == user2)\n\n        _ <- if (score1 > score2) {\n          assertIO(user1Rank < user2Rank)\n        } else if (score2 > score1) {\n          assertIO(user2Rank < user1Rank)\n        } else IO.unit\n      } yield ()\n    }\n\n    // you can also mix arguments and env at the same time\n    \"assign a higher position in the list to a higher score 2\" in {\n      ladder: Ladder[IO] =>\n          for {\n            user1  <- rnd[UserId]\n            score1 <- rnd[Score]\n            user2  <- rnd[UserId]\n            score2 <- rnd[Score]\n    \n            _      <- ladder.submitScore(user1, score1)\n            _      <- ladder.submitScore(user2, score2)\n            scores <- ladder.getScores\n    \n            user1Rank = scores.indexWhere(_._1 == user1)\n            user2Rank = scores.indexWhere(_._1 == user2)\n    \n            _ <- if (score1 > score2) {\n              assertIO(user1Rank < user2Rank)\n            } else if (score2 > score1) {\n              assertIO(user2Rank < user1Rank)\n            } else IO.unit\n          } yield ()\n    }\n  }\n\n}","title":"Testkit"},{"location":"/distage/distage-testkit.html#integration-checks","text":"Implementation classes that inherit from izumi.distage.roles.model.IntegrationCheck can specify a resourceCheck() method that will be called before test instantiation to check if external test dependencies (such as docker containers in distage-framework-docker) are available for the test or role. If not, the test will be canceled/ignored.\nThis feature allows you to e.g. selectively run only the fast in-memory tests that have no external dependencies if you have shut down your test environment.\nIntegration checks are executed only in distage-testkit tests and distage-framework’s Roles.\nUse StartupPlanExecutor to execute the checks manually.","title":"Integration Checks"},{"location":"/distage/reference.html","text":"","title":"Syntax Summary"},{"location":"/distage/reference.html#syntax-summary","text":"ModuleDefDSL syntax:\nSingleton bindings:\n  - `make[X]` = create X using its constructor\n  - `make[X].from[XImpl]` = bind X to its subtype XImpl using XImpl's constructor\n  - `make[X].from(myX)` = bind X to an already existing instance `myX`\n  - `make[X].from { y: Y => new X(y) }` = bind X to an instance of X constructed by a given [[izumi.distage.model.providers.ProviderMagnet Provider]] function\n  - `make[X].fromEffect(X.create[F]: F[X])` = create X using a purely-functional effect `X.create` in `F` monad\n  - `make[X].fromResource(X.resource[F]: Resource[F, X])` = create X using a [[DIResource]] specifying its creation and destruction lifecycle\n  - `make[X].named(\"special\")` = bind a named instance of X. It can then be summoned using [[Id]] annotation.\n  - `make[X].using[X]` = bind X to refer to another already bound instance of `X`\n  - `make[X].using[X](\"special\")` = bind X to refer to another already bound named instance at key `[X].named(\"special\")`\n  - `make[ImplXYZ].aliased[X].aliased[Y].aliased[Z]` = bind ImplXYZ and bind X, Y, Z to refer to the bound instance of ImplXYZ\n\nSet bindings:\n  - `many[X].add[X1].add[X2]` = bind a [[Set]] of X, and add subtypes X1 and X2 created via their constructors to it.\n                                Sets can be bound in multiple different modules. All the elements of the same set in different modules will be joined together.\n  - `many[X].add(x1).add(x2)` = add *instances* x1 and x2 to a `Set[X]`\n  - `many[X].add { y: Y => new X1(y).add { y: Y => X2(y) }` = add instances of X1 and X2 constructed by a given [[izumi.distage.model.providers.ProviderMagnet Provider]] function\n  - `many[X].named(\"special\").add[X1]` = create a named set of X, all the elements of it are added to this named set.\n  - `many[X].ref[XImpl]` = add a reference to an already **existing** binding of XImpl to a set of X's\n  - `many[X].ref[X](\"special\")` = add a reference to an **existing** named binding of X to a set of X's\n\nTags:\n  - `make[X].tagged(\"t1\", \"t2)` = attach tags to X's binding. Tags can be processed in a special way. See [[izumi.distage.roles.model.RoleId]]\n  - `many[X].add[X1].tagged(\"x1tag\")` = Tag a specific element of X. The tags of sets and their elements are separate.\n  - `many[X].tagged(\"xsettag\")` = Tag the binding of empty Set of X with a tag. The tags of sets and their elements are separate.\n\nIncludes:\n  - `include(that: ModuleDef)` = add all bindings in `that` module into `this` module","title":"Syntax Summary"},{"location":"/logstage/index.html","text":"Dependencies Overview Syntax Reference Basic setup Log algebras ZIO environment support Custom JSON rendering with LogstageCodec SLF4J Router","title":"LogStage"},{"location":"/logstage/index.html#logstage","text":"LogStage is a zero-cost structural logging framework for Scala & Scala.js\nKey features:\nLogStage extracts structure from ordinary string interpolations in your log messages with zero changes to code. LogStage uses macros to extract log structure, its faster at runtime than a typical reflective structural logging frameworks, Log contexts Console, File and SLF4J sinks included, File sink supports log rotation, Human-readable output and JSON output included, Method-level logging granularity. Can configure methods com.example.Service.start and com.example.Service.doSomething independently, Slf4J adapters: route legacy Slf4J logs into LogStage router","title":"LogStage"},{"location":"/logstage/index.html#dependencies","text":"libraryDependencies ++= Seq(\n  // LogStage core library\n  \"io.7mind.izumi\" %% \"logstage-core\" % \"0.10.16\",\n  // Json output\n  \"io.7mind.izumi\" %% \"logstage-rendering-circe\" % \"0.10.16\",\n  // Router from Slf4j to LogStage\n  \"io.7mind.izumi\" %% \"logstage-adapter-slf4j\" % \"0.10.16\",\n  // LogStage integration with DIStage\n  \"io.7mind.izumi\" %% \"distage-extension-logstage\" % \"0.10.16\",\n  // Router from LogStage to Slf4J\n  \"io.7mind.izumi\" %% \"logstage-sink-slf4j \" % \"0.10.16\",\n)","title":"Dependencies"},{"location":"/logstage/index.html#overview","text":"The following snippet:\nimport logstage.IzLogger\nimport scala.util.Random\n\nval logger = IzLogger()\n// logger: IzLogger = izumi.logstage.api.IzLogger@1f0754ac\n\nval justAnArg = \"example\"\n// justAnArg: String = example\nval justAList = List[Any](10, \"green\", \"bottles\")\n// justAList: List[Any] = List(10, green, bottles)\n\nlogger.trace(s\"Argument: $justAnArg, another arg: $justAList\")\n\n// custom name, not based on `val` name\n\nlogger.info(s\"Named expression: ${Random.nextInt() -> \"random number\"}\")\n\n// print result without a name\n\nlogger.warn(s\"Invisible argument: ${Random.nextInt() -> \"random number\" -> null}\")\n\n// add following fields to all messages printed by a new logger value\n\nval ctxLogger = logger(\"userId\" -> \"user@google.com\", \"company\" -> \"acme\")\n// ctxLogger: IzLogger = izumi.logstage.api.IzLogger@1c3fde15\nval delta = Random.nextInt(1000)\n// delta: Int = 601\n\nctxLogger.info(s\"Processing time: $delta\")\nWill look like this in string form:\nAnd like this in JSON:\nNote:\nJSON formatter is type aware! Each JSON message contains @class field with holds a unique event class identifier. All events produced by the same source code line will share the same event class.","title":"Overview"},{"location":"/logstage/index.html#syntax-reference","text":"Simple variable: scala logger.info(s\"My message: $argument\") Chain: scala logger.info(s\"My message: ${call.method} ${access.value}\") Named expression: scala logger.info(s\"My message: ${Some.expression -> \"argname\"}\") Invisible named expression: scala logger.info(s\"My message: ${Some.expression -> \"argname\" -> null}\")\n5) De-camelcased name: scala logger.info(${camelCaseName-> ' '})","title":"Syntax Reference"},{"location":"/logstage/index.html#basic-setup","text":"import logstage.{ConsoleSink, IzLogger, Trace}\nimport logstage.circe.LogstageCirceRenderingPolicy\n\nval textSink = ConsoleSink.text(colored = true)\n// textSink: ConsoleSink = izumi.logstage.sink.ConsoleSink$ColoredConsoleSink$@6ad1e413\nval jsonSink = ConsoleSink(LogstageCirceRenderingPolicy(prettyPrint = true))\n// jsonSink: ConsoleSink = izumi.logstage.sink.ConsoleSink@5aad3ed8\n\nval sinks = List(jsonSink, textSink)\n// sinks: List[ConsoleSink] = List(izumi.logstage.sink.ConsoleSink@5aad3ed8, izumi.logstage.sink.ConsoleSink$ColoredConsoleSink$@6ad1e413)\n\nval logger: IzLogger = IzLogger(Trace, sinks)\n// logger: IzLogger = izumi.logstage.api.IzLogger@7f2aa315\nval contextLogger: IzLogger = logger(\"key\" -> \"value\")\n// contextLogger: IzLogger = izumi.logstage.api.IzLogger@1d871593\n\nlogger.info(\"Hey\")\n\ncontextLogger.info(s\"Hey\")","title":"Basic setup"},{"location":"/logstage/index.html#log-algebras","text":"LogIO, LogBIO & LogBIO3 algebras provide a purely-functional API for one-, two-, and three-parameter effect types respectively:\nimport logstage.{IzLogger, LogIO}\nimport cats.effect.IO\n\nval logger = IzLogger()\n// logger: IzLogger = izumi.logstage.api.IzLogger@78139b4c\n\nval log = LogIO.fromLogger[IO](logger)\n// log: LogIO[IO] = logstage.LogIO$$anon$1@4b7b3168\n\nlog.info(s\"Hey! I'm logging with ${log}stage!\")\n// res9: IO[Unit] = IO$1633878297\nI 2019-03-29T23:21:48.693Z[Europe/Dublin] r.S.App7.res8 ...main-12:5384  (00_logstage.md:92) Hey! I'm logging with log=logstage.LogIO$$anon$1@72736f25stage!\nLogIO/LogBIO algebras can be extended with custom context using their .apply method, same as IzLogger:\nimport cats.effect.IO\nimport cats.implicits._\nimport logstage.LogIO\nimport io.circe.Printer\nimport io.circe.syntax._\n\ndef importEntity(entity: Entity)(implicit log: LogIO[IO]): IO[Unit] = {\n  val ctxLog = log(\"ID\" -> entity.id, \"entityAsJSON\" -> entity.asJson.printWith(Printer.spaces2))\n\n  load(entity).handleErrorWith {\n    case error =>\n      ctxLog.error(s\"Failed to import entity: $error.\").void\n      // JSON message includes `ID` and `entityAsJSON` fields\n  }\n}\nLogIO.log/LogBIO.log/LogBIO3.log/IzLogger.log let you refer to an implicit logger’s methods without naming a variable\nimport logstage.LogIO\nimport logstage.LogIO.log\n\ndef fn[F[_]: LogIO]: F[Unit] = {\n  log.info(s\"I'm logging with ${log}stage!\")\n}","title":"Log algebras"},{"location":"/logstage/index.html#zio-environment-support","text":"LogstageZIO.log lets you carry LogZIO capability in environment.\nExample:\nimport logstage.LogstageZIO.{LogZIO, log}\nimport zio.ZIO\n\nval fn: ZIO[LogZIO, Nothing, Unit] = {\n  log.info(s\"I'm logging with ${log}stage!\")\n}\n// fn: ZIO[LogZIO, Nothing, Unit] = zio.ZIO$Read@446dab2b\nLogstageZIO.withFiberId provides a LogBIO instance that logs the current ZIO FiberId in addition to the thread id:\nExample:\nimport logstage.{IzLogger, LogstageZIO}\nimport zio.IO\n\nval log = LogstageZIO.withFiberId(IzLogger())\n// log: logstage.package.LogBIO[IO] = logstage.LogstageZIO$$anon$1@20409111\n\nlog.info(s\"Hey! I'm logging with ${log}stage!\")\n// res14: IO[Nothing, Unit] = zio.ZIO$Descriptor@32220400\nI 2019-03-29T23:21:48.760Z[Europe/Dublin] r.S.App9.res10 ...main-12:5384  (00_logstage.md:123) {fiberId=0} Hey! I'm logging with log=logstage.LogstageZIO$$anon$1@c39104astage!\nLogBIO3.log extends environment support to trifunctor effect types with an instance of BIOMonadAsk[F] typeclass (from BIO)\nExample:\nimport logstage.{LogBIO3, LogBIOEnv, IzLogger}\nimport logstage.LogBIOEnv.log\nimport zio.{Has, ZIO}\n\nclass Service[F[-_, +_, +_]: LogBIOEnv] {\n  val fn: F[Has[LogBIO3[F]], Nothing, Unit] = {\n    log.info(s\"I'm logging with ${log}stage!\")\n  }\n}\n\nzio.Runtime.default.unsafeRun {\n  implicit val logger: LogBIOEnv[ZIO] = LogBIOEnv.make[ZIO]\n  new Service[ZIO]\n    .fn\n    .provide(Has(LogBIO3.fromLogger(IzLogger())))\n}","title":"ZIO environment support"},{"location":"/logstage/index.html#custom-json-rendering-with-logstagecodec","text":"If you define an instance of LogstageCodec for your type, it will be used when rendering your logs to JSON instead of the default renderer.\nYou can derive instances of LogstageCodec from Circe codecs with logstage-rendering-circe or write them manually.\nExample:\nimport io.circe.Codec\nimport io.circe.derivation\nimport logstage.LogstageCodec\nimport logstage.circe.LogstageCirceCodec\n\nfinal case class KV(key: String, value: Int)\n\nobject KV {\n  implicit val circeCodec: Codec[KV] = derivation.deriveCodec[KV]\n  implicit val logstageCodec: LogstageCodec[KV] = LogstageCirceCodec.derived[KV]\n}\nIf you want to make sure that all values in your interpolations are rendered using LogstageCodec instead of default renderer, use IzStrictLogger/LogIOStrict types from logstage.strict package:\nimport logstage.strict.IzStrictLogger\nimport logstage.ConsoleSink\nimport logstage.circe.LogstageCirceRenderingPolicy\n\nval logger = IzStrictLogger(sink = ConsoleSink(LogstageCirceRenderingPolicy()))\n// logger: IzStrictLogger = izumi.logstage.api.strict.IzStrictLogger@4b30a094\n\nlogger.info(s\"Got ${KV(\"key\", 7) -> \"KeyValue\"}\")","title":"Custom JSON rendering with LogstageCodec"},{"location":"/logstage/index.html#slf4j-router","text":"When not configured, logstage-adapter-slf4j will log messages with level >= Info to stdout.\nDue to the global mutable nature of slf4j, to configure slf4j logging you’ll have to mutate a global singleton StaticLogRouter. Replace its LogRouter with the same one you use elsewhere in your application to use the same configuration for Slf4j.\nimport logstage.IzLogger\nimport izumi.logstage.api.routing.StaticLogRouter\n\nval myLogger = IzLogger()\n// myLogger: IzLogger = izumi.logstage.api.IzLogger@622d6e2a\n\n// configure SLF4j to use the same router that `myLogger` uses\nStaticLogRouter.instance.setup(myLogger.router)","title":"SLF4J Router"},{"location":"/bio/index.html","text":"","title":"BIO"},{"location":"/bio/index.html#bio","text":"BIO is a set of typeclasses and algebras for programming in tagless final style using bifunctor or trifunctor effect types with variance.\nKey syntactic features:\nErgonomic F summoner that is a single point of entry to all methods in the hierarchy Import-less syntax. Syntax is automatically available whenever any typeclass from the hierarchy is imported, e.g. immediately after IDE auto-import.\nThese syntactic features allow you to write in a low ceremony, IDE-friendly and newcomer-friendly style:\nimport izumi.functional.bio.{F, BIOMonad, BIOMonadAsk, BIOPrimitives, BIORef3}\n\ndef adder[F[+_, +_]: BIOMonad: BIOPrimitives](i: Int): F[Nothing, Int] =\n  F.mkRef(0)\n   .flatMap(ref => ref.update(_ + i) *> ref.get)\n\n// update ref from the environment and return result\ndef adderEnv[F[-_, +_, +_]: BIOMonadAsk](i: Int): F[BIORef3[F, Int], Nothing, Int] =\n  F.access {\n    ref => \n      for {\n        _   <- ref.update(_ + i)\n        res <- ref.get\n      } yield res\n  }\nKey semantic features:\nTyped error handling with bifunctor effect types Automatic conversions to equivalent cats.effect instances in import izumi.functional.bio.catz._ Automatic adaptation of trifunctor typeclasses to bifunctor typeclasses when required No ambiguous implicit errors. It’s legal to have both BIOMonad3 and BIOMonadAsk as constraints, despite the fact that BIOMonadAsk provides a BIOMonad3: def adderEnv[F[-_, +_, +_]: BIOMonad3: BIOMonadAsk] // would still work Wrappers for primitive concurrent data structures: BIORef, BIOPromise, BIOSemaphore\nTo use it, add fundamentals-bio library:\nlibraryDependencies += \"io.7mind.izumi\" %% \"fundamentals-bio\" % \"0.10.16\"\nMost likely you’ll also need to add Kind Projector:\naddCompilerPlugin(\"org.typelevel\" % \"kind-projector\" % \"0.11.0\" cross CrossVersion.full)\nOn Scala 2.12 you must enable partial unification and set 2.13 source mode for the library to work correctly:\n// _Required_ options for Scala 2.12\nscalacOptions += \"-Ypartial-unification\"\nscalacOptions += \"-Xsource:2.13\"","title":"BIO"},{"location":"/bio/index.html#overview","text":"The following graphic shows the current BIO relationship hierarchy. Note that all the trifunctor BIO*3 typeclasses have bifunctor BIO* counterparts.\n(image)\nAuxiliary algebras:\n(image)\nRaw subtyping hierarchy:\n(image)","title":"Overview"},{"location":"/idealingua/index.html","text":"","title":"IdeaLingua RPC/DML"},{"location":"/idealingua/index.html#idealingua-rpc-dml","text":"IdeaLingua is an RPC framework & Domain Modeling Language, it’s purpose is to:\nShare & publish APIs and data models in a common concise format Allow remote calls to services given their public API definitions. Create idiomatic API clients and servers for all programming languages – currently Scala, TypeScript, C# & Go. Support frontend-to-backend and backend-to-frontend calls (ala push notifications, via buzzer definitions) Abstract away details such as the network protocol or the serialization format. Save developers from untyped and brittle REST.","title":"IdeaLingua RPC/DML"},{"location":"/idealingua/index.html#user-service-example","text":"package user.api\n\nenum Gender = Male | Female\n\nid EntityID {\n  uuid: uuid\n}\n\nmixin Entity {\n  id: EntityID\n}\n\nmixin Person {\n  name: str\n  surname: str\n  gender: Gender\n}\n\ndata User {\n  & Entity\n  + Person\n  password: str\n}\n\ndata PublicUser {\n  + User\n  - password: str\n}\n\nadt Result = Success | Failure\n\ndata Success {\n  message: str\n}\n\ndata Failure {\n  code: int8\n}\n\nservice UserService {\n  def saveUser(user: User): Result\n  def findUserByName(name: str): list[PublicUser] | Failure\n}","title":"User Service Example"},{"location":"/idealingua/index.html#quick-start","text":"You may use our preconfigured Docker environment to experiment with Izumi IDL compiler:\ndocker run -ti --rm septimalmind/izumi-env\nThen try this snippet:\nexport COMPILER=\"io.7mind.izumi:idealingua-v1-compiler_2.12:$izumi.version$\"\nexport S_REPOSITORY=https://oss.sonatype.org/content/repositories/snapshots \nexport R_REPOSITORY=https://oss.sonatype.org/content/repositories/releases\n\n# create sample project in `testproject` directory\ncoursier launch -r $S_REPOSITORY -r $R_REPOSITORY $COMPILER -- :init testproject \n\ncd testproject \n\n# compile Scala and Typescript projects using all the defaults\ncoursier launch -r $S_REPOSITORY -r $R_REPOSITORY $COMPILER -- :scala :typescript\n\n# Run SBT on generated Scala project\npushd .\ncd target/scala\nsbt package\npopd\n\n# Run tsc on generated Typescript project\npushd .\ncd target/typescript\nyarn install\ntsc\npopd\n\napt install -y mc\nmc","title":"Quick start"},{"location":"/idealingua/index.html#example-project","text":"See idealingua-example for examples for Scala, TypeScript, Go, C# and other languages.","title":"Example Project"},{"location":"/idealingua/index.html#installation","text":"","title":"Installation"},{"location":"/idealingua/index.html#using-sbt-plugin","text":"Add the following to your project/plugins.sbt file:\nval izumi_version = \"0.10.16\"\naddSbtPlugin(\"io.7mind.izumi\" % \"sbt-idealingua\" % izumi_version)\nPlace your domain definitions into /src/main/izumi directory, then enable the plugin for that project. For the generated code to compile, you will also need to add dependencies on the Idealingua RTS modules:\nval izumi = prop\n\nizumiProject\n  .enablePlugins(IdealinguaPlugin)\n  .settings(\n    libraryDependencies ++= Seq(\n        Izumi.R.idealingua_model\n      , Izumi.R.idealingua_runtime_rpc\n      , Izumi.R.idealingua_runtime_rpc_http4s\n      , Izumi.R.idealingua_runtime_rpc_circe\n    )\n  )\nYou can depend on the code generated by Idealinguain in your other Scala projects:\nproject.dependsOn(izumiProject)","title":"Using SBT Plugin"},{"location":"/idealingua/index.html#using-the-standalone-compiler","text":"The compiler is built as an uberjar and published to Maven Central.\nThe preferred way to install the compiler is via coursier\nTo install current release version:\n# install release executable\ncoursier bootstrap izumi.r2:idealingua-compiler_2.12:0.10.16 -o idlc\n\n./idlc --help\nTo install development snapshot:\n# install snapshot\ncoursier bootstrap -r https://oss.sonatype.org/content/repositories/snapshots/ izumi.r2:idealingua-compiler_2.12:0.7.0-SNAPSHOT -o idlc\n\n./idlc --help\nCommandline examples:\n# compile sources in ./src and output generated code to ./target/scala and ./target/typescript \n# all compiler plugins for Scala and TypeScript are enabled by * pattern\n\n./idlc -s src -t target -L scala=* -L typescript=*\n# compile with `AnyValExtension` compiler plugin for Scala disabled\n\n./idlc -s src -t target -L scala=-AnyvalExtension -L typescript=*","title":"Using the standalone compiler"},{"location":"/idealingua/index.html#scala-http4s-transport","text":"Most likely you’ll need to use Kind Projector and enable partial unification:\naddCompilerPlugin(\"org.typelevel\" % \"kind-projector\" % \"0.11.0\" cross CrossVersion.full)\n\n// Only for Scala 2.12, not required on 2.13+\nscalacOptions += \"-Ypartial-unification\"\nYou may find the test suite for the http4s backend here.","title":"Scala http4s Transport"},{"location":"/idealingua/language-reference.html","text":"","title":"Idealingua Language Reference"},{"location":"/idealingua/language-reference.html#idealingua-language-reference","text":"","title":"Idealingua Language Reference"},{"location":"/idealingua/language-reference.html#keywords-and-aliases","text":"Keyword Aliases Explanation domain package, namespace Namespace containing collection of entities import References a domain by id include Includes *.model file by name alias type, using Type alias enum Enumeration mixin interface Mixin, named collection of fields data dto, struct Data adt choice Algebraic Data Type id Identifier, named collection of scalars service Service interface def fn, func, fun Method","title":"Keywords and aliases"},{"location":"/idealingua/language-reference.html#inheritance-operators","text":"Keyword Aliases Explanation Example + +++, ... Inherit structure (copy fields) + Mixin & &&& Inherit interface & Mixin - --- Drop structure or field (doesn’t work for interfaces) - Mixin, - field: str","title":"Inheritance operators"},{"location":"/idealingua/language-reference.html#built-in-types","text":"","title":"Built-in types"},{"location":"/idealingua/language-reference.html#scalars","text":"Type name Aliases Explanation Scala type str string String String bool boolean, bit Boolean Boolean i08 byte, int8 8-bit integer Byte i16 short, int16 16-bit integer Short i32 int, int32 32-bit integer Int i64 long, int64 64-bit integer Long f32 float, flt Single precision floating point Float f64 double, dbl Double precision floating point Double uid uuid UUID java.util.UUID tsz dtl, datetimel Timestamp with timezone java.time.ZonedDateTime tsl dtz, datetimez Local timestamp java.time.LocalDateTime time time Time java.time.LocalTime date date Date java.time.LocalDate\nNotes:\nWhen the target language lacks a corresponding numeric type, we use the smallest type available that includes the required type. e.g. in TypeScript i08 is number When the target language lacks types for time","title":"Scalars"},{"location":"/idealingua/language-reference.html#collections","text":"Type name Explanation Scala mapping list[T] List List map[K, V] Map (only scalar and id keys are supported) Map opt[T] Optional value Option set[T] Set (unordered) Set","title":"Collections"},{"location":"/idealingua/json.html","text":"","title":"JSON Wire Format"},{"location":"/idealingua/json.html#json-wire-format","text":"IdeaLingua employs a simple JSON-based wire format. To interoperate, all the language translators should implement this spec.","title":"JSON Wire Format"},{"location":"/idealingua/json.html#data-data-class","text":"data defined as:\npackage example\n\ndata User {\n  name: str\n  surname: str\n  id: uuid\n}\nShould be rendered as:\n{\n  \"name\": \"Lorem\",\n  \"surname\": \"Ipsum\",\n  \"id\": \"13bee602-521b-47c2-ad81-30527f8b2398\"\n}","title":"data: Data Class"},{"location":"/idealingua/json.html#mixin-mixin","text":"When sent over the wire, mixins include a fully qualified name of their implementation.\nmixins defined as:\npackage example\n\nmixin IntPair {\n  x: i32\n  y: i32\n}\n\ndata NamedIntPair {\n  & IntPair\n  name: str\n}\nShould be rendered as:\n{ \n  \"example.IntPair#Struct\": {\n    \"x\": 256,\n    \"y\": 512\n  }\n}\nfor the default implementation, and:\n{\n  \"example#NamedIntPair\": {\n    \"x\": 256,\n    \"y\": 512,\n    \"name\": \"Vertex\"\n  }\n}\nfor the NamedIntPair implementation.","title":"mixin: Mixin"},{"location":"/idealingua/json.html#adt-algebraic-data-type","text":"adt’s include an unqualified name of their variant.\nadt defined as:\npackage example\n\nadt AB = A | Z as B\n\ndata A {\n  value: i32\n}\n\ndata Z {\n  value: str\n}\nShould be rendered as:\n{\n  \"A\": { \n    \"value\": 1\n  }\n}\nfor the A variant, and:\n{\n  \"B\": {\n    \"value\": \"abc\"\n  }\n}\nfor the Z as B variant","title":"adt: Algebraic Data Type"},{"location":"/idealingua/json.html#id-identifier","text":"Ids are rendered as strings prefixed by type name and separated by : symbol. Field order is preserved.\nid defined as:\npackage example\n\nid UserId {\n  userId: uuid\n  companyName: str\n}\nShould be rendered as:\n\"UserId#837006c8-d070-4cde-a2dd-8999c186ef02:Lightbend\"","title":"id: Identifier"},{"location":"/idealingua/json.html#alias-type-alias","text":"Type Aliases should be rendered directly as their aliased types and should never impact serialization.","title":"alias: Type Alias"},{"location":"/idealingua/json.html#enum-enumeration","text":"Enums are rendered as strings.\nenum defined as:\npackage example\n\nenum Gender = MALE | FEMALE\nShould be rendered as:\n\"FEMALE\"","title":"enum: Enumeration"},{"location":"/idealingua/json.html#service","text":"Service outputs are always wrapped into a JSON object with one field \"value\".\nFor service defined as:\npackage example\n\nservice SayHello {\n  def sayHello(): str\n}\nsayHello method will return a result rendered as:\n{ \"value\": \"hello\" }","title":"Service"},{"location":"/idealingua/cogen.html","text":"","title":"Code generator reference"},{"location":"/idealingua/cogen.html#code-generator-reference","text":"We support the following concepts:\nEnumerations Algebraic Data Types Type aliases Mixins Data Classes Identifiers Services","title":"Code generator reference"},{"location":"/idealingua/cogen.html#inheritance","text":"We support two forms of inheritance: interface inheritance (& modifier) and structural mixins (* modifier) The only difference between structural inheritance and interface inheritance is presence/absence of the base interface in the list of supertypes Both Data Classes and Mixins support both forms of inheritance Services, ADTs, Type Aliases, Identifiers and Enumerations does not support inheritance We provide widening narrowing implicit functions as well as copy constructors for all the generated entities","title":"Inheritance"},{"location":"/idealingua/cogen.html#example","text":"mixin IntPair {\n  x: i32\n  y: i32\n}\n\nmixin Metadata {\n  id: str\n  name: str\n}\n\nmixin PointLike {\n  + Metadata\n  * IntPair\n}\n\ndata Point {\n  + Metadata\n  * IntPair\n}","title":"Example"},{"location":"/idealingua/cogen.html#scala-output","text":"trait IntPair {\n  def y: Int\n  def x: Int\n}\n\ntrait Metadata {\n  def name: String\n  def id: String\n}\n\nfinal case class Point(y: Int, name: String, x: Int, id: String) extends Metadata\n\ntrait PointLike extends Metadata {\n  def y: Int\n  def x: Int\n  def name: String\n  def id: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#constructs","text":"Notes:\nAll the examples of generated code are given in minimal form Generated code for codecs, implicit conversions and type info is omitted","title":"Constructs"},{"location":"/idealingua/cogen.html#mixin-mixin","text":"mixin Person {\n   name: str\n   surname: str\n }","title":"mixin: Mixin"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Person {\n  def name: String\n  def surname: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#data-data-class","text":"Differences between Mixins and Data Classes:\nData classes cannot be subclassed Data classes are always rendered as case classes, Mixins are always rendered as pair of Interface and Implementation\ndata HumanUser {\n   + IdentifiedUser\n   * Person\n }","title":"data: Data Class"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class HumanUser(name: String, surname: String, id: UserId) extends IdentifiedUser with Person","title":"Scala output"},{"location":"/idealingua/cogen.html#adt-algebraic-data-type","text":"mixin Success {\n   values: map[str, str]\n }\n \n mixin Failure {\n   message: str\n }\n \n adt Result {\n   Success\n   Failure\n }","title":"adt: Algebraic Data Type"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Failure extends Any { def message: String }\n\ntrait Success extends Any { def values: scala.collection.immutable.Map[String, String] }\n\nsealed trait Result \n\nobject Result {\n  type Element = Result\n  \n  case class Success(value: Success) extends Result\n  case class Failure(value: Failure) extends Result\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#alias-type-alias","text":"alias UserId = str","title":"alias: Type Alias"},{"location":"/idealingua/cogen.html#scala-output","text":"package object domain01 {\ntype UserId = String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#enum-enumeration","text":"enum Gender {\n  MALE\n  FEMALE\n}","title":"enum: Enumeration"},{"location":"/idealingua/cogen.html#scala-output","text":"sealed trait Gender\n\nobject Gender {\n  type Element = Gender\n  def all: Seq[Gender] = Seq(MALE, FEMALE)\n  def parse(value: String) = value match {\n    case \"MALE\" => MALE\n    case \"FEMALE\" => FEMALE\n  }\n  case object MALE extends Gender { override def toString: String = \"MALE\" }\n  case object FEMALE extends Gender { override def toString: String = \"FEMALE\" }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#id-identifier","text":"Notes:\nYou can use only scalar builtin types for identifier fields We provide both parser and sane .toString implementation .toString uses the following format: Name#urlencoded(part1):urlencoded(part2):... Fields are sorted by name before using in parser and .toString\nid UserId {\n  value: uid\n  company: uid\n}","title":"id: Identifier"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class UserId(value: java.util.UUID, company: java.util.UUID) {\n  override def toString: String = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.company, this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"UserId#$suffix\"\n  }\n}\n\nobject UserId {\n  def parse(s: String): UserId = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    UserId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]), parsePart[java.util.UUID](parts(1), classOf[java.util.UUID]))\n  }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#service-service","text":"id RecordId {\n  value: uid\n}\n\nmixin WithRecordId {\n  id: RecordId\n}\n\nmixin WithResult {\n  result: shared.rpc#Result\n}\n\nmixin UserData {\n  email: str\n}\n\nmixin PrivateUserData {\n  balance: f64\n}\n\nservice UserService {\n  def deleteUser(WithRecordId): (WithResult)\n  def createUser(UserData, PrivateUserData): (WithRecordId, WithResult)\n}\nNotes:\nService signature cannot accept anything except of Mixins (improvements planned) ServerDispatcher allows you to route wrapped result type to an appropriate method of an abstract implementation ClientDispatcher just passes input to an abstract receiver ClientWrapper allows you to transform unwrapped method signatures into wrapping instances ServerWrapped provides you an unwrapping service implementation ServiceUnwrapped provides you a way to implement services with signatures unwrapped","title":"service: Service"},{"location":"/idealingua/cogen.html#scala-output","text":"import _root_.izumi.idealingua.model._\nimport _root_.izumi.idealingua.runtime._\n\nclass UserServiceServerDispatcher[R[+_], S <: UserService[R]](val service: S) extends transport.AbstractServerDispatcher[R, S] {\n  import UserService._\n  override def dispatch(input: UserService.InUserService): R[UserService.OutUserService] = input match {\n    case value: UserService.InDeleteUser =>\n      service.deleteUser(value)\n    case value: UserService.InCreateUser =>\n      service.createUser(value)\n  }\n}\n\nclass UserServiceClientDispatcher[R[+_], S <: UserService[R]](dispatcher: transport.AbstractClientDispatcher[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = dispatcher.dispatch(input, classOf[UserService.OutDeleteUser])\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = dispatcher.dispatch(input, classOf[UserService.OutCreateUser])\n}\n\nclass UserServiceClientWrapper[R[+_], S <: UserService[R]](val service: S) extends model.IDLClientWrapper[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser] = {\n    service.deleteUser(UserService.InDeleteUser(id = id))\n  }\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser] = {\n    service.createUser(UserService.InCreateUser(balance = balance, email = email))\n  }\n}\n\ntrait UserServiceUnwrapped[R[+_], S <: UserService[R]] extends model.IDLServiceExploded[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser]\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser]\n}\n\nclass UserServiceServerWrapper[R[+_], S <: UserService[R]](val service: UserServiceUnwrapped[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = service.deleteUser(id = input.id)\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = service.createUser(balance = input.balance, email = input.email)\n}\n\ntrait UserService[R[_]] extends izumi.idealingua.runtime.model.IDLService[R] {\n  import UserService._\n  override type InputType = UserService.InUserService\n  override type OutputType = UserService.OutUserService\n  \n  override def inputClass: Class[UserService.InUserService] = classOf[UserService.InUserService]\n  override def outputClass: Class[UserService.OutUserService] = classOf[UserService.OutUserService]\n  \n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser]\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser]\n}\n\nobject UserService {\n  sealed trait InUserService extends Any \n  sealed trait OutUserService extends Any\n\n  case class InDeleteUser(id: RecordId) extends UserService.InUserService with WithRecordId\n  case class OutDeleteUser(result: shared.rpc.Result) extends AnyVal with UserService.OutUserService with WithResult\n  case class InCreateUser(balance: Double, email: String) extends UserService.InUserService with UserData with PrivateUserData\n  case class OutCreateUser(result: shared.rpc.Result, id: RecordId) extends UserService.OutUserService with WithRecordId with WithResult\n}","title":"Scala output"},{"location":"/idealingua/cogen-circe.html","text":"","title":"Circe serialization reference"},{"location":"/idealingua/cogen-circe.html#circe-serialization-reference","text":"","title":"Circe serialization reference"},{"location":"/idealingua/cogen-circe.html#polymorphism-and-time","text":"Notes:\nData classes cannot be polymorphic\nThe following example demonstrates how polymorphism and time values are handled:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\ntrait Polymorphic\n\nfinal case class TestPayload(\n                        zonedDateTime: ZonedDateTime = ZonedDateTime.now()\n                        , utcZonedDateTime: ZonedDateTime = ZonedDateTime.now(ZoneId.of(\"UTC\"))\n                        , localDateTime: LocalDateTime = LocalDateTime.now()\n                        , localTime: LocalTime = LocalTime.now()\n                        , localDate: LocalDate = LocalDate.now()\n                      ) extends Polymorphic\n\nobject TestPayload {\n  implicit val encodeTestPayload: Encoder[TestPayload] = deriveEncoder[TestPayload]\n  implicit val decodeTestPayload: Decoder[TestPayload] = deriveDecoder[TestPayload]\n}\n\nfinal case class AnotherPayload(message: String) extends Polymorphic\n\nobject AnotherPayload {\n  implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n  implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n}\n\nobject Polymorphic {\n    implicit val encodePolymorphic: Encoder[Polymorphic] = Encoder.instance { c =>\n    c match {\n      case v: TestPayload =>\n        Map(\"com.test#TestPayload\" -> v).asJson\n      case v: AnotherPayload =>\n        Map(\"com.test#RealPayload\" -> v).asJson\n    }\n  }\n  implicit val decodePolymorphic: Decoder[Polymorphic] = Decoder.instance(c => {\n    val fname = c.keys.flatMap(_.headOption).toSeq.head\n    val value = c.downField(fname)\n    fname match {\n      case \"com.test#TestPayload\" =>\n        value.as[TestPayload]\n      case \"com.test#RealPayload\" =>\n        value.as[AnotherPayload]\n    }\n  })\n}\n\ndef test(t: Polymorphic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Polymorphic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(TestPayload())\ntest(AnotherPayload(\"hi\"))\nThis example produces the following output:\nTestPayload:\nEncoded:\n{\"TestPayload\":{\"zonedDateTime\":\"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\"utcZonedDateTime\":\"2018-04-02T21:34:31.367744Z[UTC]\",\"localDateTime\":\"2018-04-02T22:34:31.36778\",\"localTime\":\"22:34:31.367813\",\"localDate\":\"2018-04-02\"}}\n\nParsed:\nRight({\n  \"TestPayload\" : {\n    \"zonedDateTime\" : \"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\n    \"utcZonedDateTime\" : \"2018-04-02T21:34:31.367744Z[UTC]\",\n    \"localDateTime\" : \"2018-04-02T22:34:31.36778\",\n    \"localTime\" : \"22:34:31.367813\",\n    \"localDate\" : \"2018-04-02\"\n  }\n})\n\nRestored:\nRight(Right(TestPayload(2018-04-02T22:34:31.367649+01:00[Europe/Dublin],2018-04-02T21:34:31.367744Z[UTC],2018-04-02T22:34:31.367780,22:34:31.367813,2018-04-02)))\n\n\nAnotherPayload:\nEncoded:\n{\"RealPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"RealPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Polymorphism and time"},{"location":"/idealingua/cogen-circe.html#algebraic-types","text":"Notes:\nWorks same way as polymorphic types Use short names instead of fully qualified names You may introduce a local alias for an algebraic type member: adt MyAdt { domain1.A as A1 | A}. This allows you to resolve name conflicts\nCogen example for ADTs:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\nsealed trait Algebraic\n\nobject NS1 {\n\n  case class Payload(localTime: LocalTime = LocalTime.now()) extends Algebraic\n\n  object Payload {\n    implicit val encodeTestPayload: Encoder[Payload] = deriveEncoder[Payload]\n    implicit val decodeTestPayload: Decoder[Payload] = deriveDecoder[Payload]\n  }\n\n}\n\nobject NS2 {\n\n  case class AnotherPayload(message: String) extends Algebraic\n\n  object AnotherPayload {\n    implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n    implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n  }\n\n}\nobject Algebraic {\n  implicit val encodePolymorphic: Encoder[Algebraic] = deriveEncoder[Algebraic]\n  implicit val decodePolymorphic: Decoder[Algebraic] = deriveDecoder[Algebraic]\n}\n\ndef test(t: Algebraic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Algebraic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(NS1.Payload())\ntest(NS2.AnotherPayload(\"hi\"))\nOutput:\nEncoded:\n{\"Payload\":{\"localTime\":\"18:13:31.942072\"}}\n\nParsed:\nRight({\n  \"Payload\" : {\n    \"localTime\" : \"18:13:31.942072\"\n  }\n})\n\nRestored:\nRight(Right(Payload(18:13:31.942072)))\n\nEncoded:\n{\"AnotherPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"AnotherPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Algebraic types"},{"location":"/idealingua/cogen-circe.html#identifiers","text":"Identifiers codec just invokes .toString and .parse to serialize/deserialize Identifiers.\nPlease check identifier codegen example for additional details.\nFull example:\nfinal case class CompanyId(value: java.util.UUID) {\n  override def toString: String = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"CompanyId#$suffix\"\n  }\n}\n\ntrait CompanyIdCirce {\n  import _root_.io.circe.{ Encoder, Decoder }\n  implicit val encodeCompanyId: Encoder[CompanyId] = Encoder.encodeString.contramap(_.toString)\n  implicit val decodeCompanyId: Decoder[CompanyId] = Decoder.decodeString.map(CompanyId.parse)\n}\n\nobject CompanyId extends CompanyIdCirce {\n  def parse(s: String): CompanyId = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    CompanyId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]))\n  }\n  implicit class CompanyIdExtensions(_value: CompanyId)\n}","title":"Identifiers"},{"location":"/idealingua/cogen-circe.html#enumerations","text":"Identifiers codec just invokes .toString and .parse same way as it implemented for Identifiers.","title":"Enumerations"},{"location":"/sbt/index.html","text":"","title":"SBT Toolkit"},{"location":"/sbt/index.html#sbt-toolkit","text":"MOVED Moved to https://github.com/7mind/sbtgen/\nIzumi provides you a bunch of sbt plugins allowing you to significantly reduce size and increase clarity of huge multi-module builds.\nTo start using Izumi plugins add the following into your project/plugins.sbt:\n// This is Izumi Bill of Materials, see below\naddSbtPlugin(\"io.7mind.izumi\" % \"sbt-izumi-deps\" % \"0.10.16\")\n\n// Izumi SBT plugins\naddSbtPlugin(\"io.7mind.izumi.sbt\" % \"sbt-izumi\" % \"0.0.57\")\nWe provide you the following kinds of plugins:\nGlobal plugins: they add some helper sbt tasks, enabled automatically, Environmental plugins: they change some aspects of sbt behavior in an opinionated way, intended to be enabled in the root project, Presets - opinionated sets of environmental plugins, Optional plugins: they provide some convenience sbt tasks, intended to be enabled manually, per-project.\nImportant notes:\nPlease keep in mind no plugins are being enabled automatically, The rest of Izumi plugins are optional. You may use a preset to activate them or combine them manually as you wish (using settings groups), Some plugins can’t be enabled globally due to sbt limitations – they have to be enabled per-project. You should use Settings Groups in order to enable them.","title":"SBT Toolkit"},{"location":"/sbt/index.html#global-plugins","text":"Plugin Description IzumiImportsPlugin Makes all the Izumi imports visible by default","title":"Global plugins"},{"location":"/sbt/index.html#environmental-plugins","text":"Plugin Description IzumiBuildManifestPlugin Adds build info into jar manifests IzumiConvenienceTasksPlugin Devops/workflow helpers IzumiDslPlugin Compact build definitions IzumiGitStampPlugin Adds GIT status into jar manifests IzumiPropertiesPlugin Convenience helpers for sys.props IzumiResolverPlugin Better defaults for artifact resolution IzumiInheritedTestScopesPlugin Convenience helpers for test scope inheritance","title":"Environmental plugins"},{"location":"/sbt/index.html#presets","text":"Plugin Description IzumiEnvironment All the environmental plugins except of GIT one IzumiGitEnvironment All the environmental plugins with GIT one","title":"Presets"},{"location":"/sbt/index.html#optional-plugins","text":"Plugin Description IzumiExposedTestScopesPlugin Maintains test scope separation IzumiCompilerOptionsPlugin Some linting/optimization presets for scalac/javac IzumiFetchPlugin Allows you to transitively download artifacts from remote repositories IzumiPublishingPlugin Some convenience helpers and improvements for artifact publishing IzumiBuildInfoPlugin Generates sbt-compatible BOMs – Bills of Materials","title":"Optional plugins"},{"location":"/sbt/index.html#installation","text":"To activate all the plugins add the following statements into your root project:\nenablePlugins(IzumiGitEnvironmentPlugin)\nIf you don’t use git in your project, use this preset instead:\nenablePlugins(IzumiEnvironmentPlugin)\nTo activate Comp\nval GlobalSettings = new DefaultGlobalSettingsGroup {\n  override val plugins = Set(IzumiCompilerOptionsPlugin, IzumiExposedTestScopesPlugin)\n}","title":"Installation"},{"location":"/sbt/index.html#inherited-test-scopes","text":"","title":"Inherited Test Scopes"},{"location":"/sbt/index.html#test-scope-inheritance","text":"IzumiScopesPlugin extends SBT Project with several implicit methods:\ntestOnlyRef - provides you a project reference which is equivalent to % \"test\" dependency, dependsSeq and depends - allow you to add dependencies to your project the way test scopes of your dependencies are visible within test scopes of your project. So, essentially when you use these methods your dependencies are added into your projects with the following qualifier: \"test->compile,test;it->compile,test,it\"\nYou need to activate DefaultItSettingsGroup on your projects (see “Setting Groups” below) in order to make this working on it scope.\nExample:\nlazy val myLibrary = ...\n\nlazy val myProject = (...).depends(myLibrary)\nSo, now you may use classes from the test scope of myLibrary within test scope of myProject","title":"Test Scope Inheritance"},{"location":"/sbt/index.html#test-scope-separation","text":"InheritedTestScopesPlugin works in pair with IzumiScopesPlugin and provides you an unique feature: only the classes you marked with @ExposedTestScope are being exposed to dependant artifacts.\nSo, let’s assume that:\nyou have two artifacts, Library and App, App depends on Library, In the test scope of Library you have a class named TestSuite, In the test scope of Library you have another class named TestUtil, TestUtil is annotated with @ExposedTestScope,\nin that case TestUtil will be visible in App’s test scope, but TestSuite will not be visible.\nA diagram:\n+-----------------------------------------+     +-----------------------------------------+\n| Library                                 |     | App                                     |\n|-----------------------------------------|     |-----------------------------------------|\n| Main scope                              |     | Main scope                              |\n|                                     <---+-----+--                                       |\n| UtilityClass                            |     | AppMain                                 |\n|-----------------------------------------|     |-----------------------------------------+\n| Private Test Scope | Exposed test scope |     | Test scope                              |\n|                    |                <---+-----+--                                       |\n| TestSuite          | TestUtil           |     | Private Test Scope | Exposed test scope |\n+-----------------------------------------+     +-----------------------------------------+\nNotes:\nIntellij IDEA doesn’t support overriden classpaths so when you run your tests under IDEA the whole test scopes are visible in dependencies, At the moment the implementation of @ExposedTestScope (substring presence check) is imperfect and has to be improved, Transitive dependencies are not checked, so in case you expose a class but do not expose it’s dependencies your build will work under IDEA, but you will a classloading exception under sbt. This is going to be improved in the future.","title":"Test Scope Separation"},{"location":"/sbt/index.html#test-scope-publishing","text":"The whole content of test scopes is being published by default with test qualifier. Test scope separation has no effect on test scope publishing.","title":"Test Scope Publishing"},{"location":"/sbt/index.html#settings-dsl","text":"IzumiDslPlugin comes with a DSL intended to simplify definition of complex project layouts.\nTo activate the plugin add the following statement into your root project:\nenablePlugins(IzumiDslPlugin)","title":"Settings DSL"},{"location":"/sbt/index.html#simplified-identifiers","text":"DSL provides syntax to simplify project definitions. A definition such as this:\nlazy val petstoreApp = In(\"app\").as.module\nexpands to\nlazy val petstoreApp = project.in(\"app/petstore-app\")\nYou can attach settings and dependencies to the In part, that way you can apply common settings to all the projects in a directory:\nval ApiSettings = new SettingsGroup {\n  override val plugins = Set(IdealinguaPlugin)\n}\n\nlazy val inApi = In(\"api\").settings(ApiSettings)\n\nlazy val petstoreApi = inApi.as.module\nlazy val todomvcApi = inApi.as.module","title":"Simplified Identifiers"},{"location":"/sbt/index.html#setting-groups","text":"","title":"Setting Groups"},{"location":"/sbt/index.html#global-setting-group","text":"","title":"Global Setting Group"},{"location":"/sbt/index.html#automatic-aggregation","text":"When you use .as.project or .as.module syntax to define a project, that project is stored in a global singleton.\nYou may use transitiveAggregate or transitiveAggregateSeq methods instead of standard aggregate, in that case all the transitive dependencies of the projects provided will be also added into aggregation list. This allows you to simplify your definitions by avoiding specifing all the modules in .aggregate.\nIn case you don’t want your project to be recorded, you shoud use .as.just syntax.\nImportant note: sbt is lazy! We just store project reference in a singleton list, we don’t analyze dependency graph. Though sbt relies on lazy val declarations. So, in fact the singleton initializes at the moment you invoke aggregation. In case you don’t add a project into aggregation list such a project still will be initialized by sbt and added into the singleton, but it would happen later than evaluation of aggregation list so the project will not be aggregated.","title":"Automatic Aggregation"},{"location":"/sbt/index.html#aggregation-safety-check","text":"When you invoke transitiveAggregate or transitiveAggregateSeq on your root project it checks if the accumulated set of known project is the same as the set of all projects loaded by sbt.\nIn case module is missing you’ll get a warning. This makes it unlikely for you to accidentally forget to aggregate a module in multi-module project.","title":"Aggregation Safety Check"},{"location":"/sbt/index.html#build-descriptors","text":"","title":"Build Descriptors"},{"location":"/sbt/index.html#bills-of-materials","text":"Izumi brings Bill of Materials concept to SBT.","title":"Bills of Materials"},{"location":"/sbt/index.html#izumi-bom","text":"You can import Izumi libraries and transitive dependencies without specifying their version or even artifact names. To do that add sbt-izumi-deps SBT plugin:\nval izumi_version = \"0.10.16\"\naddSbtPlugin(\"io.7mind.izumi\" % \"sbt-izumi-deps\" % izumi_version)\nYou can use it like this:\nlibraryDependencies += Izumi.R.distage_core // Import an izumi library\nlibraryDependencies += IzumiDeps.R.cats_effect // Import a dependency of izumi\nlibraryDependencies += IzumiDeps.T.scalatest // Import a dependency of izumi in test scope\nR is for Runtime artifacts and T is for Test scope artifacts","title":"Izumi BOM"},{"location":"/sbt/index.html#create-a-bom-for-your-projects","text":"sbt-izumi-deps allows you to a create BOMs for your own projects. Just add the following snippet into your project settings:\nlazy val myProject = (project in file(\"my-project-bom\"))\n  .settings(withBuildInfo(\"com.mycompany.myproject\", \"MyProjectBOM\"))\nIf you use Izumi SBT DSL, you can use the following syntax:\nlazy val inRoot = In(\".\")\nlazy val myProjectBom = inRoot.as.module\n  .settings(withBuildInfo(\"com.mycompany.myproject\", \"MyProjectBOM\"))\nIf you want to include BOMs of you project, you can use the following syntax:\nimport com.mycompany.myproject.MyProjectBOM\n\nlazy val myLib = In(\"lib\").as.module\n  .settings(\n    libraryDependencies ++= Seq(\n      MyProjectBOM.R.my_project_bom,     // Runtime artifact\n      MyProjectBOM.T.my_project_bom,     // Runtime artifacts for test scope*\n      MyProjectBOM.TSR.my_project_bom,   // Test artifacts\n      MyProjectBOM.TST.my_project_bom,   // Test artifacts for test scope\n    )\n  )","title":"Create a BOM for your projects"},{"location":"/sbt/index.html#build-manifest-entries","text":"","title":"Build Manifest entries"},{"location":"/sbt/index.html#git-manifest-entries","text":"GitStampPlugin adds the following values into MANIFEST.MF of each jar artifact produced:\nManifest Key Description X-Git-Branch The name of branch sbt was invoked on X-Git-Repo-Is-Clean true or false, indicates if GIT repo was in clean state when the build was invoked X-Git-Head-Rev GIT revision on which sbt was invoked\nTo activate the plugin add the following statement into your root project:\nenablePlugins(GitStampPlugin)","title":"Git Manifest entries"},{"location":"/sbt/index.html#convenience-helpers","text":"","title":"Convenience Helpers"},{"location":"/sbt/index.html#stub-generators","text":"ConvenienceTasksPlugin provides you the following commands:\nnewModule <module_path/module_name> [package.suffix]: creates empty project layout at /module_path/module_name. Optional package.suffix may be specified. newStub <module_path/module_name> [stub_name:default]: copies /stubs/${stub_name} into /module_path/module_name. stub_name may be omitted, default value is default\nSetting Description ConvenienceTasksPlugin.Keys.mkJavaDirs Also adds src/*/java directories into generated stubs ConvenienceTasksPlugin.Keys.defaultStubPackage Default stub package. By default same as project’s organization","title":"Stub Generators"},{"location":"/sbt/index.html#version-suffixes","text":"ConvenienceTasksPlugin provides you command\naddVersionSuffix SUFFIX\nThis command updates project version defined in version.sbt with qualifier SUFFIX-SNAPSHOT\nExisting qualifiers will be removed. 1.0.0 would become 1.0.0-SUFFIX-SNAPSHOT 1.0.0-SNAPSHOT would become 1.0.0-SUFFIX-SNAPSHOT\nYou may need this command while setting up a build for feature branches and wish to avoid situation when different branches publishes artifacts with the same names.","title":"Version Suffixes"},{"location":"/sbt/index.html#target-preservation","text":"ConvenienceTasksPlugin provides you command\npreserveTargets SUFFIX\nThis command recursively enumerates all the directories named target and recursively copies them using name target.SUFFIX.\nYou may need this command while setting up a build where you wish to perform clean several times but want to preserve intermediate build artifacts stored in target directories. The most frequent case is coverage build followed by tests and then by production build. In this case you would like to use a command sequence like\n;clean;coverage;test;coverageOff;coverageReport;preserveTargets coverage;clean;publish","title":"target preservation"},{"location":"/sbt/index.html#directory-cleanups","text":"ConvenienceTasksPlugin provides you command\nrmDirs target.coverage\nThis command recursively removes all the directories named target.coverage across the project.\nYou may need this command to cleanup preserved target directories, or destroy some build artifacts, like rmDirs scala-2.11","title":"Directory cleanups"},{"location":"/sbt/index.html#property-readers","text":"IzumiPropertiesPlugin provides you implicit classes allowing you to convert Strings into Integers or Booleans exceptions-safe and do the same for system properties:\n\"true\".asBoolean(default = false) // true\n\"junk\".asBoolean(default = false) // false\n\"123\".asInt(default = 265) // 123\n\"junk\".asInt(default = 265) // 265\nsys.props.asBoolean(\"my.property\", default = false)\nsys.props.asInt(\"my.property\", default = 123)\nYou may activate this plugin with the following statement in root project:","title":"Property Readers"},{"location":"/sbt/index.html#transitive-artifact-downloader","text":"TODO","title":"Transitive Artifact Downloader"},{"location":"/sbt/index.html#optional-settings","text":"","title":"Optional settings"},{"location":"/sbt/index.html#publishing","text":"TODO","title":"Publishing"},{"location":"/sbt/index.html#publishing-settings","text":"TODO","title":"Publishing settings"},{"location":"/sbt/index.html#publishing-credentials-and-targets","text":"TODO","title":"Publishing credentials and targets"},{"location":"/sbt/index.html#compiler-options","text":"CompilerOptionsPlugin provides you some sane compiler option presets (linting, optimizations).\nYou should explicitly enable this plugin in each project you want to use it. When you want to enable it globally, use a settings group:\nval GlobalSettings = new SettingsGroup {\n  override val plugins = Set(\n      IzumiCompilerOptionsPlugin,\n      // ...\n  )\n  // ...\n}","title":"Compiler options"},{"location":"/sbt/index.html#resolvers","text":"ResolverPlugin turns on the following settings which should speedup your dependency resolution:\nupdateOptions := updateOptions\n      .value\n      .withCachedResolution(true)\n      .withGigahorse(true)","title":"Resolvers"},{"location":"/manifesto/index.html","text":"","title":"Productivity and challenges"},{"location":"/manifesto/index.html#productivity-and-challenges","text":"TODO Sorry, this page is not ready yet","title":"Productivity and challenges"},{"location":"/pper/index.html","text":"","title":"PPER Pattern"},{"location":"/pper/index.html#pper-pattern","text":"“Project Networks and Percept-Plan-Execute-Repeat loop to the rescue” slides\nTODO Sorry, this page is not ready yet","title":"PPER Pattern"}]}