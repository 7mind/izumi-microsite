{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Izumi Project"},{"location":"/index.html#izumi-project","text":"Izumi (*jp. 泉水, spring*) is an ecosystem of independent libraries and frameworks allowing you to significantly increase productivity of your Scala development.\nincluding the following components:\ndistage – Transparent and debuggable Dependency Injection framework for pure FP Scala, distage-testkit – Hyper-pragmatic pure FP Test framework. Shares heavy resources globally across all test suites; lets you easily swap implementations of component; uses your effect type for parallelism. distage-framework-docker – A distage extension for using docker containers in tests or for local application runs, comes with example Postgres, Cassandra, Kafka & DynamoDB containers. LogStage – Automatic structural logs from Scala string interpolations, BIO - A typeclass hierarchy for tagless final style with Bifunctor and Trifunctor effect types. Focused on ergonomics and ease of use with zero boilerplate. izumi-reflect (moved to zio/izumi-reflect) - Portable, lightweight and kind-polymorphic alternative to scala-reflect’s Typetag for Scala, Scala.js, Scala Native and (soon) Dotty IdeaLingua (moved to 7mind/idealingua-v1) – API Definition, Data Modeling and RPC language, optimized for fast prototyping – like gRPC or Swagger, but with a human face. Generates RPC servers and clients for Go, TypeScript, C# and Scala, Opinionated SBT plugins (moved to 7mind/sbtgen) – Reduces verbosity of SBT builds and introduces new features – inter-project shared test scopes and BOM plugins (from Maven) Percept-Plan-Execute-Repeat (PPER) – A pattern that enables modeling very complex domains and orchestrate deadly complex processes a lot easier than you’re used to.","title":"Izumi Project"},{"location":"/index.html#dependencies","text":"To use, add the following into project/build.sbt,\nlibraryDependencies ++= Seq(\n  // distage core library\n  \"io.7mind.izumi\" %% \"distage-core\" % \"1.0.2\",\n  // distage-testkit for ScalaTest\n  \"io.7mind.izumi\" %% \"distage-testkit-scalatest\" % \"1.0.2\" % Test,\n  // distage-framework: Roles, Entrypoints, Effect modules\n  \"io.7mind.izumi\" %% \"distage-framework\" % \"1.0.2\",\n  // Typesafe Config support\n  \"io.7mind.izumi\" %% \"distage-extension-config\" % \"1.0.2\",\n  // Classpath discovery support\n  \"io.7mind.izumi\" %% \"distage-extension-plugins\" % \"1.0.2\",\n  // LogStage integration with DIStage\n  \"io.7mind.izumi\" %% \"distage-extension-logstage\" % \"1.0.2\",\n\n  // LogStage core library\n  \"io.7mind.izumi\" %% \"logstage-core\" % \"1.0.2\",\n  // Write logs as JSON\n  \"io.7mind.izumi\" %% \"logstage-rendering-circe \" % \"1.0.2\",\n  // Route Slf4J logs to LogStage\n  \"io.7mind.izumi\" %% \"logstage-adapter-slf4j \" % \"1.0.2\",\n  // Route LogStage logs to Slf4J\n  \"io.7mind.izumi\" %% \"logstage-sink-slf4j \" % \"1.0.2\",\n\n)","title":"Dependencies"},{"location":"/index.html#development","text":"GitHub","title":"Development"},{"location":"/index.html#documentation","text":"Scaladoc Documentation SNAPSHOT Documentation","title":"Documentation"},{"location":"/index.html#further-reading","text":"Example projects:\nDIStage Example Project Idealingua Example Project with TypeScript and Scala\nSupport Chats:\nIzumi on Gitter Izumi User Group [RU] on Telegram Izumi User Group [EN] on Telegram\nVideos:\nIzumi 1.0: Your Next Scala Stack Scala, Functional Programming and Team Productivity (an overview of distage, distage-framework-docker & distage-testkit) Hyper-pragmatic Pure FP Testing with distage-testkit Livecoding: DIStage & Bifunctor Tagless Final on Youtube DevInsideYou — Tagless Final with BIO\nSlides:\nIzumi 1.0: Your Next Scala Stack Scala, Functional Programming and Team Productivity Hyper-pragmatic Pure FP Testing with distage-testkit distage: Staged Dependency Injection logstage: Zero-cost Structured Logging More slides","title":"Further reading"},{"location":"/index.html#credits","text":"YourKit supports open source projects with innovative and intelligent tools for monitoring and profiling Java and .NET applications. YourKit is the creator of YourKit Java Profiler YourKit .NET Profiler and YourKit YouMonitor.\ndistage: Staged Dependency Injection Getting started Why distage? FAQ Documentation Further reading Overview Debugging Advanced Features distage-framework distage-framework-docker distage-testkit Syntax Reference LogStage Dependencies Overview Syntax Reference Basic setup Log algebras ZIO environment support Custom JSON rendering with LogstageCodec SLF4J Router BIO Hierarchy Overview Syntax, Implicit Punning cats-effect compatibilty Data Types Misc Capabilities IdeaLingua RPC/DML User Service Example Quick start Example Project Installation Idealingua Language Reference JSON Wire Format Code generator reference Circe serialization reference SBT Toolkit Global plugins Environmental plugins Presets Optional plugins Installation Inherited Test Scopes Settings DSL Build Descriptors Convenience Helpers Optional settings Productivity and challenges PPER Pattern","title":"Credits"},{"location":"/distage/index.html","text":"","title":"distage: Staged Dependency Injection"},{"location":"/distage/index.html#distage-staged-dependency-injection","text":"distage is a pragmatic module system for Scala and Scala.js. It combines the simplicity and expressiveness of pure FP with the flexibility and extreme late-binding, traditionally associated with Java dependency injection frameworks, such as Guice.\ndistage supports any Scala style, whether it’s Tagless Final Style, ZIO Layer, ordinary FP, actor-based or imperative Scala.","title":"distage: Staged Dependency Injection"},{"location":"/distage/index.html#getting-started","text":"The best way get started is to clone distage-example sample project and play around with it.\nIt shows how to write an idiomatic distage application from scratch and how to:\nwrite tests using distage-testkit setup portable test environments using distage-framework-docker create role-based applications enable compile-time checks for fast feedback on wiring errors","title":"Getting started"},{"location":"/distage/index.html#why-distage-","text":"Faster applications and tests: distage guarantees that no unnecessary instantiations will happen during your tests or application startup. distage itself is very fast, in part due to not using Java reflection. Faster integration tests: distage-testkit allows you to reuse expensive resources (such as database connections and docker containers) across multiple test suites, gaining performance without sacrificing correctness. Managed test environments: distage-testkit eliminates all the hard work of setting up test environments, especially configurable ones. Easily describe tests environments, share heavy resources across all the test suites in the environment, use the power of DI to override components and run your tests under different scenarios. Compile-time error detection: distage can detect wiring errors at compile-time for fast feedback during development. Despite that, distage extensions are simple to write and do not require type-level programming. Early failure detection: distage performs all the integration checks for your application and tests even before any instantiations happen. Simplify development workflow: distage-framework allows you to develop Role-based applications, letting you run all your services in one process for development purposes (and even switch to mock implementations with a single commandline argument). Easy deployment: Role-based applications allow you to deploy and orchestrate fewer containers and achieve a higher computation density. Simple debugging: distage provides you insights about your application structure and allows you to introspect and modify it on the fly, before any instantiations happen. Lifecycle management: distage supports resources and lifecycle natively and guarantees proper cleanups even when something went wrong. Non-invasive: distage is designed to not impact the way your Scala code is written, it just removes all the initialization boilerplate. You don’t need to learn magic tricks to write components in a distage application. Cross-platform: distage is available for JVM, Graal Native Image and Scala.js.\nGiven its native support for type classes and higher-kinded types – both features indispensable to functional programming – distage is one of the leading dependency injection libraries out there. Bonus points for being built by a wicked-smart team that contributes to ZIO! — John A. De Goes","title":"Why distage?"},{"location":"/distage/index.html#faq","text":"Q: How to pronounce distage?\nA: ‘Dee-stage’\nQ: How do I switch between production and test implementations of components?\nA: Use Activation Axis","title":"FAQ"},{"location":"/distage/index.html#documentation","text":"Overview Debugging Advanced Features distage-framework distage-framework-docker distage-testkit Syntax Reference","title":"Documentation"},{"location":"/distage/index.html#further-reading","text":"Example projects:\nDIStage Example Project Idealingua Example Project with TypeScript and Scala\nSupport Chats:\nIzumi on Gitter Izumi User Group [RU] on Telegram Izumi User Group [EN] on Telegram\nVideos:\nIzumi 1.0: Your Next Scala Stack Scala, Functional Programming and Team Productivity Hyper-pragmatic Pure FP Testing with distage-testkit Livecoding: DIStage & Bifunctor Tagless Final DevInsideYou — Tagless Final with BIO\nSlides:\nIzumi 1.0: Your Next Scala Stack Scala, Functional Programming and Team Productivity Hyper-pragmatic Pure FP Testing with distage-testkit distage: Staged Dependency Injection LogStage: Zero-cost Structured Logging More slides","title":"Further reading"},{"location":"/distage/basics.html","text":"","title":"Overview"},{"location":"/distage/basics.html#overview","text":"Quick Start Dependencies Hello World example Singleton components Named components Non-singleton components Real-world example Activation Axis Multi-dimensionality Resource Bindings, Lifecycle Inheritance helpers Out-of-the-box typeclass instances Set Bindings Mutator Bindings Effect Bindings ZIO Has Bindings Converting ZIO environment dependencies to parameters Auto-Traits @impl annotation Avoiding constructors even further Auto-Factories @With annotation Tagless Final Style Effect-type polymorphism Kind polymorphism Cats & ZIO Integration","title":"Overview"},{"location":"/distage/basics.html#quick-start","text":"","title":"Quick Start"},{"location":"/distage/basics.html#dependencies","text":"Add the distage-core library:\nsbt libraryDependencies += \"io.7mind.izumi\" %% \"distage-core\" % \"1.0.2\"","title":"Dependencies"},{"location":"/distage/basics.html#hello-world-example","text":"Suppose we have an abstract Greeter component, and some other components that depend on it:\nimport zio.RIO\nimport zio.console.{Console, getStrLn, putStrLn}\n\ntrait Greeter {\n  def hello(name: String): RIO[Console, Unit]\n}\n\nfinal class PrintGreeter extends Greeter {\n  override def hello(name: String) =\n    putStrLn(s\"Hello $name!\")\n}\n\ntrait Byer {\n  def bye(name: String): RIO[Console, Unit]\n}\n\nfinal class PrintByer extends Byer {\n  override def bye(name: String) =\n    putStrLn(s\"Bye $name!\")\n}\n\nfinal class HelloByeApp(\n  greeter: Greeter,\n  byer: Byer,\n) {\n  def run: RIO[Console, Unit] = {\n    for {\n      _    <- putStrLn(\"What's your name?\")\n      name <- getStrLn\n      _    <- greeter.hello(name)\n      _    <- byer.bye(name)\n    } yield ()\n  }\n}\nTo actually run the HelloByeApp, we have to wire implementations of Greeter and Byer into it. We will not do it directly. First we’ll only declare the component interfaces we have, and the implementations we want for them:\nimport distage.ModuleDef\n\ndef HelloByeModule = new ModuleDef {\n  make[Greeter].from[PrintGreeter]\n  make[Byer].from[PrintByer]\n  make[HelloByeApp] // `.from` is not required for concrete classes\n}\nModuleDef merely contains a description of the desired object graph, let’s transform that high-level description into an actionable series of steps - an OrderedPlan, a datatype we can inspect, test or verify at compile-time – without having to actually create objects or execute effects.\nimport distage.{Activation, Injector, Roots}\n\nval injector = Injector[RIO[Console, *]]()\n// injector: Injector[zio.ZIO[zio.Has[Console.Service], Throwable, β$0$]] = izumi.distage.InjectorDefaultImpl@40b9d737\n\nval plan = injector.plan(HelloByeModule, Activation.empty, Roots.target[HelloByeApp])\n// plan: izumi.distage.model.plan.OrderedPlan = \n// {type.MdocSession::App1::Greeter} (basics.md:84) := call(π:Class(): MdocSession::App1::PrintGreeter) {}\n// {type.MdocSession::App1::Byer} (basics.md:85) := call(π:Class(): MdocSession::App1::PrintByer) {}\n// {type.MdocSession::App1::HelloByeApp} (basics.md:86) := call(π:Class(MdocSession::App1::Greeter, MdocSession::App1::Byer): MdocSession::App1::HelloByeApp) {\n//   arg greeter: MdocSession::App1::Greeter = lookup({type.MdocSession::App1::Greeter})\n//   arg byer: MdocSession::App1::Byer = lookup({type.MdocSession::App1::Byer})\n// }\nThe series of steps must be executed to produce the object graph.\nInjector.produce will interpret the steps into a Lifecycle value holding the lifecycle of the object graph:\nimport zio.Runtime.default.unsafeRun\n\n// Interpret into a Lifecycle value\n\nval resource = injector.produce(plan)\n// resource: izumi.distage.model.definition.Lifecycle[zio.ZIO[zio.Has[Console.Service], Throwable, β$0$], izumi.distage.model.Locator] = izumi.distage.model.definition.Lifecycle$$anon$10@3f1eee04\n\n// Use the object graph:\n// After `.use` exits, all objects will be deallocated,\n// and all allocated resources will be freed.\n\nval effect = resource.use {\n  objects =>\n    objects.get[HelloByeApp].run\n}\n// effect: zio.ZIO[zio.Has[Console.Service], Throwable, Unit] = zio.ZIO$CheckInterrupt@45db7b65\n\n// Run the resulting program\n\nunsafeRun(effect)\n// What's your name?\n// > izumi\n// Hello izumi!\n// Bye izumi!","title":"Hello World example"},{"location":"/distage/basics.html#singleton-components","text":"distage creates components at most once, even if multiple other objects depend on them.\nA given component X will be the same X everywhere in the object graph, i.e. a singleton.\nIt’s impossible to create non-singletons in distage.","title":"Singleton components"},{"location":"/distage/basics.html#named-components","text":"If you need multiple singleton instances of the same type, you may create “named” instances and disambiguate between them using @distage.Id annotation. (javax.inject.Named is also supported)\nimport distage.Id\n\ndef negateByer(otherByer: Byer): Byer = {\n  new Byer {\n    def bye(name: String) =\n     otherByer.bye(s\"NOT-$name\")\n  }\n}\n\nnew ModuleDef {\n  make[Byer].named(\"byer-1\").from[PrintByer]\n  make[Byer].named(\"byer-2\").from {\n    otherByer: Byer @Id(\"byer-1\") =>\n      negateByer(otherByer)\n  }\n}\nYou can use make[_].annotateParameter method instead of an annotation, to attach a name component to an existing constructor:\nnew ModuleDef {\n  // same binding as above\n  make[Byer].named(\"byer-2\")\n    .from(negateByer(_))\n    .annotateParameter[Byer](\"byer-1\")\n}\nYou can also abstract over annotations using type aliases and/or string constants (final val):\nobject Ids {\n  final val byer1Id = \"byer-1\"\n  type Byer1 = Byer @Id(byer1Id)\n}","title":"Named components"},{"location":"/distage/basics.html#non-singleton-components","text":"You cannot embed non-singletons into the object graph, but you may create them as normal using factories. distage’s Auto-Factories can generate implementations for your factories, removing the associated boilerplate.\nWhile Auto-Factories may remove the boilerplate of generating factories for singular components, if you need to create a new non-trivial subgraph dynamically, you’ll need to run Injector again – you may use Injector.inherit to reuse components from the outer object graph in your new nested object graph, see Injector Inheritance. It’s safe, performance-wise, to run Injector to create nested graphs, it’s extremely fast.","title":"Non-singleton components"},{"location":"/distage/basics.html#real-world-example","text":"Check out distage-example sample project for a complete example built using distage, bifunctor tagless final, http4s, doobie and zio libraries.\nIt shows how to write an idiomatic distage-style from scratch and how to:\nwrite tests using distage-testkit setup portable test environments using distage-framework-docker create role-based applications enable compile-time checks for fast feedback on wiring errors","title":"Real-world example"},{"location":"/distage/basics.html#activation-axis","text":"You can choose between different implementations of a component using “Activation axis”:\nimport distage.{Axis, Activation, ModuleDef, Injector}\n\nclass AllCapsGreeter extends Greeter {\n  def hello(name: String) =\n    putStrLn(s\"HELLO ${name.toUpperCase}\")\n}\n\n// declare a configuration axis for our components\n\nobject Style extends Axis {\n  case object AllCaps extends AxisChoiceDef\n  case object Normal extends AxisChoiceDef\n}\n\n// Declare a module with several implementations of Greeter\n// but in different environments\n\ndef TwoImplsModule = new ModuleDef {\n  make[Greeter].tagged(Style.Normal)\n    .from[PrintGreeter]\n\n  make[Greeter].tagged(Style.AllCaps)\n    .from[AllCapsGreeter]\n}\n\n// Combine previous `HelloByeModule` with our new module\n// While overriding `make[Greeter]` bindings from the first module\n\ndef CombinedModule = HelloByeModule overriddenBy TwoImplsModule\n\n// Choose component configuration when making an Injector:\n\nunsafeRun {\n  Injector()\n    .produceGet[HelloByeApp](CombinedModule, Activation(Style -> Style.AllCaps))\n    .use(_.run)\n}\n// What's your name?\n// > kai\n// HELLO KAI\n// Bye kai!\n\n// Check that result changes with a different configuration:\n\nunsafeRun {\n  Injector()\n    .produceGet[HelloByeApp](CombinedModule, Activation(Style -> Style.Normal))\n    .use(_.run)\n}\n// What's your name?\n// > Pavel\n// Hello Pavel!\n// Bye Pavel!\ndistage.StandardAxis contains bundled Axes for back-end development:\nRepo axis, with Prod/Dummy choices, describes any entities which may store and persist state or “repositories”. e.g. databases, message queues, KV storages, file systems, etc. Those may typically have both in-memory Dummy implementations and heavyweight Prod implementations using external databases. Mode axis, with Prod/Test choices, describes a generic choice between production and test implementations of a component. World axis, with Real/Mock choices, describes third-party integrations which are not controlled by the application and provided “as is”. e.g. Facebook API, Google API, etc. those may contact a Real external integration or a Mock one with predefined responses. Scene axis with Managed/Provided choices, describes whether external services required by the application should be set-up on the fly by an orchestrator library such as distage-framework-docker (Scene.Managed), or whether the application should try to connect to external services as if they already exist in the environment (Scene.Provided). We call a set of external services required by the application a Scene, etymology being that the running external services required by the application are like a “scene” that the “staff” (the orchestrator) must prepare for the “actor” (the application) to enter.\nIn distage-framework’s RoleAppMain, you can choose axes using the -u command-line parameter:\n./launcher -u repo:dummy -u env:prod app1\nIn distage-testkit, choose axes using TestConfig:\nimport distage.StandardAxis.Repo\nimport izumi.distage.testkit.TestConfig\nimport izumi.distage.testkit.scalatest.Spec2\n\nclass AxisTest extends Spec2[zio.IO] {\n\n  // choose implementations `.tagged` as `Repo.Dummy` over those tagged `Repo.Prod`\n  override def config: TestConfig = super.config.copy(\n    activation = Activation(Repo -> Repo.Dummy)\n  )\n\n}","title":"Activation Axis"},{"location":"/distage/basics.html#multi-dimensionality","text":"There may be many configuration axes in an application and components can specify multiple axis choices at once:\nimport distage.StandardAxis.Mode\n\nclass TestPrintGreeter extends Greeter {\n  def hello(name: String) =\n    putStrLn(s\"Test 1 2, hello $name\")\n}\n\n// declare 3 possible implementations\n\ndef TestModule = new ModuleDef {\n  make[Greeter].tagged(Style.Normal, Mode.Prod).from[PrintGreeter]\n  make[Greeter].tagged(Style.Normal, Mode.Test).from[TestPrintGreeter]\n  make[Greeter].tagged(Style.AllCaps).from[AllCapsGreeter]\n}\n\ndef runWith(activation: Activation) = unsafeRun {\n  Injector().produceRun(TestModule, activation) {\n    greeter: Greeter => greeter.hello(\"$USERNAME\")\n  }\n}\n\n// Production Normal Greeter\n\nrunWith(Activation(Style -> Style.Normal, Mode -> Mode.Prod))\n// Hello $USERNAME!\n\n// Test Normal Greeter\n\nrunWith(Activation(Style -> Style.Normal, Mode -> Mode.Test))\n// Test 1 2, hello $USERNAME\n\n// Both Production and Test Caps Greeters are the same:\n\nrunWith(Activation(Style -> Style.AllCaps, Mode -> Mode.Prod))\n// HELLO $USERNAME\n\nrunWith(Activation(Style -> Style.AllCaps, Mode -> Mode.Test))\n// HELLO $USERNAME","title":"Multi-dimensionality"},{"location":"/distage/basics.html#specificity-and-defaults","text":"When multiple dimensions are attached to a binding, bindings with less specified dimensions will be considered less specific and will be overridden by bindings with more dimensions, if all of those dimensions are explicitly set.\nA binding with no attached dimensions is considered a “default” vs. a binding with attached dimensions. A default will be chosen only if all other bindings are explicitly contradicted by passed activations. If the dimensions for other bindings are merely unset, it will cause an ambiguity error.\nExample of these rules:\nimport scala.util.Try\n\nsealed trait Color\ncase object RED extends Color\ncase object Blue extends Color\ncase object Green extends Color\n\n// Defaults:\n\ndef DefaultsModule = new ModuleDef {\n  make[Color].from(Green)\n  make[Color].tagged(Style.AllCaps).from(RED)\n}\n\nInjector().produceRun(DefaultsModule, Activation(Style -> Style.AllCaps))(println(_: Color))\n// RED\n// res11: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\n\nInjector().produceRun(DefaultsModule, Activation(Style -> Style.Normal))(println(_: Color))\n// Green\n// res12: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\n\n// ERROR Ambiguous without Style\nTry { Injector().produceRun(DefaultsModule, Activation.empty)(println(_: Color)) }.isFailure\n// res13: Boolean = true\n\n// Specificity\n\ndef SpecificityModule = new ModuleDef {\n  make[Color].tagged(Mode.Test).from(Blue)\n  make[Color].tagged(Mode.Prod).from(Green)\n  make[Color].tagged(Mode.Prod, Style.AllCaps).from(RED)\n}\n\nInjector().produceRun(SpecificityModule, Activation(Mode -> Mode.Prod, Style -> Style.AllCaps))(println(_: Color))\n// RED\n// res14: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\n\nInjector().produceRun(SpecificityModule, Activation(Mode -> Mode.Test, Style -> Style.AllCaps))(println(_: Color))\n// Blue\n// res15: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\n\nInjector().produceRun(SpecificityModule, Activation(Mode -> Mode.Prod, Style -> Style.Normal))(println(_: Color))\n// Green\n// res16: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\n\nInjector().produceRun(SpecificityModule, Activation(Mode -> Mode.Test))(println(_: Color))\n// Blue\n// res17: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\n\n// ERROR Ambiguous without Mode\nTry { Injector().produceRun(SpecificityModule, Activation(Style -> Style.Normal))(println(_: Color)) }.isFailure\n// res18: Boolean = true","title":"Specificity and defaults"},{"location":"/distage/basics.html#resource-bindings-lifecycle","text":"You can specify object lifecycle by injecting distage.Lifecycle, cats.effect.Resource or zio.ZManaged values specifying the allocation and finalization actions of an object.\nWhen ran, distage Injector itself returns a Lifecycle value that describes actions to create and finalize the object graph; the Lifecycle value is pure and can be reused multiple times.\nA Lifecycle is executed using its .use method, the function passed to use will receive an allocated resource and when the function exits the resource will be deallocated. Lifecycle is generally not invalidated after .use and may be executed multiple times.\nExample with cats.effect.Resource:\nimport distage.{Roots, ModuleDef, Injector}\nimport cats.effect.{Resource, IO}\n\nclass DBConnection\nclass MessageQueueConnection\n\nval dbResource = Resource.make(\n  acquire = IO {\n    println(\"Connecting to DB!\")\n    new DBConnection\n})(release = _ => IO(println(\"Disconnecting DB\")))\n// dbResource: Resource[IO, DBConnection] = Allocate(<function1>)\n\nval mqResource = Resource.make(\n  acquire = IO {\n   println(\"Connecting to Message Queue!\")\n   new MessageQueueConnection\n})(release = _ => IO(println(\"Disconnecting Message Queue\")))\n// mqResource: Resource[IO, MessageQueueConnection] = Allocate(<function1>)\n\nclass MyApp(\n  db: DBConnection,\n  mq: MessageQueueConnection,\n) {\n  val run = {\n    IO(println(\"Hello World!\"))\n  }\n}\n\ndef module = new ModuleDef {\n  make[DBConnection].fromResource(dbResource)\n  make[MessageQueueConnection].fromResource(mqResource)\n  make[MyApp]\n}\nWill produce the following output:\nimport distage.DIKey\n\nval objectGraphResource = {\n  Injector[IO]()\n    .produce(module, Roots.target[MyApp])\n}\n// objectGraphResource: izumi.distage.model.definition.Lifecycle[IO, izumi.distage.model.Locator] = izumi.distage.model.definition.Lifecycle$$anon$10@443ea24f\n\nobjectGraphResource\n  .use(_.get[MyApp].run)\n  .unsafeRunSync()\n// Connecting to Message Queue!\n// Connecting to DB!\n// Hello World!\n// Disconnecting DB\n// Disconnecting Message Queue\nLifecycle management with Lifecycle is also available without an effect type, via Lifecycle.Simple and Lifecycle.Mutable:\nimport distage.{Lifecycle, ModuleDef, Injector}\n\nclass Init {\n  var initialized = false\n}\n\nclass InitResource extends Lifecycle.Simple[Init] {\n  override def acquire = {\n    val init = new Init\n    init.initialized = true\n    init\n  }\n  override def release(init: Init) = {\n    init.initialized = false\n  }\n}\n\ndef module = new ModuleDef {\n  make[Init].fromResource[InitResource]\n}\n\nval closedInit = Injector()\n  .produceGet[Init](module)\n  .use {\n    init =>\n      println(init.initialized)\n      init\n}\n// true\n// closedInit: izumi.fundamentals.platform.functional.package.Identity[Init] = repl.MdocSession$App21$Init@4a30c590\n\nprintln(closedInit.initialized)\n// false\nLifecycle forms a monad and has the expected .map, .flatMap, .evalMap, .mapK methods.\nYou can convert between a Lifecycle and cats.effect.Resource via Lifecycle#toCats/Lifecycle.fromCats methods, and between a Lifecycle and zio.ZManaged via Lifecycle#toZIO/Lifecycle.fromZIO methods.","title":"Resource Bindings, Lifecycle"},{"location":"/distage/basics.html#inheritance-helpers","text":"The following helpers allow defining Lifecycle sub-classes using expression-like syntax:\nLifecycle.Of Lifecycle.OfInner Lifecycle.OfCats Lifecycle.OfZIO Lifecycle.LiftF Lifecycle.Make Lifecycle.Make_ Lifecycle.MakePair Lifecycle.FromAutoCloseable Lifecycle.SelfOf Lifecycle.MutableOf\nThe main reason to employ them is to workaround a limitation in Scala 2’s eta-expansion — when converting a method to a function value, Scala always tries to fulfill implicit parameters eagerly instead of making them parameters of the function value, this limitation makes it harder to inject implicits using distage.\nHowever, when using distage’s type-based syntax: make[A].fromResource[A.Resource[F]] — this limitation does not apply and implicits inject successfully.\nSo to workaround this limitation you can convert an expression based resource-constructor:\nimport distage.Lifecycle, cats.Monad\n\nclass A\nobject A {\n\n  def resource[F[_]: Monad]: Lifecycle[F, A] =\n    Lifecycle.pure[F, A](new A)\n\n}\nInto a class-based form:\nimport distage.Lifecycle, cats.Monad\n\nclass A\nobject A {\n\n  final class Resource[F[_]: Monad]\n    extends Lifecycle.Of(\n      Lifecycle.pure[F, A](new A)\n    )\n\n}\nAnd inject successfully using make[A].fromResource[A.Resource[F]] syntax of ModuleDefDSL.\nThe following helpers ease defining Lifecycle sub-classes using traditional inheritance where acquire/release parts are defined as methods:\nLifecycle.Basic Lifecycle.Simple Lifecycle.Mutable Lifecycle.MutableNoClose Lifecycle.Self Lifecycle.SelfNoClose Lifecycle.NoClose","title":"Inheritance helpers"},{"location":"/distage/basics.html#out-of-the-box-typeclass-instances","text":"Typeclass instances for popular typeclass hierarchies are included by default for the effect type in which distage is running.\nWhenever your effect type implements BIO or cats-effect typeclasses, their instances will be summonable without adding them into modules. This applies for ZIO, cats.effect.IO, monix, monix-bio and any other effect type with relevant typeclass instances in implicit scope.\nFor ZIO, monix-bio and any other implementors of BIO typeclasses, BIO hierarchy instances will be included. For ZIO, cats-effect instances will be included only if ZIO interop-cats library is on the classpath.\nExample usage:\nimport cats.effect.{IO, Sync}\nimport distage.{Activation, DefaultModule, Injector, Module, TagK}\nimport izumi.distage.model.effect.QuasiIO\n\ndef polymorphicHelloWorld[F[_]: TagK: QuasiIO: DefaultModule]: F[Unit] = {\n  Injector[F]().produceRun(\n    Module.empty, // we do not define _any_ components\n    Activation.empty,\n  ) {\n      (F: Sync[F]) => // cats.effect.Sync[F] is available anyway\n        F.delay(println(\"Hello world!\"))\n  }\n}\n\nval catsEffectHello = polymorphicHelloWorld[cats.effect.IO]\n// catsEffectHello: IO[Unit] = IO$43412508\n\nval monixHello = polymorphicHelloWorld[monix.eval.Task]\n// monixHello: monix.eval.Task[Unit] = Task.Async$478687096\n\nval zioHello = polymorphicHelloWorld[zio.IO[Throwable, ?]]\n// zioHello: zio.ZIO[Any, Throwable, Unit] = zio.ZIO$CheckInterrupt@2d15ca7c\n\nval monixBioHello = polymorphicHelloWorld[monix.bio.IO[Throwable, ?]]\n// monixBioHello: monix.bio.IO[Throwable, Unit] = IO.Async$1640338955\nSee DefaultModule implicit for implementation details. For details on what exact components are available for each effect type, see ZIOSupportModule, CatsIOSupportModule, MonixSupportModule, MonixBIOSupportModule, ZIOCatsEffectInstancesModule, respectively.\nDefaultModule occurs as an implicit parameter in distage entrypoints that require an effect type parameter, namely: Injector[F]() in distage-core, extends RoleAppMain[F] and extends PlanCheck.Main[F] in distage-framework and extends Spec1[F] in distage-testkit.","title":"Out-of-the-box typeclass instances"},{"location":"/distage/basics.html#set-bindings","text":"Set bindings are useful for implementing listeners, plugins, hooks, http routes, healthchecks, migrations, etc. Everywhere where a collection of components is required, a Set Binding is appropriate.\nTo define a Set binding use .many and .add methods of the ModuleDef DSL.\nAs an example, we may declare multiple command handlers and use them to interpret user input in a REPL\nimport distage.ModuleDef\n\nfinal case class CommandHandler(\n  handle: PartialFunction[String, String]\n)\n\nval additionHandler = CommandHandler {\n  case s\"$x + $y\" => s\"${x.toInt + y.toInt}\"\n}\n// additionHandler: CommandHandler = CommandHandler(<function1>)\n\nobject AdditionModule extends ModuleDef {\n  many[CommandHandler]\n    .add(additionHandler)\n}\nWe’ve used many method to declare an open Set of command handlers and then added one handler to it.\nWhen module definitions are combined, elements for the same type of Set will be merged together into a larger set.\nYou can summon a Set binding by summoning a scala Set, as in Set[CommandHandler].\nLet’s define a new module with another handler:\nval subtractionHandler = CommandHandler {\n  case s\"$x - $y\" => s\"${x.toInt - y.toInt}\"\n}\n// subtractionHandler: CommandHandler = CommandHandler(<function1>)\n\nobject SubtractionModule extends ModuleDef {\n  many[CommandHandler]\n    .add(subtractionHandler)\n}\nLet’s create a command-line application using our command handlers:\nimport distage.Injector\n\ntrait App {\n  def interpret(input: String): String\n}\nobject App {\n  final class Impl(\n    handlers: Set[CommandHandler]\n  ) extends App {\n    override def interpret(input: String): String = {\n      handlers.map(_.handle).reduce(_ orElse _).lift(input) match {\n        case Some(answer) => s\"ANSWER: $answer\"\n        case None         => \"?\"\n      }\n    }\n  }\n}\n\nobject AppModule extends ModuleDef {\n  // include all the previous module definitions\n  include(AdditionModule)\n  include(SubtractionModule)\n\n  // add a help handler\n  many[CommandHandler].add(CommandHandler {\n    case \"help\" => \"Please input an arithmetic expression!\"\n  })\n\n  // bind App\n  make[App].from[App.Impl]\n}\n\n// wire the graph and get the app\n\nval app = Injector().produceGet[App](AppModule).unsafeGet()\n// app: App = repl.MdocSession$App26$App$Impl@653f8ba3\n\n// check how it works\n\napp.interpret(\"1 + 5\")\n// res27: String = \"ANSWER: 6\"\n\napp.interpret(\"7 - 11\")\n// res28: String = \"ANSWER: -4\"\n\napp.interpret(\"1 / 3\")\n// res29: String = \"?\"\n\napp.interpret(\"help\")\n// res30: String = \"ANSWER: Please input an arithmetic expression!\"\nIf we rewire the app without SubtractionModule, it will expectedly lose the ability to subtract:\nInjector().produceRun(AppModule -- SubtractionModule.keys) {\n  app: App =>\n    app.interpret(\"10 - 1\")\n}\n// res31: String = \"?\"\nFurther reading:\nGuice calls the same concept “Multibindings”.","title":"Set Bindings"},{"location":"/distage/basics.html#mutator-bindings","text":"Mutations can be attached to any component using modify[X] keyword.\nIf present, they will be applied in an undefined order after the component has been created, but before it is visible to any other component.\nMutators provide a way to do partial overrides or slight modifications of some existing component without redefining it fully.\nExample:\nimport distage.{Id, Injector, ModuleDef}\n\ndef startingModule = new ModuleDef {\n  make[Int].fromValue(1) // 1\n}\n\ndef increment2 = new ModuleDef {\n  modify[Int](_ + 1) // 2\n  modify[Int](_ + 1) // 3\n}\n\ndef incrementWithDep = new ModuleDef {\n  make[String].fromValue(\"hello\")\n  make[Int].named(\"a-few\").fromValue(2)\n\n  // mutators may use other components and add additional dependencies\n  modify[Int].by(_.flatAp {\n    (s: String, few: Int @Id(\"a-few\")) => currentInt: Int =>\n      s.length + few + currentInt\n  }) // 5 + 2 + 3\n}\n\nInjector().produceRun(\n  startingModule ++\n  increment2 ++\n  incrementWithDep\n)((currentInt: Int) => currentInt): Int\n// res33: Int = 10\nAnother example: Suppose you’re using a config case class in your distage-testkit tests, and for one of the test you want to use a modified value for one of the fields in it. Before 1.0 you’d have to duplicate the config binding into a new key and apply the modifying function to it:\nimport distage.{Id, ModuleDef}\nimport distage.config.ConfigModuleDef\nimport izumi.distage.testkit.TestConfig\nimport izumi.distage.testkit.scalatest.SpecIdentity\n\nclass MyTest extends SpecIdentity {\n  override def config: TestConfig = super.config.copy(\n    moduleOverrides = new ConfigModuleDef {\n      makeConfig[Config](\"config.myconfig\").named(\"duplicate\")\n      make[Config].from {\n        (thatConfig: Config @Id(\"duplicate\")) =>\n          modifyingFunction(thatConfig)\n      }\n    }\n  )\n}\nNow instead of overriding the entire binding, we may use a mutator:\nclass MyTest extends SpecIdentity {\n  override def config: TestConfig = super.config.copy(\n    moduleOverrides = new ModuleDef {\n      modify[Config](modifyingFunction(_))\n    }\n  )\n}\nMutators are subject to configuration using Activation Axis and will be applied conditionally, if tagged:\nimport distage.{Activation, Injector, Mode}\n\ndef axisIncrement = new ModuleDef {\n  make[Int].fromValue(1)\n  modify[Int](_ + 10).tagged(Mode.Test)\n  modify[Int](_ + 1).tagged(Mode.Prod)\n}\n\nInjector().produceRun(axisIncrement, Activation(Mode -> Mode.Test))((currentInt: Int) => currentInt): Int\n// res35: Int = 11\n\nInjector().produceRun(axisIncrement, Activation(Mode -> Mode.Prod))((currentInt: Int) => currentInt): Int\n// res36: Int = 2","title":"Mutator Bindings"},{"location":"/distage/basics.html#effect-bindings","text":"Sometimes we want to effectfully create a component, but the resulting component or data does not need to be deallocated. An example might be a global Semaphore to limit the parallelism of the entire application based on configuration, or a test implementation of some service made with Refs.\nIn these cases we can use .fromEffect to create a value using an effectful constructor.\nExample with a Ref-based Tagless Final KVStore:\nimport distage.{Injector, ModuleDef}\nimport izumi.functional.bio.{Error2, Primitives2, F}\nimport zio.{Task, IO}\n\ntrait KVStore[F[_, _]] {\n  def get(key: String): F[NoSuchElementException, String]\n  def put(key: String, value: String): F[Nothing, Unit]\n}\n\ndef dummyKVStore[F[+_, +_]: Error2: Primitives2]: F[Nothing, KVStore[F]] = {\n  for {\n    ref <- F.mkRef(Map.empty[String, String])\n  } yield new KVStore[F] {\n    def put(key: String, value: String): F[Nothing, Unit] = {\n      ref.update_(_ + (key -> value))\n    }\n\n    def get(key: String): F[NoSuchElementException, String] = {\n      for {\n        map <- ref.get\n        res <- map.get(key) match {\n          case Some(value) => F.pure(value)\n          case None        => F.fail(new NoSuchElementException(key))\n        }\n      } yield res\n    }\n  }\n}\n\ndef kvStoreModule = new ModuleDef {\n  make[KVStore[IO]].fromEffect(dummyKVStore[IO])\n}\n\nval io = Injector[Task]()\n  .produceRun[String](kvStoreModule) {\n    kv: KVStore[IO] =>\n      for {\n        _    <- kv.put(\"apple\", \"pie\")\n        res1 <- kv.get(\"apple\")\n        _    <- kv.put(\"apple\", \"ipad\")\n        res2 <- kv.get(\"apple\")\n      } yield res1 + res2\n  }\n// io: Task[String] = zio.ZIO$CheckInterrupt@2138c41e\n\nzio.Runtime.default.unsafeRun(io)\n// res38: String = pieipad\nYou need to specify your effect type when constructing Injector, as in Injector[F](), to use effect bindings in chosen F[_].","title":"Effect Bindings"},{"location":"/distage/basics.html#zio-has-bindings","text":"You can inject into ZIO Environment using make[_].fromHas syntax for ZLayer, ZManaged, ZIO or any F[_, _, _]: Local3:\nimport zio._\nimport zio.console.{Console, putStrLn}\nimport distage.ModuleDef\n\nclass Dependency\n\nclass X(dependency: Dependency)\n\ndef makeX: URIO[Console with Has[Dependency], X] = {\n  for {\n    dep <- ZIO.service[Dependency]\n    _   <- putStrLn(s\"Obtained environment dependency = $dep\")\n  } yield new X(dep)\n}\n\ndef makeXManaged: URManaged[Console with Has[Dependency], X] = makeX.toManaged_\n\ndef makeXLayer: URLayer[Console with Has[Dependency], Has[X]] = makeX.toLayer\n\ndef module1 = new ModuleDef {\n  make[Dependency]\n\n  make[X].fromHas(makeX)\n  // or\n  make[X].fromHas(makeXManaged)\n  // or\n  make[X].fromHas(makeXLayer)\n}\nYou can also mix environment and parameter dependencies at the same time in one constructor:\ndef zioArgEnvCtor(\n  dependency: Dependency\n): URLayer[Console, Has[X]] = {\n  ZLayer.succeed(dependency) ++\n  ZLayer.identity[Console] >>>\n  makeX.toLayer\n}\n\ndef module2 = new ModuleDef {\n  make[Dependency]\n\n  make[X].fromHas(zioArgEnvCtor _)\n}\nzio.Has values are derived at compile-time by HasConstructor macro and can be summoned at need.\nAnother example:\nimport distage.{Injector, ModuleDef}\nimport zio.console.{putStrLn, Console}\nimport zio.{UIO, URIO, Ref, Task, Has}\n\ntrait Hello {\n  def hello: UIO[String]\n}\ntrait World {\n  def world: UIO[String]\n}\n\n// Environment forwarders that allow\n// using service functions from everywhere\n\nval hello: URIO[Has[Hello], String] = URIO.accessM(_.get.hello)\n// hello: URIO[Has[Hello], String] = zio.ZIO$Read@6bb65dc0\n\nval world: URIO[Has[World], String] = URIO.accessM(_.get.world)\n// world: URIO[Has[World], String] = zio.ZIO$Read@3e3c1679\n\n// service implementations\n\nval makeHello = {\n  (for {\n    _     <- putStrLn(\"Creating Enterprise Hellower...\")\n    hello = new Hello { val hello = UIO(\"Hello\") }\n  } yield hello).toManaged { _ =>\n    putStrLn(\"Shutting down Enterprise Hellower\")\n  }\n}\n// makeHello: zio.ZManaged[Console, Nothing, AnyRef with Hello{val hello: zio.UIO[String]}] = zio.ZManaged$$anon$2@7047b564\n\nval makeWorld = {\n  for {\n    counter <- Ref.make(0)\n  } yield new World {\n    val world = counter.get.map(c => if (c < 1) \"World\" else \"THE World\")\n  }\n}\n// makeWorld: zio.ZIO[Any, Nothing, AnyRef with World{val world: zio.ZIO[Any,Nothing,String]}] = zio.ZIO$FlatMap@17b89746\n\n// the main function\n\nval turboFunctionalHelloWorld: URIO[Has[Hello] with Has[World] with Has[Console.Service], Unit] = {\n  for {\n    hello <- hello\n    world <- world\n    _     <- putStrLn(s\"$hello $world\")\n  } yield ()\n}\n// turboFunctionalHelloWorld: URIO[Has[Hello] with Has[World] with Has[Console.Service], Unit] = zio.ZIO$FlatMap@4e39802c\n\ndef module = new ModuleDef {\n  make[Hello].fromHas(makeHello)\n  make[World].fromHas(makeWorld)\n  make[Unit].fromHas(turboFunctionalHelloWorld)\n}\n\nval main = Injector[Task]()\n  .produceRun[Unit](module)((_: Unit) => Task.unit)\n// main: Task[Unit] = zio.ZIO$CheckInterrupt@1068d84c\n\nzio.Runtime.default.unsafeRun(main)\n// Creating Enterprise Hellower...\n// Hello World\n// Shutting down Enterprise Hellower","title":"ZIO Has Bindings"},{"location":"/distage/basics.html#converting-zio-environment-dependencies-to-parameters","text":"Any ZIO Service that requires an environment can be turned into a service without an environment dependency by providing the dependency in each method using .provide.\nThis pattern can be generalized by implementing an instance of cats.Contravariant (or cats.tagless.FunctorK) for your services and using it to turn environment dependencies into constructor parameters.\nIn that way ZIO Environment can be used uniformly for declaration of dependencies, but the dependencies used inside the service do not leak to other services calling it. See: https://gitter.im/ZIO/Core?at=5dbb06a86570b076740f6db2\nExample:\nimport cats.Contravariant\nimport distage.{Injector, ModuleDef, Functoid, Tag, TagK, HasConstructor}\nimport zio.{Task, UIO, URIO, Has}\n\ntrait Dependee[-R] {\n  def x(y: String): URIO[R, Int]\n}\ntrait Depender[-R] {\n  def y: URIO[R, String]\n}\nimplicit val contra1: Contravariant[Dependee] = new Contravariant[Dependee] {\n  def contramap[A, B](fa: Dependee[A])(f: B => A): Dependee[B] = new Dependee[B] { def x(y: String) = fa.x(y).provideSome(f) }\n}\n// contra1: Contravariant[Dependee] = repl.MdocSession$App41$$anon$25@5dc9b3b0\nimplicit val contra2: Contravariant[Depender] = new Contravariant[Depender] {\n  def contramap[A, B](fa: Depender[A])(f: B => A): Depender[B] = new Depender[B] { def y = fa.y.provideSome(f) }\n}\n// contra2: Contravariant[Depender] = repl.MdocSession$App41$$anon$27@e980de8\n\ntype DependeeR = Has[Dependee[Any]]\ntype DependerR = Has[Depender[Any]]\nobject dependee extends Dependee[DependeeR] {\n  def x(y: String) = URIO.accessM(_.get.x(y))\n}\nobject depender extends Depender[DependerR] {\n  def y = URIO.accessM(_.get.y)\n}\n\n// cycle\nobject dependerImpl extends Depender[DependeeR] {\n  def y: URIO[DependeeR, String] = dependee.x(\"hello\").map(_.toString)\n}\nobject dependeeImpl extends Dependee[DependerR] {\n  def x(y: String): URIO[DependerR, Int] = {\n    if (y == \"hello\") UIO(5)\n    else depender.y.map(y.length + _.length)\n  }\n}\n\n/** Fulfill the environment dependencies of a service from the object graph */\ndef fullfill[R: Tag: HasConstructor, M[_]: TagK: Contravariant](service: M[R]): Functoid[M[Any]] = {\n  HasConstructor[R]\n    .map(depsCakeR => Contravariant[M].contramap(service)(_ => depsCakeR))\n}\n\ndef module = new ModuleDef {\n  make[Depender[Any]].from(fullfill(dependerImpl))\n  make[Dependee[Any]].from(fullfill(dependeeImpl))\n}\n\nInjector()\n  .produceRun(module) {\n    HasConstructor[DependeeR].map {\n      (for {\n        r <- dependee.x(\"zxc\")\n        _ <- Task(println(s\"result: $r\"))\n      } yield ()).provide(_)\n    }\n  }.fold(_ => 1, _ => 0)\n// res42: URIO[Any, Int] = <function1>","title":"Converting ZIO environment dependencies to parameters"},{"location":"/distage/basics.html#auto-traits","text":"distage can instantiate traits and structural types. All unimplemented fields in a trait, or a refinement are filled in from the object graph.\nTrait implementations are derived at compile-time by TraitConstructor macro and can be summoned at need.\nIf a suitable trait is specified as an implementation class for a binding, TraitConstructor will be used automatically:\nExample:\nimport distage.{ModuleDef, Id, Injector}\n\ntrait Trait1 {\n  def a: Int @Id(\"a\")\n}\ntrait Trait2 {\n  def b: Int @Id(\"b\")\n}\n\n/** All methods in this trait are implemented,\n  * so a constructor for it will be generated\n  * even though it's not a class */\ntrait Pluser {\n  def plus(a: Int, b: Int) = a + b\n}\n\ntrait PlusedInt {\n  def result(): Int\n}\nobject PlusedInt {\n\n  /**\n    * Besides the dependency on `Pluser`,\n    * this class defines 2 more dependencies\n    * to be injected from the object graph:\n    *\n    * `def a: Int @Id(\"a\")` and\n    * `def b: Int @Id(\"b\")`\n    *\n    * When an abstract type is declared as an implementation,\n    * its no-argument abstract defs & vals are considered as\n    * dependency parameters by TraitConstructor. (empty-parens and\n    * parameterized methods are not considered parameters)\n    *\n    * Here, using an abstract class directly as an implementation\n    * lets us avoid writing a lengthier constructor, like this one:\n    *\n    * {{{\n    *   final class Impl(\n    *     pluser: Pluser,\n    *     override val a: Int @Id(\"a\"),\n    *     override val b: Int @Id(\"b\"),\n    *   ) extends PlusedInt with Trait1 with Trait2\n    * }}}\n    */\n  abstract class Impl(\n    pluser: Pluser\n  ) extends PlusedInt\n    with Trait1\n    with Trait2 {\n    override def result(): Int = {\n      pluser.plus(a, b)\n    }\n  }\n\n}\n\ndef module = new ModuleDef {\n  make[Int].named(\"a\").from(1)\n  make[Int].named(\"b\").from(2)\n  make[Pluser]\n  make[PlusedInt].from[PlusedInt.Impl]\n}\n\nInjector().produceRun(module) {\n  plusedInt: PlusedInt =>\n    plusedInt.result()\n}\n// res44: izumi.fundamentals.platform.functional.package.Identity[Int] = 3","title":"Auto-Traits"},{"location":"/distage/basics.html#impl-annotation","text":"Abstract classes or traits without obvious concrete subclasses may hinder the readability of a codebase, to mitigate that you may use an optional @impl documenting annotation to aid the reader in understanding your intention.\nimport distage.impl\n\n@impl abstract class Impl(\n  pluser: Pluser\n) extends PlusedInt with Trait1 with Trait2 {\n  override def result(): Int = {\n    pluser.plus(a, b)\n  }\n}","title":"@impl annotation"},{"location":"/distage/basics.html#avoiding-constructors-even-further","text":"When overriding behavior of a class, you may avoid writing a repeat of its constructor in your sub-class by inheriting it with a trait instead. Example:\n/**\n  * Note how we avoid writing a call to the super-constructor\n  * of `PlusedInt.Impl`, such as:\n  *\n  * {{{\n  *   abstract class OverridenPlusedIntImpl(\n  *     pluser: Pluser\n  *   ) extends PlusedInt.Impl(pluser)\n  * }}}\n  *\n  * Which would be unavoidable with class-to-class inheritance.\n  * Using trait-to-class inheritance we avoid writing any boilerplate\n  * besides the overrides we want to apply to the class.\n  */\n@impl trait OverridenPlusedIntImpl extends PlusedInt.Impl {\n override def result(): Int = {\n   super.result() * 10\n }\n}\n\nInjector().produceRun(module overriddenBy new ModuleDef {\n  make[PlusedInt].from[OverridenPlusedIntImpl]\n}) {\n  plusedInt: PlusedInt =>\n    plusedInt.result()\n}\n// res45: izumi.fundamentals.platform.functional.package.Identity[Int] = 30","title":"Avoiding constructors even further"},{"location":"/distage/basics.html#auto-factories","text":"distage can instantiate ‘factory’ classes from suitable traits. This feature is especially useful with Akka. All unimplemented methods with parameters in a trait will be filled by factory methods:\nGiven a class ActorFactory:\nimport distage.ModuleDef\nimport java.util.UUID\n\nclass SessionStorage\n\nclass UserActor(sessionId: UUID, sessionStorage: SessionStorage)\n\ntrait ActorFactory {\n  // UserActor will be created as follows:\n  //   sessionId argument is provided by the user\n  //   sessionStorage argument is wired from the object graph\n  def createActor(sessionId: UUID): UserActor\n}\nAnd a binding of ActorFactory without an implementation\nclass ActorModule extends ModuleDef {\n  make[ActorFactory]\n}\ndistage will derive and bind the following implementation for ActorFactory:\nclass ActorFactoryImpl(sessionStorage: SessionStorage) extends ActorFactory {\n  override def createActor(sessionId: UUID): UserActor = {\n    new UserActor(sessionId, sessionStorage)\n  }\n}","title":"Auto-Factories"},{"location":"/distage/basics.html#with-annotation","text":"@With annotation can be used to specify the implementation class, to avoid leaking the implementation type in factory method result:\nimport distage.{Injector, ModuleDef, With}\n\ntrait Actor {\n  def receive(msg: Any): Unit\n}\n\nobject Actor {\n  trait Factory {\n    def newActor(id: String): Actor @With[Actor.Impl]\n  }\n\n  final class Impl(id: String, config: Actor.Configuration) extends Actor {\n    def receive(msg: Any) = {\n      val response = s\"Actor `$id` received a message: $msg\"\n      println(if (config.allCaps) response.toUpperCase else response)\n    }\n  }\n\n  final case class Configuration(allCaps: Boolean)\n}\n\ndef factoryModule = new ModuleDef {\n  make[Actor.Factory]\n  make[Actor.Configuration].from(Actor.Configuration(allCaps = false))\n}\n\nInjector()\n  .produceGet[Actor.Factory](factoryModule)\n  .use(_.newActor(\"Martin Odersky\").receive(\"ping\"))\n// Actor `Martin Odersky` received a message: ping\n// res48: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\nYou can use this feature to concisely provide non-Singleton semantics for some of your components.\nFactory implementations are derived at compile-time by FactoryConstructor macro and can be summoned at need.","title":"@With annotation"},{"location":"/distage/basics.html#tagless-final-style","text":"Tagless Final is one of the popular patterns for structuring purely-functional applications.\nBrief introduction to tagless final:\nDeferring Commitments: Tagless Final Introduction to Tagless Final\nAdvantages of distage as a driver for TF compared to implicits:\neasy explicit overrides easy effectful instantiation and resource management extremely easy & scalable test context setup due to the above multiple different implementations for a type using disambiguation by @Id\nFor example, let’s take freestyle’s tagless example and make it better by replacing dependencies on global imported implementations with explicit modules.\nFirst, the program we want to write:\nimport cats.Monad\nimport cats.effect.{Sync, IO}\nimport cats.syntax.all._\nimport distage.{Roots, Module, ModuleDef, Injector, Tag, TagK, TagKK}\n\ntrait Validation[F[_]] {\n  def minSize(s: String, n: Int): F[Boolean]\n  def hasNumber(s: String): F[Boolean]\n}\nobject Validation {\n  def apply[F[_]: Validation]: Validation[F] = implicitly\n}\n\ntrait Interaction[F[_]] {\n  def tell(msg: String): F[Unit]\n  def ask(prompt: String): F[String]\n}\nobject Interaction {\n  def apply[F[_]: Interaction]: Interaction[F] = implicitly\n}\n\nclass TaglessProgram[F[_]: Monad: Validation: Interaction] {\n  def program: F[Unit] = for {\n    userInput <- Interaction[F].ask(\"Give me something with at least 3 chars and a number on it\")\n    valid     <- (Validation[F].minSize(userInput, 3), Validation[F].hasNumber(userInput)).mapN(_ && _)\n    _         <- if (valid) Interaction[F].tell(\"awesomesauce!\")\n                 else       Interaction[F].tell(s\"$userInput is not valid\")\n  } yield ()\n}\n\ndef ProgramModule[F[_]: TagK: Monad] = new ModuleDef {\n  make[TaglessProgram[F]]\n}\nTagK is distage’s analogue of TypeTag for higher-kinded types such as F[_], it allows preserving type-information at runtime for type parameters. You’ll need to add a TagK context bound to create a module parameterized by an abstract F[_]. To parameterize by non-higher-kinded types, use just Tag.\nNow the interpreters for Validation and Interaction:\nfinal class SyncValidation[F[_]](implicit F: Sync[F]) extends Validation[F] {\n  def minSize(s: String, n: Int): F[Boolean] = F.delay(s.size >= n)\n  def hasNumber(s: String): F[Boolean]       = F.delay(s.exists(c => \"0123456789\".contains(c)))\n}\n\nfinal class SyncInteraction[F[_]](implicit F: Sync[F]) extends Interaction[F] {\n  def tell(s: String): F[Unit]  = F.delay(println(s))\n  def ask(s: String): F[String] = F.delay(\"This could have been user input 1\")\n}\n\ndef SyncInterpreters[F[_]: TagK: Sync] = {\n  new ModuleDef {\n    make[Validation[F]].from[SyncValidation[F]]\n    make[Interaction[F]].from[SyncInteraction[F]]\n  }\n}\n\n// combine all modules\n\ndef SyncProgram[F[_]: TagK: Sync] = ProgramModule[F] ++ SyncInterpreters[F]\n\n// create object graph Lifecycle\n\nval objectsLifecycle = Injector[IO]().produce(SyncProgram[IO], Roots.Everything)\n// objectsLifecycle: izumi.distage.model.definition.Lifecycle[IO, izumi.distage.model.Locator] = izumi.distage.model.definition.Lifecycle$$anon$10@c22c4f7\n\n// run\n\nobjectsLifecycle.use(_.get[TaglessProgram[IO]].program).unsafeRunSync()\n// awesomesauce!","title":"Tagless Final Style"},{"location":"/distage/basics.html#effect-type-polymorphism","text":"The program module is polymorphic over effect type. It can be instantiated by a different effect:\nimport zio.interop.catz._\nimport zio.Task\n\nval ZIOProgram = ProgramModule[Task] ++ SyncInterpreters[Task]\n// ZIOProgram: Module = \n// make[{type.repl.MdocSession::repl.MdocSession.App49::repl.MdocSession.App49.Validation[=λ %0 → ZIO[-Any,+Throwable,+0]]}].from(call(π:Class(cats.effect.Sync[=λ %0 → ZIO[-Any,+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App49::repl.MdocSession.App49.SyncValidation[=λ %0 → ZIO[-Any,+Throwable,+0]])) ((basics.md:1296))\n// make[{type.repl.MdocSession::repl.MdocSession.App49::repl.MdocSession.App49.Interaction[=λ %0 → ZIO[-Any,+Throwable,+0]]}].from(call(π:Class(cats.effect.Sync[=λ %0 → ZIO[-Any,+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App49::repl.MdocSession.App49.SyncInteraction[=λ %0 → ZIO[-Any,+Throwable,+0]])) ((basics.md:1297))\n// make[{type.repl.MdocSession::repl.MdocSession.App49::repl.MdocSession.App49.TaglessProgram[=λ %0 → ZIO[-Any,+Throwable,+0]]}].from(call(π:Class(cats.Monad[=λ %0 → ZIO[-Any,+Throwable,+0]], repl.MdocSession::repl.MdocSession.App49::repl.MdocSession.App49.Validation[=λ %0 → ZIO[-Any,+Throwable,+0]], repl.MdocSession::repl.MdocSession.App49::repl.MdocSession.App49.Interaction[=λ %0 → ZIO[-Any,+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App49::repl.MdocSession.App49.TaglessProgram[=λ %0 → ZIO[-Any,+Throwable,+0]])) ((basics.md:1275))\nWe may even choose different interpreters at runtime:\nimport zio.RIO\nimport zio.console.{Console, getStrLn, putStrLn}\nimport distage.Activation\n\nobject RealInteractionZIO extends Interaction[RIO[Console, ?]] {\n  def tell(s: String): RIO[Console, Unit]  = putStrLn(s)\n  def ask(s: String): RIO[Console, String] = putStrLn(s) *> getStrLn\n}\n\ndef RealInterpretersZIO = {\n  SyncInterpreters[RIO[Console, ?]] overriddenBy new ModuleDef {\n    make[Interaction[RIO[Console, ?]]].from(RealInteractionZIO)\n  }\n}\n\ndef chooseInterpreters(isDummy: Boolean) = {\n  val interpreters = if (isDummy) SyncInterpreters[RIO[Console, ?]]\n                     else         RealInterpretersZIO\n  def module = ProgramModule[RIO[Console, ?]] ++ interpreters\n\n  Injector[RIO[Console, ?]]()\n    .produceGet[TaglessProgram[RIO[Console, ?]]](module, Activation.empty)\n}\n\n// execute\n\nchooseInterpreters(true)\n// res51: izumi.distage.model.definition.Lifecycle[zio.ZIO[zio.Has[Console.Service], Throwable, β$8$], TaglessProgram[zio.ZIO[zio.Has[Console.Service], Throwable, β$9$]]] = izumi.distage.model.definition.Lifecycle$$anon$9@31575907","title":"Effect-type polymorphism"},{"location":"/distage/basics.html#kind-polymorphism","text":"Modules can be polymorphic over arbitrary kinds - use TagKK to abstract over bifunctors:\nclass BifunctorIOModule[F[_, _]: TagKK] extends ModuleDef\nOr use Tag.auto.T to abstract over any kind:\nclass MonadTransModule[F[_[_], _]: Tag.auto.T] extends ModuleDef\nclass TrifunctorModule[F[_, _, _]: Tag.auto.T] extends ModuleDef\nclass EldritchModule[F[+_, -_[_, _], _[_[_, _], _], _]: Tag.auto.T] extends ModuleDef\nconsult izumi.reflect.HKTag docs for more details.","title":"Kind polymorphism"},{"location":"/distage/basics.html#cats-zio-integration","text":"Cats & ZIO instances and syntax are available automatically in distage-core, without wildcard imports, if your project depends on cats-core, cats-effect or zio. However, distage won’t bring in cats or zio as dependencies if you don’t already depend on them. (see No More Orphans blog post for details on how that works)\nCats Resource & ZIO ZManaged Bindings also work out of the box without any magic imports.\nAll relevant typeclass instances for chosen effect type, such as ConcurrentEffect[F], are included by default (overridable by user bindings)\nExample:\nimport cats.syntax.semigroup._\nimport cats.effect.{ExitCode, IO, IOApp}\nimport distage.{DIKey, Roots, Injector}\n\ntrait AppEntrypoint {\n  def run: IO[Unit]\n}\n\nobject Main extends IOApp {\n  override def run(args: List[String]): IO[ExitCode] = {\n\n    // `distage.Module` has a Monoid instance\n\n    val myModules = ProgramModule[IO] |+| SyncInterpreters[IO]\n\n    val plan = Injector().plan(myModules, Roots.target[AppEntrypoint])\n\n    for {\n      // resolveImportsF can effectfully add missing instances to an existing plan\n      // (You can also create instances effectfully inside `ModuleDef` via `make[_].fromEffect` bindings)\n\n      newPlan <- plan.resolveImportsF[IO] {\n        case i if i.target == DIKey[DBConnection] =>\n           DBConnection.create[IO]\n      }\n\n      // Effects used in Resource and Effect Bindings\n      // should match the effect `F[_]` in `Injector[F]()`\n\n      _ <- Injector[IO]().produce(newPlan).use {\n        classes =>\n          classes.get[AppEntrypoint].run\n      }\n    } yield ExitCode.Success\n  }\n}","title":"Cats & ZIO Integration"},{"location":"/distage/debugging.html","text":"","title":"Debugging"},{"location":"/distage/debugging.html#debugging","text":"Testing Plans Pretty-printing plans Graphviz rendering","title":"Debugging"},{"location":"/distage/debugging.html#testing-plans","text":"Use OrderedPlan#assertValid method to test whether the plan will execute correctly when passed to Injector#produce.\nimport distage.{DIKey, Roots, ModuleDef, Injector}\n\nclass A(b: B)\nclass B\n\ndef badModule = new ModuleDef {\n  make[A]\n  make[B].fromEffect(zio.Task { ??? })\n}\n\nval badPlan = Injector[cats.effect.IO]().plan(badModule, Roots.target[A])\n// badPlan: izumi.distage.model.plan.OrderedPlan = \n// {effect.{type.MdocSession::App0::B}} (debugging.md:22) := value zio.ZIO$EffectPartial#2125397128\n// {type.MdocSession::App0::B} (debugging.md:22) := effect[λ %0 → zio.ZIO[-Any,+Throwable,+0]]{effect.{type.MdocSession::App0::B}}\n// {type.MdocSession::App0::A} (debugging.md:21) := call(π:Class(MdocSession::App0::B): MdocSession::App0::A) {\n//   arg b: MdocSession::App0::B = lookup({type.MdocSession::App0::B})\n// }\n// the effect types are mismatched - `badModule` uses `zio.Task`, but we expect `cats.effect.IO`\n\nbadPlan.assertValid[cats.effect.IO]().unsafeRunSync()\n// izumi.distage.model.exceptions.InvalidPlanException: \n// - Incompatible effect types when trying to execute operation:\n// \n//   - {type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B} (debugging.md:22) := effect[λ %0 → zio.ZIO[-Any,+Throwable,+0]]{effect.{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B}/zio.ZIO[-Any,+Throwable,+Nothing]}\n// \n// Can't execute an effect in `λ %0 → zio.ZIO[-Any,+Throwable,+0]` which is neither equivalent to `izumi.fundamentals.platform.Identity`, nor a subtype of the Injector's effect type: `λ %0 → cats.effect.IO[+0]`\n// \n//   - To execute `make[_].fromEffect` and `make[_].fromResource` bindings for effects other than `Identity`, you must parameterize the `Injector` with the corresponding effect type when creating it, as in `Injector[F]()`.\n//   - Subtype type constructors are allowed. e.g. when using ZIO you can execute effects in `IO[Nothing, ?]` when using an `Injector[IO[Throwable, ?]]()`.\n//        \n// \tat izumi.distage.model.plan.impl.OrderedPlanOps.$anonfun$isValid$3(OrderedPlanOps.scala:57)\n// \tat izumi.distage.model.plan.impl.OrderedPlanOps.$anonfun$isValid$3$adapted(OrderedPlanOps.scala:56)\n// \tat scala.Option.map(Option.scala:242)\n// \tat izumi.distage.model.plan.impl.OrderedPlanOps.assertValid(OrderedPlanOps.scala:56)\n// \tat izumi.distage.model.plan.impl.OrderedPlanOps.assertValid$(OrderedPlanOps.scala:37)\n// \tat repl.MdocSession$App0$$anonfun$4.apply$mcV$sp(debugging.md:33)\n// \tat repl.MdocSession$App0$$anonfun$4.apply(debugging.md:33)\n// \tat repl.MdocSession$App0$$anonfun$4.apply(debugging.md:33)\ndef goodModule = new ModuleDef {\n  make[A]\n  make[B].fromEffect(cats.effect.IO(new B))\n}\n\nval plan = Injector[cats.effect.IO]().plan(goodModule, Roots.target[A])\n// plan: izumi.distage.model.plan.OrderedPlan = \n// {effect.{type.MdocSession::App0::B}} (debugging.md:42) := value cats.effect.IO$Delay#525807713\n// {type.MdocSession::App0::B} (debugging.md:42) := effect[λ %0 → cats.effect.IO[+0]]{effect.{type.MdocSession::App0::B}}\n// {type.MdocSession::App0::A} (debugging.md:41) := call(π:Class(MdocSession::App0::B): MdocSession::App0::A) {\n//   arg b: MdocSession::App0::B = lookup({type.MdocSession::App0::B})\n// }\n// the effect types in `goodModule` and here match now\n\nplan.assertValid[cats.effect.IO]().unsafeRunSync()","title":"Testing Plans"},{"location":"/distage/debugging.html#pretty-printing-plans","text":"You can print the output of plan.render() to get detailed info on what will happen during instantiation. The printout includes source and line numbers so your IDE can show you where the binding was defined!\nprintln(plan.render())\n// {effect.{type.MdocSession::App0::B}} (debugging.md:42) := value cats.effect.IO$Delay#525807713\n// {type.MdocSession::App0::B} (debugging.md:42) := effect[λ %0 → cats.effect.IO[+0]]{effect.{type.MdocSession::App0::B}}\n// {type.MdocSession::App0::A} (debugging.md:41) := call(π:Class(MdocSession::App0::B): MdocSession::App0::A) {\n//   arg b: MdocSession::App0::B = lookup({type.MdocSession::App0::B})\n// }\nYou can also query a plan to see the dependencies and reverse dependencies of a specific class and their order of instantiation:\n// Print dependencies\nprintln(plan.topology.dependencies.tree(DIKey[A]))\n// DepNode({type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A},DependencyGraph(Map({effect.{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B}/cats.effect.IO[+MdocSession::App0::B]} -> Set(), {type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B} -> Set({effect.{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B}/cats.effect.IO[+MdocSession::App0::B]}), {type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A} -> Set({type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B})),Depends),0,None,Set())\n\n// Print reverse dependencies\nprintln(plan.topology.dependees.tree(DIKey[B]))\n// DepNode({type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B},DependencyGraph(Map({effect.{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B}/cats.effect.IO[+MdocSession::App0::B]} -> Set({type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B}), {type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.B} -> Set({type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A}), {type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.A} -> Set()),Required),0,None,Set())\nThe printer highlights circular dependencies:\nTo debug macros used by distage you may use the following Java Properties:\n# izumi-reflect macros\n-Dizumi.debug.macro.rtti=true\n\n# izumi.distage.constructors.* macros\n-Dizumi.debug.macro.distage.constructors=true\n\n# Functoid macro\n-Dizumi.debug.macro.distage.functoid=true","title":"Pretty-printing plans"},{"location":"/distage/debugging.html#graphviz-rendering","text":"Add GraphDumpBootstrapModule to your Injector’s configuration to enable writing GraphViz files with a graphical representation of the OrderedPlan. Data will be saved to ./target/plan-last-full.gv and ./target/plan-last-nogc.gv in the current working directory.\nimport distage.{GraphDumpBootstrapModule, Injector}\n\nInjector(GraphDumpBootstrapModule)\n// res6: Injector[izumi.fundamentals.platform.functional.package.Identity[A]] = izumi.distage.InjectorDefaultImpl@58286a17\nYou’ll need a GraphViz installation to render these files into a viewable PNG images:\ndot -Tpng target/plan-last-nogc.gv -o out.png","title":"Graphviz rendering"},{"location":"/distage/advanced-features.html","text":"","title":"Advanced Features"},{"location":"/distage/advanced-features.html#advanced-features","text":"Dependency Pruning Circular Dependencies Support Automatic Resolution with generated proxies Manual Resolution with by-name parameters Weak Sets Auto-Sets Depending on Locator Injector inheritance Bootloader Inner Classes and Path-Dependent Types","title":"Advanced Features"},{"location":"/distage/advanced-features.html#dependency-pruning","text":"distage performs pruning of all unused bindings by default. When you configure a set of “root” keys - either explicitly by passing Roots or implicitly by using Injector#produceRun or Injector#produceGet methods, distage will remove all bindings that aren’t required to create the supplied roots – these bindings will be thrown out and not even considered, much less executed.\nPruning serves two important purposes:\nIt enables faster tests by omitting unused instantiations and allocations of potentially heavy resources, It enables multiple independent applications, aka “Roles” to be hosted within a single binary.\nExample:\nimport distage.{Roots, ModuleDef, Injector}\n\nclass A(b: B) {\n  println(\"A!\")\n}\nclass B() {\n  println(\"B!\")\n}\nclass C() {\n  println(\"C!\")\n}\n\ndef module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n\n// create an object graph from description in `module`\n// with `A` as the GC root\n\nval objects = Injector().produce(module, Roots.target[A]).unsafeGet()\n// B!\n// A!\n// objects: izumi.fundamentals.platform.functional.package.Identity[izumi.distage.model.Locator] = izumi.distage.LocatorDefaultImpl@25036f26\n\n// A and B are in the object graph\n\nobjects.find[A]\n// res1: Option[A] = Some(repl.MdocSession$App0$A@2a56b06a)\n\nobjects.find[B]\n// res2: Option[B] = Some(repl.MdocSession$App0$B@14128059)\n\n// C is missing\n\nobjects.find[C]\n// res3: Option[C] = None\nClass C was removed because neither B nor A depended on it. It’s neither present in the Locator nor the \"C!\" message from it’s constructor was ever printed.\nIf you add c: C parameter to class B , like class B(c: C) - then C will be instantiated, because A - the “root”, will now depend on B, and B will depend on C.\nclass B(c: C) {\n  println(\"B!\")\n}\n\nval objects = Injector().produce(module, Roots.target[A]).unsafeGet()\n// C!\n// B!\n// A!\n// objects: izumi.fundamentals.platform.functional.package.Identity[Locator] = izumi.distage.LocatorDefaultImpl@1eaa6bbb\n\nobjects.find[C]\n// res5: Option[C] = Some(repl.MdocSession$App4$C@402dda3c)","title":"Dependency Pruning"},{"location":"/distage/advanced-features.html#circular-dependencies-support","text":"distage automatically resolves arbitrary circular dependencies, including self-references:\nimport distage.{DIKey, Roots, ModuleDef, Injector}\n\nclass A(val b: B)\nclass B(val a: A)\nclass C(val c: C)\n\ndef module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n\nval objects = Injector().produce(module, Roots(DIKey[A], DIKey[C])).unsafeGet()\n// objects: izumi.fundamentals.platform.functional.package.Identity[izumi.distage.model.Locator] = izumi.distage.LocatorDefaultImpl@5fe7e7b3\n\nobjects.get[A] eq objects.get[B].a\n// res7: Boolean = true\n\nobjects.get[B] eq objects.get[A].b\n// res8: Boolean = true\n\nobjects.get[C] eq objects.get[C].c\n// res9: Boolean = true","title":"Circular Dependencies Support"},{"location":"/distage/advanced-features.html#automatic-resolution-with-generated-proxies","text":"The above strategy depends on distage-core-proxy-cglib module and is enabled by default.\nIf you want to disable it, use NoProxies bootstrap configuration:\nInjector.NoProxies()\n// res10: Injector[izumi.fundamentals.platform.functional.package.Identity] = izumi.distage.InjectorDefaultImpl@5ff7b45e\nProxies are not supported on Scala.js.","title":"Automatic Resolution with generated proxies"},{"location":"/distage/advanced-features.html#manual-resolution-with-by-name-parameters","text":"Most cycles can be resolved without proxies, using By-Name parameters:\nimport distage.{DIKey, Roots, ModuleDef, Injector}\n\nclass A(b0: => B) {\n  def b: B = b0\n}\n\nclass B(a0: => A) {\n  def a: A = a0\n}\n\nclass C(self: => C) {\n  def c: C = self\n}\n\ndef module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n\n// disable proxies and execute the module\n\nval locator = Injector.NoProxies()\n  .produce(module, Roots(DIKey[A], DIKey[C]))\n  .unsafeGet()\n// locator: izumi.fundamentals.platform.functional.package.Identity[izumi.distage.model.Locator] = izumi.distage.LocatorDefaultImpl@12cdfba8\n\nlocator.get[A].b eq locator.get[B]\n// res12: Boolean = true\n\nlocator.get[B].a eq locator.get[A]\n// res13: Boolean = true\n\nlocator.get[C].c eq locator.get[C]\n// res14: Boolean = true\nThe proxy generation via cglib is enabled by default, because in scenarios with extreme late-binding cycles can emerge unexpectedly, out of control of the origin module.\nNote: Currently a limitation applies to by-names - ALL dependencies of a class engaged in a by-name circular dependency must be by-name, otherwise distage will revert to generating proxies.","title":"Manual Resolution with by-name parameters"},{"location":"/distage/advanced-features.html#weak-sets","text":"Set bindings can contain weak references. References designated as weak will be retained only if there are other dependencies on the referred bindings, NOT if there’s a dependency only on the entire Set.\nExample:\nimport distage.{Roots, ModuleDef, Injector}\n\nsealed trait Elem\n\nfinal case class Strong() extends Elem {\n  println(\"Strong constructed\")\n}\n\nfinal case class Weak() extends Elem {\n  println(\"Weak constructed\")\n}\n\ndef module = new ModuleDef {\n  make[Strong]\n  make[Weak]\n\n  many[Elem]\n    .ref[Strong]\n    .weak[Weak]\n}\n\n// Designate Set[Elem] as the garbage collection root,\n// everything that Set[Elem] does not strongly depend on will be garbage collected\n// and will not be constructed.\n\nval roots = Roots.target[Set[Elem]]\n// roots: Roots = Of(NonEmptySet({type.scala.collection.immutable.Set[=MdocSession::App15::Elem]}))\n\nval objects = Injector().produce(module, roots).unsafeGet()\n// Strong constructed\n// objects: izumi.fundamentals.platform.functional.package.Identity[izumi.distage.model.Locator] = izumi.distage.LocatorDefaultImpl@36541e50\n\n// Strong is around\n\nobjects.find[Strong]\n// res16: Option[Strong] = Some(Strong())\n\n// Weak is not\n\nobjects.find[Strong]\n// res17: Option[Strong] = Some(Strong())\n\n// There's only Strong in the Set\n\nobjects.get[Set[Elem]]\n// res18: Set[Elem] = Set(Strong())\nThe Weak class was not required by any dependency of Set[Elem], so it was pruned. The Strong class remained, because the reference to it was strong, so it was counted as a dependency of Set[Elem].\nIf we change Strong to depend on the Weak, then Weak will be retained:\nfinal class Strong(weak: Weak) extends Elem {\n  println(\"Strong constructed\")\n}\n\nval objects = Injector().produce(module, roots).unsafeGet()\n// Weak constructed\n// Strong constructed\n// objects: izumi.fundamentals.platform.functional.package.Identity[izumi.distage.model.Locator] = izumi.distage.LocatorDefaultImpl@56d805bd\n\n// Weak is around\n\nobjects.find[Weak]\n// res20: Option[Weak] = Some(repl.MdocSession$App19$Weak@2f68d863)\n\n// both Strong and Weak are in the Set\n\nobjects.get[Set[Elem]]\n// res21: Set[Elem] = Set(repl.MdocSession$App19$Weak@2f68d863, repl.MdocSession$App19$Strong@620691c3)","title":"Weak Sets"},{"location":"/distage/advanced-features.html#auto-sets","text":"AutoSet Planner Hooks can traverse the plan and collect all future objects that match a predicate.\nUsing Auto-Sets you can e.g. collect all AutoCloseable classes and .close() them after the application has finished work. NOTE: please use Resource bindings for real lifecycle, this is just an example.\nimport distage.{BootstrapModuleDef, ModuleDef, Injector}\nimport izumi.distage.model.planning.PlanningHook\nimport izumi.distage.planning.AutoSetHook\n\nclass PrintResource(name: String) {\n  def start(): Unit = println(s\"$name started\")\n  def stop(): Unit = println(s\"$name stopped\")\n}\n\nclass A extends PrintResource(\"A\")\nclass B(val a: A) extends PrintResource(\"B\")\nclass C(val b: B) extends PrintResource(\"C\")\n\ndef bootstrapModule = new BootstrapModuleDef {\n  many[PlanningHook]\n    .add(new AutoSetHook[PrintResource, PrintResource])\n}\n\ndef appModule = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n\nval resources = Injector(bootstrapModule)\n  .produceGet[Set[PrintResource]](appModule)\n  .use(set => set)\n// resources: izumi.fundamentals.platform.functional.package.Identity[Set[PrintResource]] = Set()\n\nresources.foreach(_.start())\nresources.toSeq.reverse.foreach(_.stop())\nCalling .foreach on an auto-set is safe; the actions will be executed in order of dependencies - Auto-Sets preserve ordering, unlike user-defined Sets\ne.g. If C depends on B depends on A, autoset order is: A, B, C, to start call: A, B, C, to close call: C, B, A. When using an auto-set for finalization, you must .reverse the autoset.\nNote: Auto-Sets are assembled after Garbage Collection, they are assembled after garbage collection is done, as such they can’t contain garbage by construction. Because of that they also cannot be used as GC Roots.\nFurther reading:\nMacWire calls the same concept “Multi Wiring”","title":"Auto-Sets"},{"location":"/distage/advanced-features.html#depending-on-locator","text":"Objects can depend on the outer object graph that contains them (Locator), by including a LocatorRef parameter:\nimport distage.{DIKey, ModuleDef, LocatorRef, Injector, Roots}\n\nclass A(\n  objects: LocatorRef\n) {\n  def c = objects.get.get[C]\n}\nclass B\nclass C\n\ndef module = new ModuleDef {\n  make[A]\n  make[B]\n  make[C]\n}\n\nval objects = Injector().produce(module, Roots(DIKey[A], DIKey[B], DIKey[C])).unsafeGet()\n// objects: izumi.fundamentals.platform.functional.package.Identity[izumi.distage.model.Locator] = izumi.distage.LocatorDefaultImpl@10e56ff6\n\n// A took C from the object graph\n\nobjects.get[A].c\n// res26: C = repl.MdocSession$App25$C@3db54470\n\n// this C is the same C as in this `objects` value\n\nval thisC = objects.get[C]\n// thisC: C = repl.MdocSession$App25$C@3db54470\n\nval thatC = objects.get[A].c\n// thatC: C = repl.MdocSession$App25$C@3db54470\n\nassert(thisC == thatC)\nLocator contains metadata about the plan and the bindings from which it was ultimately created:\nimport distage.{OrderedPlan, ModuleBase}\n\n// Plan that created this locator (after GC)\n\nval plan: OrderedPlan = objects.plan\n// plan: OrderedPlan = \n// {type.LocatorRef} (advanced-features.md:347) := import {type.izumi.distage.model.recursive.LocatorRef} // required for {type.MdocSession::App25::A}\n// {type.MdocSession::App25::C} (advanced-features.md:349) := call(π:Class(): MdocSession::App25::C) {}\n// {type.MdocSession::App25::B} (advanced-features.md:348) := call(π:Class(): MdocSession::App25::B) {}\n// {type.MdocSession::App25::A} (advanced-features.md:347) := call(π:Class(LocatorRef): MdocSession::App25::A) {\n//   arg objects: LocatorRef = lookup({type.LocatorRef})\n// }\n\n// Bindings from which the Plan was built (after GC)\n\nval bindings: ModuleBase = plan.definition\n// bindings: ModuleBase = \n// make[{type.repl.MdocSession::repl.MdocSession.App25::repl.MdocSession.App25.C}].from(call(π:Class(): repl.MdocSession::repl.MdocSession.App25::repl.MdocSession.App25.C)) ((advanced-features.md:349))\n// make[{type.repl.MdocSession::repl.MdocSession.App25::repl.MdocSession.App25.B}].from(call(π:Class(): repl.MdocSession::repl.MdocSession.App25::repl.MdocSession.App25.B)) ((advanced-features.md:348))\n// make[{type.repl.MdocSession::repl.MdocSession.App25::repl.MdocSession.App25.A}].from(call(π:Class(izumi.distage.model.recursive.LocatorRef): repl.MdocSession::repl.MdocSession.App25::repl.MdocSession.App25.A)) ((advanced-features.md:347))","title":"Depending on Locator"},{"location":"/distage/advanced-features.html#injector-inheritance","text":"You may run a new planning cycle, inheriting the instances from an existing Locator into your new object subgraph:\nval childInjector = Injector.inherit(objects)\n// childInjector: Injector[izumi.fundamentals.platform.functional.package.Identity[A]] = izumi.distage.InjectorDefaultImpl@2745c342\n\nclass Printer(a: A, b: B, c: C) {\n  def printEm() =\n    println(s\"I've got A=$a, B=$b, C=$c, all here!\")\n}\n\nchildInjector.produceRun(new ModuleDef { make[Printer] }) {\n  (_: Printer).printEm()\n}\n// I've got A=repl.MdocSession$App25$A@63f17e7a, B=repl.MdocSession$App25$B@72ed20c1, C=repl.MdocSession$App25$C@3db54470, all here!\n// res28: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()","title":"Injector inheritance"},{"location":"/distage/advanced-features.html#bootloader","text":"The plan and bindings in Locator are saved in the state they were AFTER Garbage Collection has been performed. Objects can request the original input via a PlannerInput parameter:\nimport distage.{Roots, ModuleDef, PlannerInput, Injector, Activation}\n\nclass InjectionInfo(val plannerInput: PlannerInput)\n\ndef module = new ModuleDef {\n  make[InjectionInfo]\n}\n\nval input = PlannerInput(module, Activation.empty, Roots.target[InjectionInfo])\n// input: PlannerInput = PlannerInput(\n// make[{type.repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.InjectionInfo}].from(call(π:Class(izumi.distage.model.PlannerInput): repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.InjectionInfo)) ((advanced-features.md:410)),Activation(Map()),Of(NonEmptySet({type.repl.MdocSession::repl.MdocSession.App29::repl.MdocSession.App29.InjectionInfo})))\n\nval injectionInfo = Injector().produce(input).unsafeGet().get[InjectionInfo]\n// injectionInfo: InjectionInfo = repl.MdocSession$App29$InjectionInfo@100505ca\n\n// the PlannerInput in `InjectionInfo` is the same as `input`\n\nassert(injectionInfo.plannerInput == input)\nBootloader is another summonable parameter that contains the above information in aggregate and lets you create another object graph from the same inputs as the current or with alterations.","title":"Bootloader"},{"location":"/distage/advanced-features.html#inner-classes-and-path-dependent-types","text":"Path-dependent types with a value prefix will be instantiated normally:\nimport distage.{Roots, ModuleDef, Injector}\n\nclass Path {\n  class A\n}\nval path = new Path\n// path: Path = repl.MdocSession$App31$Path@41d8f79c\n\ndef module = new ModuleDef {\n  make[path.A]\n}\n\nInjector()\n  .produce(module, Roots.Everything)\n  .use(_.get[path.A])\n// res32: izumi.fundamentals.platform.functional.package.Identity[path.A] = repl.MdocSession$App31$Path$A@776b6204\nSince version 0.10, support for types with a non-value prefix (type projections) has been dropped.\nHowever, there’s a gotcha with value prefixes, when seen by distage they’re based on the literal variable name of the prefix, not the full type information available to the compiler, therefore the following usage, a simple rename, will fail:\ndef pathModule(p: Path) = new ModuleDef {\n  make[p.A]\n}\n\nval path1 = new Path\n// path1: Path = repl.MdocSession$App31$Path@7e3de078\nval path2 = new Path\n// path2: Path = repl.MdocSession$App31$Path@46ae9120\nTry {\n  Injector().produceRun(pathModule(path1) ++ pathModule(path2)) {\n    (p1a: path1.A, p2a: path2.A) =>\n      println((p1a, p2a))\n  }\n}.isFailure\n// res33: Boolean = true\nThis will fail because while path1.A and p.A inside new ModuleDef are the same type as far as Scala is concerned, the variables path1 & p are spelled differently and this causes a mismatch in distage.\nThere’s one way to workaround this - turn the type member A into a type parameter using the Aux Pattern, and then for that type parameter in turn, summon the type information using Tag implicit (as described in Tagless Final Style chapter) and summon the constructor using the ClassConstructor implicit, example:\nimport distage.{ClassConstructor, ModuleDef, Injector, Tag}\n\nobject Path {\n  type Aux[A0] = Path { type A = A0 }\n}\n\ndef pathModule[A: Tag: ClassConstructor](p: Path.Aux[A]) = new ModuleDef {\n  make[A]\n}\n\nval path1 = new Path\n// path1: Path = repl.MdocSession$App34$Path@404cfa7e\nval path2 = new Path\n// path2: Path = repl.MdocSession$App34$Path@6c1bcb31\n\nInjector().produceRun(pathModule(path1) ++ pathModule(path2)) {\n  (p1a: path1.A, p2a: path2.A) =>\n    println((p1a, p2a))\n}\n// (repl.MdocSession$App34$Path$A@513b6716,repl.MdocSession$App34$Path$A@13ce479a)\n// res35: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\nNow the example works, because the A type inside pathModule(path1) is path1.A and for pathModule(path2) it’s path2.A, which matches their subsequent spelling in (p1a: path1.A, p2a: path2.A) => in produceRun","title":"Inner Classes and Path-Dependent Types"},{"location":"/distage/distage-framework.html","text":"","title":"distage-framework"},{"location":"/distage/distage-framework.html#distage-framework","text":"Roles Compile-time checks Checking default config Using with distage-teskit Checking distage-core apps Low-Level APIs Scala 2.12 Typesafe Config Plugins Compile-time scanning","title":"distage-framework"},{"location":"/distage/distage-framework.html#roles","text":"Many software suites have more than one entrypoint. For example Scalac provides a REPL and a Compiler. A typical distributed application may provide both server and client code, as well as a host of utility applications for maintenance.\nIn distage such entrypoints are called “roles”. Role-based applications may contain roles of different types:\nRoleService[F], for persistent services and daemons RoleTask[F], for one-off tasks and applications\nTo use roles, add distage-framework library:\nsbt libraryDependencies += \"io.7mind.izumi\" %% \"distage-framework\" % \"1.0.2\"\nTo declare roles use RoleModuleDef#makeRole:\nimport distage.plugins.PluginDef\nimport izumi.distage.roles.model.definition.RoleModuleDef\nimport izumi.distage.roles.model.RoleDescriptor\nimport izumi.distage.roles.model.RoleTask\nimport izumi.fundamentals.platform.cli.model.raw.RawEntrypointParams\nimport logstage.LogIO\nimport zio.UIO\n\nobject AppPlugin extends PluginDef {\n  include(roleModule)\n\n  def roleModule = new RoleModuleDef {\n    makeRole[ExampleRoleTask]\n  }\n}\n\nclass ExampleRoleTask(log: LogIO[UIO]) extends RoleTask[UIO] {\n  override def start(roleParameters: RawEntrypointParams, freeArgs: Vector[String]): UIO[Unit] = {\n    log.info(s\"Running ${ExampleRoleTask.id}!\")\n  }\n}\n\nobject ExampleRoleTask extends RoleDescriptor {\n  override def id = \"exampletask\"\n}\nCreate a Role Launcher, RoleAppMain, with the example role:\nimport distage.plugins.PluginConfig\nimport izumi.distage.roles.RoleAppMain\nimport zio.IO\n\nobject ExampleLauncher extends RoleAppMain.LauncherBIO2[IO] {\n  override def pluginConfig = {\n    PluginConfig.const(\n      // add the plugin with ExampleRoleTask\n      AppPlugin\n    )\n  }\n}\nYou can now specify roles to launch on the command-line:\n./launcher :exampletask\nExampleLauncher.main(Array(\":exampletask\"))\nI 2020-12-14T10:00:16.172           (RoleAppPlanner.scala:70)  …oleAppPlanner.Impl.makePlan [ 944:run-main-1          ] phase=late Planning finished. main ops=7, integration ops=0, shared ops=0, runtime ops=17\nI 2020-12-14T10:00:16.253        (RoleAppEntrypoint.scala:99)  …AppEntrypoint.Impl.runTasks [ 944:run-main-1          ] phase=late Going to run: tasks=1\nI 2020-12-14T10:00:16.259       (RoleAppEntrypoint.scala:104)  …R.I.runTasks.101.loggedTask [ 944:run-main-1          ] phase=late Task is about to start: task=repl.MdocSession$App0$ExampleRoleTask@76b7592c\nI 2020-12-14T10:00:16.263           (distage-framework.md:43)  ….App0.ExampleRoleTask.start [ 944:run-main-1          ] Running id=exampletask!\nI 2020-12-14T10:00:16.267       (RoleAppEntrypoint.scala:106)  ….R.I.r.1.loggedTask.104.105 [ 944:run-main-1          ] phase=late Task finished: task=repl.MdocSession$App0$ExampleRoleTask@76b7592c\nOnly the components required by the specified roles will be created, everything else will be pruned. (see: Dependency Pruning)\nBundledRolesModule contains two example roles:\nHelp - prints help message when launched ./launcher :help ConfigWriter - writes reference config into files, split by roles (includes only parts of the config used by the application)\nUse include to add it to your application:\nimport distage.plugins.PluginDef\nimport izumi.distage.roles.bundled.BundledRolesModule\nimport zio.Task\n\nobject RolesPlugin extends PluginDef {\n  include(BundledRolesModule[Task](version = \"1.0\"))\n}\nFurther reading:\ndistage-example - Example web service using roles Roles: a viable alternative to Microservices and Monoliths","title":"Roles"},{"location":"/distage/distage-framework.html#compile-time-checks","text":"To use compile-time checks, add distage-framework library:\nsbt libraryDependencies += \"io.7mind.izumi\" %% \"distage-framework\" % \"1.0.2\"\nThe easiest way to add full compile-time safety to your application is to add an object inheriting PlanCheck.Main in __ test scope__ of the same module where you define your Role Launcher\nimport izumi.distage.framework.PlanCheck\nimport com.example.myapp.MainLauncher\n\nobject WiringCheck extends PlanCheck.Main(MainLauncher)\nThis object will emit compile-time errors for any issues or omissions in your ModuleDefs. It will recompile itself as necessary to provide feedback during development.\nBy default, all possible roles and activations are checked efficiently.\nYou may exclude specific roles or activations from the check by passing a PlanCheckConfig case class to PlanCheck API. Most options in PlanCheckConfig can also be set using system properties, see DebugProperties.","title":"Compile-time checks"},{"location":"/distage/distage-framework.html#checking-default-config","text":"By default PlanCheck will check parsing of config bindings (from distage-extension-config) using configs loaded with the same settings as the role launcher.\nThis allows you to ensure correctness of default configs during development without writing tests.\nIf you need to disable this check, set checkConfig option of PlanCheckConfig to false.","title":"Checking default config"},{"location":"/distage/distage-framework.html#using-with-distage-teskit","text":"Use SpecWiring to spawn a test-suite that also triggers compile-time checks.\nSpecWiring will check the passed application when compiled, then perform the check again at runtime when ran as a test.\nimport izumi.distage.framework.PlanCheckConfig\nimport izumi.distage.testkit.scalatest.SpecWiring\nimport com.example.myapp.MainLauncher\n\nobject WiringCheck extends SpecWiring(\n  app = MainLauncher,\n  cfg = PlanCheckConfig(checkConfig = false),\n  checkAgainAtRuntime = false, // disable the runtime re-check\n)","title":"Using with distage-teskit"},{"location":"/distage/distage-framework.html#checking-distage-core-apps","text":"distage-framework’s Role-based applications are checkable out of the box, but applications assembled directly via distage-core’s distage.Injector APIs must implement the CheckableApp trait to provide all the data necessary for the checks. You may use CoreCheckableAppSimple implementation for applications definable by a single collection of modules.","title":"Checking distage-core apps"},{"location":"/distage/distage-framework.html#low-level-apis","text":"PlanCheckMaterializer, ForcedRecompilationToken and PlanCheck.runtime provide the low-level APIs behind distage compile-time checks, they can be used to wrap the capability in other APIs or implement similar functionality.\nPlanVerifier hosts the multi-graph traversal doing the actual checking and can be invoked at runtime or in macro. It can also be invoked using Injector#assert and Injector#verify methods.","title":"Low-Level APIs"},{"location":"/distage/distage-framework.html#scala-2-12","text":"If you’re using Scala 2.12 and get compilation errors such as\n[error]  type mismatch;\n[error]  found   : String(\"mode:test\")\n[error]  required: izumi.fundamentals.platform.language.literals.LiteralString{type T = String(\"mode:test\")} with izumi.fundamentals.platform.language.literals.LiteralString\nThen you’ll have to refactor your instance of PlanCheck.Main (or similar) to make sure that PlanCheckConfig is defined in a separate val. You may do this by moving it from a constructor parameter to an early initializer.\nExample:\nobject WiringTest extends PlanCheck.Main(\n  MyApp,\n  PlanCheckConfig(...)\n)\n// [error]\nFix:\nobject WiringTest extends {\n  val config = PlanCheckConfig(... )\n} with PlanCheck.Main(MyApp, config)\nNote that this issue does not exist on Scala 2.13+, it is caused by a bug in Scala 2.12’s treatment of implicits in class parameter position.","title":"Scala 2.12"},{"location":"/distage/distage-framework.html#typesafe-config","text":"distage-extension-config library allows parsing case classes and sealed traits from typesafe-config configuration files.\nTo use it, add the distage-extension-config library:\nsbt libraryDependencies += \"io.7mind.izumi\" %% \"distage-extension-config\" % \"1.0.2\"\nUse helper functions in ConfigModuleDef, makeConfig and make[_].fromConfig to parse the bound AppConfig instance into case classes, sealed traits or literals:\nimport distage.{Id, Injector}\nimport distage.config.{AppConfig, ConfigModuleDef}\nimport com.typesafe.config.ConfigFactory\n\nfinal case class Conf(\n  name: String,\n  age: Int,\n)\n\nfinal case class OtherConf(\n  other: Boolean\n)\n\nfinal class ConfigPrinter(\n  conf: Conf,\n  otherConf: OtherConf @Id(\"other\"),\n) {\n  def print() = {\n    println(s\"name: ${conf.name}, age: ${conf.age}, other: ${otherConf.other}\")\n  }\n}\n\nval module = new ConfigModuleDef {\n  make[ConfigPrinter]\n\n  // declare paths to parse\n  makeConfig[Conf](\"conf\")\n  makeConfig[OtherConf](\"conf\").named(\"other\")\n\n  // add config instance\n  make[AppConfig].from(AppConfig(\n    ConfigFactory.parseString(\n      \"\"\"conf {\n        |  name = \"John\"\n        |  age = 33\n        |  other = true\n        |}\"\"\".stripMargin\n    )\n  ))\n}\n// module: AnyRef with ConfigModuleDef = \n// make[{type.repl.MdocSession::repl.MdocSession.App4::repl.MdocSession.App4.ConfigPrinter}].from(call(π:Class(repl.MdocSession::repl.MdocSession.App4::repl.MdocSession.App4.Conf, repl.MdocSession::repl.MdocSession.App4::repl.MdocSession.App4.OtherConf): repl.MdocSession::repl.MdocSession.App4::repl.MdocSession.App4.ConfigPrinter)) ((distage-framework.md:172))\n// make[{type.repl.MdocSession::repl.MdocSession.App4::repl.MdocSession.App4.OtherConf@other}].from(call(ƒ:izumi.distage.config.codec.DIConfigReader$$Lambda$22880/1088740824@2ff01cf8(izumi.distage.config.model.AppConfig): repl.MdocSession::repl.MdocSession.App4::repl.MdocSession.App4.OtherConf)).tagged(Set(ConfTag(conf))) ((distage-framework.md:176))\n// make[{type.izumi.distage.config.model.AppConfig}].from(call(ƒ:<function0>(): izumi.distage.config.model.AppConfig)) ((distage-framework.md:179))\n// make[{type.repl.MdocSession::repl.MdocSession.App4::repl.MdocSession.App4.Conf}].from(call(ƒ:izumi.distage.config.codec.DIConfigReader$$Lambda$22880/1088740824@47901b1f(izumi.distage.config.model.AppConfig): repl.MdocSession::repl.MdocSession.App4::repl.MdocSession.App4.Conf)).tagged(Set(ConfTag(conf))) ((distage-framework.md:175))\n\nInjector().produceRun(module) {\n  configPrinter: ConfigPrinter =>\n    configPrinter.print()\n}\n// name: John, age: 33, other: true\n// res5: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()\nAutomatic derivation of config codecs is based on pureconfig-magnolia.\nWhen a given type already has custom pureconfig.ConfigReader instances in implicit scope, they will be used, otherwise they will be derived automatically.\nYou don’t have to explicitly make[AppConfig] in distage-testkit’s tests and in distage-framework’s Roles, unless you want to override default behavior.\nBy default, tests and roles will try to read the configurations from resources with the following names, in order:\n${roleName}.conf ${roleName}-reference.conf ${roleName}-reference-dev.conf application.conf application-reference.conf application-reference-dev.conf common.conf common-reference.conf common-reference-dev.conf\nWhere distage-testkit uses TestConfig#configBaseName instead of roleName.\nExplicit config files passed to the role launcher -c file.conf the command-line flag have a higher priority than resource configs.\nRole-specific configs on the command-line, passed via -c file.conf option after a :roleName argument, in turn have a higher priority than the explicit config files passed before the first :role argument.\nExample:\n./launcher -c global.conf :role1 -c role1.conf :role2 -c role2.conf\nHere configs will be loaded in the following order, with higher priority earlier and earlier configs overriding the values in later configs:\nexplicits: role1.conf, role2.conf, global.conf, resources: role1[-reference,-dev].conf, role2[-reference,-dev].conf, ,application[-reference,-dev].conf, common[-reference,-dev].conf","title":"Typesafe Config"},{"location":"/distage/distage-framework.html#plugins","text":"distage-extension-plugins module adds classpath discovery for modules that inherit a marker trait PluginBase.\nPlugins reduce friction in adding new components, a programmer needs only to define new plugins and does not also have to stop to add a new plugin to a central wiring point. Plugins also enable extreme late-binding: they allow a program to extend itself at launch time with new Plugin classes on the classpath.\nPlugins are compatible with compile-time checks as long as they’re defined in a separate module.\nTo use plugins, add the distage-extension-plugins library:\nsbt libraryDependencies += \"io.7mind.izumi\" %% \"distage-extension-plugins\" % \"1.0.2\"\nTo declare a plugin, create a top-level object extending the PluginDef trait instead of ModuleDef:\npackage com.example.petstore\n\nimport distage.Injector\nimport distage.plugins.{PluginConfig, PluginDef, PluginLoader}\n\nobject PetStorePlugin extends PluginDef {\n  make[PetRepository]\n  make[PetStoreService]\n  make[PetStoreController]\n}\nUse PluginLoader to find all the PluginDef objects in a specific package or its subpackages:\nval pluginConfig = PluginConfig.cached(\n  // packages to scan\n  packagesEnabled = Seq(\"com.example.petstore\")\n)\n// pluginConfig: PluginConfig = PluginConfig(List(com.example.petstore),List(),true,false,List(),List())\n\nval appModules = PluginLoader().load(pluginConfig)\n// appModules: izumi.distage.plugins.load.LoadedPlugins = LoadedPlugins(List(\n// make[{type.com.example.petstore.PetStoreController}].from(call(π:Class(): com.example.petstore.PetStoreController)) ((PetStorePlugin.scala:8))\n// make[{type.com.example.petstore.PetStoreService}].from(call(π:Class(): com.example.petstore.PetStoreService)) ((PetStorePlugin.scala:7))\n// make[{type.com.example.petstore.PetRepository}].from(call(π:Class(): com.example.petstore.PetRepository)) ((PetStorePlugin.scala:6))),List(),List())\nYou may then pass plugins to Injector as ordinary modules:\n// combine all plugins into one\n\nval appModule = appModules.result.merge\n// appModule: izumi.distage.plugins.PluginBase = \n// make[{type.com.example.petstore.PetRepository}].from(call(π:Class(): com.example.petstore.PetRepository)) ((PetStorePlugin.scala:6))\n// make[{type.com.example.petstore.PetStoreService}].from(call(π:Class(): com.example.petstore.PetStoreService)) ((PetStorePlugin.scala:7))\n// make[{type.com.example.petstore.PetStoreController}].from(call(π:Class(): com.example.petstore.PetStoreController)) ((PetStorePlugin.scala:8))\n\n// launch\n\nInjector()\n  .produceGet[PetStoreController](appModule)\n  .use(_.run())\n// PetStoreController: running!\n// res9: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()","title":"Plugins"},{"location":"/distage/distage-framework.html#compile-time-scanning","text":"Plugin scan can be performed at compile-time, this is mainly useful for deployment on platforms with reduced runtime reflection capabilities compared to the JVM, such as Graal Native Image, Scala.js and Scala Native. Use PluginConfig.compileTime to perform a compile-time scan.\nBe warned though, for compile-time scanning to find plugins, they must be placed in a separate module from the one in which scan is performed. When placed in the same module, scanning will fail.\nExample:\npackage com.example.petstore.another.module\n\nval pluginConfig = PluginConfig.compileTime(\"com.example.petstore\")\n// pluginConfig: PluginConfig = PluginConfig(\n//   packagesEnabled = List(),\n//   packagesDisabled = List(),\n//   cachePackages = false,\n//   debug = false,\n//   merges = List(\n//     \n// make[{type.com.example.petstore.PetStoreController}].from(call(π:Class(): com.example.petstore.PetStoreController)) ((PetStorePlugin.scala:8))\n// make[{type.com.example.petstore.PetStoreService}].from(call(π:Class(): com.example.petstore.PetStoreService)) ((PetStorePlugin.scala:7))\n// make[{type.com.example.petstore.PetRepository}].from(call(π:Class(): com.example.petstore.PetRepository)) ((PetStorePlugin.scala:6))\n//   ),\n//   overrides = List()\n// )\n\nval loadedPlugins = PluginLoader().load(pluginConfig)\n// loadedPlugins: izumi.distage.plugins.load.LoadedPlugins = LoadedPlugins(\n//   loaded = List(),\n//   merges = List(\n//     \n// make[{type.com.example.petstore.PetStoreController}].from(call(π:Class(): com.example.petstore.PetStoreController)) ((PetStorePlugin.scala:8))\n// make[{type.com.example.petstore.PetStoreService}].from(call(π:Class(): com.example.petstore.PetStoreService)) ((PetStorePlugin.scala:7))\n// make[{type.com.example.petstore.PetRepository}].from(call(π:Class(): com.example.petstore.PetRepository)) ((PetStorePlugin.scala:6))\n//   ),\n//   overrides = List()\n// )","title":"Compile-time scanning"},{"location":"/distage/distage-framework-docker.html","text":"","title":"distage-framework-docker"},{"location":"/distage/distage-framework-docker.html#distage-framework-docker","text":"Key Features Dependencies Overview 1. Create a ContainerDef 2. Declare Container Components 3. Include the DockerSupportModule Config API modifyConfig dependOnContainer Availability and Health Checks Usage in Integration Tests Docker Container Environment Docker Metadata Docker Container Networks 1. Create a ContainerNetworkDef 2. Add to Container Config Container Network Reuse Docker Client Configuration Container Reuse Matching Containers for Reuse Configuring Reuse Improving Reuse Performance Examples Tips Troubleshooting References","title":"distage-framework-docker"},{"location":"/distage/distage-framework-docker.html#key-features","text":"Provides Docker containers as resources Reasonable defaults with flexible configuration Excellent for providing Docker implementations of services for integration tests","title":"Key Features"},{"location":"/distage/distage-framework-docker.html#dependencies","text":"Add the distage-framework-docker library:\nsbt libraryDependencies += \"io.7mind.izumi\" %% \"distage-framework-docker\" % \"1.0.2\"","title":"Dependencies"},{"location":"/distage/distage-framework-docker.html#overview","text":"Usage of distage-framework-docker generally follows these steps:\nCreate ContainerDefs for the containers the application requires Create a module that declares the container component Include the DockerSupportModule in the application’s modules","title":"Overview"},{"location":"/distage/distage-framework-docker.html#1-create-a-containerdef","text":"The ContainerDef is a trait used to define a Docker container. Extend this trait and provide an implementation of the config method.\nThe required parameters for Config are:\nimage - the docker image to use ports - ports to map on the docker container\nSee Docker.ContainerConfig[Tag] for additional parameters.\nExample postgres container definition:\nimport izumi.distage.docker.{ContainerDef, Docker}\n\nobject PostgresDocker extends ContainerDef {\n  val primaryPort: Docker.DockerPort = Docker.DockerPort.TCP(5432)\n\n  override def config: Config = {\n    Config(\n      image = \"library/postgres:12.2\",\n      ports = Seq(primaryPort),\n      env = Map(\"POSTGRES_PASSWORD\" -> \"postgres\"),\n    )\n  }\n}","title":"1. Create a ContainerDef"},{"location":"/distage/distage-framework-docker.html#2-declare-container-components","text":"To use this container, a module that declares this component is required:\nUse make for binding in a ModuleDef:\nimport distage.ModuleDef\nimport izumi.reflect.TagK\n\nclass PostgresDockerModule[F[_]: TagK] extends ModuleDef {\n  make[PostgresDocker.Container].fromResource {\n    PostgresDocker.make[F]\n  }\n}\nobject PostgresDockerModule {\n  def apply[F[_]: TagK] = new PostgresDockerModule[F]\n}","title":"2. Declare Container Components"},{"location":"/distage/distage-framework-docker.html#3-include-the-dockersupportmodule","text":"Include the izumi.distage.docker.modules.DockerSupportModule module in the application modules. This module contains required component declarations and initializes the Docker.ClientConfig.\nimport cats.effect.IO\nimport com.typesafe.config.ConfigFactory\nimport distage.Injector\nimport distage.config.AppConfigModule\nimport izumi.distage.docker.modules.DockerSupportModule\nimport izumi.logstage.distage.LogIOModule\nimport logstage.LogRouter\n\nobject DistageFrameworkModules extends ModuleDef {\n  // required for docker\n  include(DockerSupportModule[IO])\n\n  // standard distage framework modules\n  include(AppConfigModule(ConfigFactory.defaultApplication()))\n  include(LogIOModule[IO](LogRouter(), true))\n}\nThe required framework modules plus PostgresDockerModule is sufficient to depend on Docker containers:\ndef minimalExample = {\n  val applicationModules = new ModuleDef {\n    include(PostgresDockerModule[IO])\n    include(DistageFrameworkModules)\n  }\n\n  Injector[IO]().produceRun(applicationModules) {\n    container: PostgresDocker.Container =>\n      val port = container.availablePorts.first(PostgresDocker.primaryPort)\n      IO(println(s\"postgres is available on port ${port}\"))\n  }\n}\n\nminimalExample.unsafeRunSync()\n// postgres is available on port AvailablePort(172.17.0.2,5432)\nIf the DockerSupportModule is not included in an application then a get of a Docker container dependent resource will fail with a izumi.distage.model.exceptions.ProvisioningException.","title":"3. Include the DockerSupportModule"},{"location":"/distage/distage-framework-docker.html#config-api","text":"The DockerProviderExtensions provides additional APIs for modiying the container definition.","title":"Config API"},{"location":"/distage/distage-framework-docker.html#modifyconfig","text":"Use modifyConfig to modify the configuration of a container. The modifier is instantiated to a Functoid, which will summon any additional dependencies.\nFor example, to change the user of the PostgreSQL container:\nclass PostgresRunAsAdminModule[F[_]: TagK] extends ModuleDef {\n  make[PostgresDocker.Container].fromResource {\n    PostgresDocker\n      .make[F]\n      .modifyConfig {\n        () => (old: PostgresDocker.Config) =>\n          old.copy(user = Some(\"admin\"))\n      }\n  }\n}\nSuppose HostPostgresData is a component provided by the application modules. This path can be added to the PostgreSQL container’s mounts by adding to the additional dependencies of the provider magnet:\nfinal case class HostPostgresData(path: String)\n\nclass PostgresWithMountsDockerModule[F[_]: TagK] extends ModuleDef {\n  make[PostgresDocker.Container].fromResource {\n    PostgresDocker.make[F].modifyConfig {\n      (hostPostgresData: HostPostgresData) =>\n        (old: PostgresDocker.Config) =>\n          val dataMount = Docker.Mount(hostPostgresData.path, \"/var/lib/postgresql/data\")\n          old.copy(mounts = old.mounts :+ dataMount)\n    }\n  }\n}","title":"modifyConfig"},{"location":"/distage/distage-framework-docker.html#dependoncontainer","text":"dependOnContainer adds a dependency on a given Docker container. distage ensures the requested container is available before the dependent.\nFor example, suppose a system under test requires both PostgreSQL and Elasticsearch. One option is to use dependOnContainer to declare the Elasticsearch container depends on the PostgreSQL container:\nobject ElasticSearchDocker extends ContainerDef {\n  val ports = Seq(9200, 9300)\n\n  override def config: Config = {\n    Config(\n      image = \"docker.elastic.co/elasticsearch/elasticsearch:7.7.0\",\n      ports = ports.map(Docker.DockerPort.TCP(_)),\n      env = Map(\"discovery.type\" -> \"single-node\")\n    )\n  }\n}\n\nclass ElasticSearchPlusPostgresModule[F[_]: TagK] extends ModuleDef {\n  make[PostgresDocker.Container].fromResource {\n    PostgresDocker.make[F]\n  }\n\n  make[ElasticSearchDocker.Container].fromResource {\n    ElasticSearchDocker.make[F].dependOnContainer(PostgresDocker)\n  }\n}\nAnother example of dependencies between containers is in the “Docker Container Networks” section later in this document.","title":"dependOnContainer"},{"location":"/distage/distage-framework-docker.html#availability-and-health-checks","text":"The healthCheck properties of Docker.ContainerConfig configure the health checks. A container resource will not be provided if the health checks did not succeed at acquire time. These are used to determine if an existing container can be used and if starting a fresh container succeeded.\nBy default, the healthCheck is a port check of the ports from the container config. There are several standard checks provided in ContainerHealthCheck that can be combined to cover many common cases.\nThe availablePorts property of the container resource are the mapped ports that passed the health check. This is a map from a Docker.DockerPort provided in the config to a host and port. For example:\nval port = container.availablePorts.first(PostgresDocker.primaryPort)\nwould be a host and port mapped to the Postgres container’s primary port that have passed the health check.","title":"Availability and Health Checks"},{"location":"/distage/distage-framework-docker.html#usage-in-integration-tests","text":"A common use case is using Docker containers to provide service implementations for integration test, such as using a PostgreSQL container for verifying an application that uses a PostgreSQL database.\nConsider the example application below. This application is written to depend on a doobie Transactor, which is constructed from a PostgresServerConfig.\nimport cats.effect.{Async, ContextShift}\nimport doobie.Transactor\nimport doobie.syntax.connectionio._\nimport doobie.syntax.string._\n\nfinal class PostgresExampleApp(\n  xa: Transactor[IO]\n) {\n  def plusOne(a: Int): IO[Int] = {\n    sql\"select ${a} + 1\".query[Int].unique.transact(xa)\n  }\n\n  val run: IO[Unit] = {\n    for {\n      v <- plusOne(1)\n      _ <- IO(println(s\"1 + 1 = ${v}.\"))\n    } yield ()\n  }\n}\n\n// the postgres configuration used to construct the Transactor\nfinal case class PostgresServerConfig(\n  host: String,\n  port: Int,\n  database: String,\n  username: String,\n  password: String,\n)\n\nobject TransactorFromConfigModule extends ModuleDef {\n  make[Transactor[IO]].from {\n    (config: PostgresServerConfig, async: Async[IO], contextShift: ContextShift[IO]) =>\n\n      Transactor.fromDriverManager[IO](\n        driver = \"org.postgresql.Driver\",\n        url    = s\"jdbc:postgresql://${config.host}:${config.port}/${config.database}\",\n        user   = config.username,\n        pass   = config.password,\n      )(async, contextShift)\n  }\n}\nNote that the above code is agnostic of environment. Provided a PostgresServerConfig, the Transactor needed by PostgresExampleApp can be constructed.\nAn integration test would use a module that provides the PostgresServerConfig from a PostgresDocker.Container:\nobject PostgresUsingDockerModule extends ModuleDef {\n  make[PostgresServerConfig].from {\n    container: PostgresDocker.Container => {\n      val knownAddress = container.availablePorts.first(PostgresDocker.primaryPort)\n      PostgresServerConfig(\n        host     = knownAddress.hostV4,\n        port     = knownAddress.port,\n        database = \"postgres\",\n        username = \"postgres\",\n        password = \"postgres\",\n      )\n    }\n  }\n\n  make[PostgresDocker.Container].fromResource {\n    PostgresDocker.make[IO]\n  }\n}\nUsing distage-testkit the test would be written like this:\nimport izumi.distage.testkit.scalatest.{AssertCIO, Spec1}\nimport distage.DIKey\n\nclass PostgresExampleAppIntegrationTest extends Spec1[IO] with AssertCIO {\n  override def config = super.config.copy(\n    moduleOverrides = new ModuleDef {\n      include(TransactorFromConfigModule)\n      include(PostgresUsingDockerModule)\n      include(DistageFrameworkModules)\n      make[PostgresExampleApp]\n    },\n    memoizationRoots = Set(\n      DIKey[PostgresServerConfig]\n    ),\n  )\n\n  \"distage docker\" should {\n\n    \"support integration tests using containers\" in {\n      app: PostgresExampleApp =>\n        for {\n          v <- app.plusOne(1)\n          _ <- assertIO(v == 2)\n        } yield ()\n    }\n\n  }\n}\nTypically, this would be run by the test runner. For completeness, the example can be run directly using:\ndef postgresDockerIntegrationExample = {\n  val applicationModules = new ModuleDef {\n    include(TransactorFromConfigModule)\n    include(PostgresUsingDockerModule)\n    include(DistageFrameworkModules)\n\n    make[PostgresExampleApp]\n  }\n\n  Injector[IO]().produceRun(applicationModules) {\n    app: PostgresExampleApp =>\n      app.run\n  }\n}\n\npostgresDockerIntegrationExample.unsafeRunSync()\n// 1 + 1 = 2.","title":"Usage in Integration Tests"},{"location":"/distage/distage-framework-docker.html#docker-container-environment","text":"The container config (Docker.ContainerConfig) defines the container environment. Of note are the environment variables, command of entrypoint, and working directory properties:\nenv: Map[String, String] - environment variables to setup in container cmd: Seq[String] - command of entrypoint cwd: Option[String] - working directory in container\nOnce defined in a ContainerDef the config may be modified by distage modules. See modifyConfig above for one mechanism.\nThe container ports will also add to the configured environment variables:\nDISTAGE_PORT_<protocol>_<originalPort> are the host ports allocated for the container","title":"Docker Container Environment"},{"location":"/distage/distage-framework-docker.html#docker-metadata","text":"The host ports allocated for the container are also added to the container metadata as labels. These labels follow the pattern distage.port.<protocol>.<originalPort>. The value is the integer port number.","title":"Docker Metadata"},{"location":"/distage/distage-framework-docker.html#docker-container-networks","text":"distage-framework-docker can automatically manage Docker networks.\nTo connect containers to the same Docker network, use a ContainerNetworkDef:\nCreate a ContainerNetworkDef. Add the network to each container’s config.\nThis will ensure the containers are all connected to the network. Assuming no reuse, distage will create the required network and add each container to that network.","title":"Docker Container Networks"},{"location":"/distage/distage-framework-docker.html#1-create-a-containernetworkdef","text":"A minimal ContainerNetworkDef uses the default configuration.\nobject TestClusterNetwork extends ContainerNetworkDef {\n  override def config: Config = Config()\n}\nBy default this object identifies the network. The associated tag type uniquely identifies this network within the application. In addition, any created network will have a label with this name in Docker.","title":"1. Create a ContainerNetworkDef"},{"location":"/distage/distage-framework-docker.html#2-add-to-container-config","text":"A container will be connected to all networks in the networks of the config. The method connectToNetwork adds a dependency on a network defined by a ContainerNetworkDef, as in this example:\nclass TestClusterNetworkModule[F[_]: TagK] extends ModuleDef {\n  make[TestClusterNetwork.Network].fromResource {\n    TestClusterNetwork.make[F]\n  }\n  make[PostgresDocker.Container].fromResource {\n    PostgresDocker.make[F].connectToNetwork(TestClusterNetwork)\n  }\n  make[ElasticSearchDocker.Container].fromResource {\n    ElasticSearchDocker.make[F].dependOnContainer(PostgresDocker).connectToNetwork(TestClusterNetwork)\n  }\n}\nThe use of connectToNetwork automatically adds a dependency on TestClusterNetwork.Network to each container.","title":"2. Add to Container Config"},{"location":"/distage/distage-framework-docker.html#container-network-reuse","text":"Container networks, like containers, are reused by default. If there is an existing network that matches a definition then that network will be used. This can be disabled by setting the reuse configuration to DockerReusePolicy.KillOnExitNoReuse:\nobject AlwaysFreshNetwork extends ContainerNetworkDef {\n  override def config: Config = Config(reuse = Docker.DockerReusePolicy.KillOnExitNoReuse)\n}\nFor an existing network to be reused, the config and object name at time of creation must be the match the current configuration value and object.","title":"Container Network Reuse"},{"location":"/distage/distage-framework-docker.html#docker-client-configuration","text":"The Docker.ClientConfig is the configuration of the Docker client used. Including the module DockerSupportModule will provide a Docker.ClientConfig.\nThere are two primary mechanisms to change the Docker.ClientConfig provided by DockerSupportModule:\nProvide a docker configuration in the application.conf:\n# include the default configuration\ninclude \"docker-reference.conf\"\n\n# override docker object fields\ndocker {\n  readTimeoutMs = 60000\n  globalReuse = \"always-kill\"\n}\nOverride the DockerSupportModule using overriddenBy:\nimport izumi.distage.docker.Docker\nimport izumi.distage.docker.Docker.DockerReusePolicy\n\nclass CustomDockerConfigExampleModule[F[_]: TagK] extends ModuleDef {\n  include(DockerSupportModule[F] overriddenBy new ModuleDef {\n    make[Docker.ClientConfig].from {\n      Docker.ClientConfig(\n        readTimeoutMs    = 10000,\n        connectTimeoutMs = 10000,\n        globalReuse      = DockerReusePolicy.ReuseEnabled,\n        useRemote        = true,\n        useRegistry      = true,\n        remote           = Some(\n          Docker.RemoteDockerConfig(\n            host      = \"tcp://localhost:2376\",\n            tlsVerify = true,\n            certPath  = \"/home/user/.docker/certs\",\n            config    = \"/home/user/.docker\",\n          )\n        ),\n        registry = Some(\n          Docker.DockerRegistryConfig(\n            url      = \"https://index.docker.io/v1/\",\n            username = \"dockeruser\",\n            password = \"ilovedocker\",\n            email    = \"dockeruser@github.com\",\n          )\n        ),\n      )\n    }\n  })\n}","title":"Docker Client Configuration"},{"location":"/distage/distage-framework-docker.html#container-reuse","text":"By default acquiring a container resource does not always start a fresh container. Likewise on releasing the resource the container will not be destroyed. When a container resource is acquired, the Docker system is inspected to determine if a matching container is already executing. If a matching container is found this container is referenced by the ContainerResource. Otherwise a fresh container is started. In both cases the acquired ContainerResource will have passed configured health checks.","title":"Container Reuse"},{"location":"/distage/distage-framework-docker.html#matching-containers-for-reuse","text":"For an existing container to be reused, all the following must be true:\nThe current client config has globalReuse == DockerReusePolicy.ReuseEnabled The container config has reuse == DockerReusePolicy.ReuseEnabled The running container was created for reuse. The running container uses the same image as the container config. All ports requested in the container config must be mapped for the running container.","title":"Matching Containers for Reuse"},{"location":"/distage/distage-framework-docker.html#configuring-reuse","text":"DockerReusePolicy has 2 possible values:\nReuseEnabled: the resource (container or network) will be always freed after use and existing matching containers will not be reused ReuseDisabled: the resource will be always be freed after use but existing matching containers will be reused\nThe ContainerDef.Config.reuse should be DockerReusePolicy.ReuseDisabled to disable reuse for a specific container. While Docker.ClientConfig.globalReuse should be DockerReusePolicy.ReuseDisabled to disable reuse throughout the application.","title":"Configuring Reuse"},{"location":"/distage/distage-framework-docker.html#improving-reuse-performance","text":"When utilizing reuse, the performance cost of inspecting the Docker system can be avoided using memoization roots. For example, in this integration test the container resource is not reconstructed for each test. Because the resource is not reconstructed there is no repeated inspection of the Docker system.\nclass NoReuseByMemoizationExampleTest extends Spec1[IO] {\n  override def config = super.config.copy(\n    moduleOverrides = new ModuleDef {\n      include(DistageFrameworkModules)\n      include(PostgresDockerModule[IO])\n    },\n    memoizationRoots = Set(\n      DIKey[PostgresDocker.Container]\n    )\n  )\n\n  \"distage docker\" should {\n    \"provide a fresh container resource\" in { c: PostgresDocker.Container =>\n      val port = c.availablePorts.first(PostgresDocker.primaryPort)\n      IO(println(s\"port ${port}\"))\n    }\n\n    \"provide the same resource\" in { c: PostgresDocker.Container =>\n      val port = c.availablePorts.first(PostgresDocker.primaryPort)\n      IO(println(s\"port ${port}\"))\n    }\n  }\n}","title":"Improving Reuse Performance"},{"location":"/distage/distage-framework-docker.html#examples","text":"The distage-example project uses distage-framework-docker to provide a PostgresDockerModule.\nThe distage-framework-docker project contains example ContainerDefs and modules for various services under izumi.distage.docker.examples namespace.","title":"Examples"},{"location":"/distage/distage-framework-docker.html#tips","text":"To kill all containers spawned by distage, use the following command:\ndocker rm -f $(docker ps -q -a -f 'label=distage.type')","title":"Tips"},{"location":"/distage/distage-framework-docker.html#troubleshooting","text":"// izumi.distage.model.exceptions.ProvisioningException: Provisioner stopped after 1 instances, 2/14 operations failed:\n//  - {type.izumi.distage.docker.DockerClientWrapper[=λ %0 → IO[+0]]} (distage-framework-docker.md:40), MissingInstanceException: Instance is not available in the object graph: {type.izumi.distage.docker.DockerClientWrapper[=λ %0 → IO[+0]]}.\nThis error means that DockerSupportModule hasn’t been included with the application modules.\nDockerClientWrapper component is provided by izumi.distage.docker.modules.DockerSupportModule.","title":"Troubleshooting"},{"location":"/distage/distage-framework-docker.html#references","text":"Introduced in release 0.9.13 An example PR showing how to use them. The distage-example PostgresDockerModule.","title":"References"},{"location":"/distage/distage-testkit.html","text":"","title":"distage-testkit"},{"location":"/distage/distage-testkit.html#distage-testkit","text":"Quick Start API Overview Spec Base Classes Test Cases Assertions Assertions with Effects Assertions with Effects with Environments Pattern: Dual Test Tactic Test Case Context Configuration Syntax Reference Execution Order Resource Reuse - Memoization Memoization Environments Memoization Levels Examples Pseudocode Forced Roots Test Selection Using IntegrationCheck References Extended Example","title":"distage-testkit"},{"location":"/distage/distage-testkit.html#quick-start","text":"distage-testkit simplifies pragmatic purely-functional program testing providing Spec* ScalaTest base classes for any existing Scala effect type with kind F[_], F[+_, +_], F[-_, +_, +_] or Identity. Specs provide an interface similar to ScalaTest’s WordSpec, however distage-testkit adds additional capabilities such as: first class support for effect types; dependency injection; and parallel execution.\nUsage of distage-testkit generally follows these steps:\nExtend a base class corresponding to the effect type: No effect type - SpecIdentity F[_] - Spec1[F], for monofunctors (cats.effect.IO , monix) F[+_, +_] - Spec2[F], for bifunctors (ZIO, monix-bio) F[-_, +_, +_] - Spec3[F] for trifunctors (ZIO) Override def config: TestConfig to customize the TestConfig Establish test case contexts using should, must, or can. Introduce test cases using one of the in methods. These test cases can have a variety of forms, from plain functions returning an assertion, to effectful functions with dependencies: No effect type / Identity - in in for F[_] in for F[+_, +_] in for F[-_, +_, +_] Test cases dependent on injectables: Functoid","title":"Quick Start"},{"location":"/distage/distage-testkit.html#api-overview","text":"The highest value tests to develop in our experience are those that verify the communication behavior of components. These are tests of blackbox interfaces, with atomic or group isolation levels.\nTo demonstrate usage of distage-testkit we’ll consider a hypothetical game score system. This system will have a model, logic, and service which we’ll then define test cases to verify. Our application will use ZIO[-R, +E, +A].\nWe’ll start with the following model and service interface for the game score system:\npackage app\n\nimport zio._\nimport zio.console.{Console, putStrLn}\n\nfinal case class Score(\n  value: Int\n)\n\nfinal case class Config(\n  starValue: Int,\n  mangoValue: Int,\n  defaultBonus: Int,\n)\n\ntrait BonusService {\n  def queryCurrentBonus: Task[Int]\n  def increaseCurrentBonus(delta: Int): Task[Int]\n}\n\nobject Score {\n  val zero = Score(0)\n\n  def addStar(config: Config, score: Score) =\n    score.copy(value = score.value + config.starValue)\n\n  def echoConfig(config: Config): RIO[Has[Console.Service], Config] =\n    for {\n      _ <- putStrLn(config.toString)\n    } yield config\n\n  def addMango(config: Config, score: Score): RIO[Has[Console.Service] with Has[BonusService], Score] =\n    for {\n      bonusService <- RIO.service[BonusService]\n      currentBonus <- bonusService.queryCurrentBonus\n    } yield {\n      val value = score.value + config.mangoValue + currentBonus\n      score.copy(value = value)\n    }\n}\nThis represents a game score system where the player can collect Stars or Mangoes with differently configured and calculated point values.","title":"API Overview"},{"location":"/distage/distage-testkit.html#spec-base-classes","text":"There are test suite base classes for functor, bifunctor and trifunctor effect types. We will be choosing the one that matches our application’s effect type from the following:\nNo effect type, imperative usage - SpecIdentity F[_] - Spec1[F] F[+_, +_] - Spec2[F] F[-_, +_, +_] - Spec3[F]\nThe effect monad is expected to support sync and async effects. distage-testkit provides this support for Identity , monix, monix-bio, ZIO, and monads wth instances of cats-effect or BIO typeclasses. For our demonstration application, the tests will use the ZIO[-R, +E, +A] effect type. This means we’ll be using Spec3[ZIO] for the test suite base class.\nThe default config (super.config) has pluginConfig, which by default will scan the package the test is defined in for defined Plugin modules. See the distage-extension-plugins documentation for more information. For our demonstration the module will be provided using explicit moduleOverrides instead of classpath scanning, like so:\npackage app\n\nimport com.typesafe.config.ConfigFactory\nimport distage.ModuleDef\nimport izumi.distage.testkit.scalatest.{AssertZIO, Spec3}\n\nabstract class Test extends Spec3[ZIO] with AssertZIO {\n  val defaultConfig = Config(\n    starValue = 10,\n    mangoValue = 256,\n    defaultBonus = 10,\n  )\n\n  override def config = super\n    .config.copy(\n      moduleOverrides = new ModuleDef {\n        make[Config].from(defaultConfig)\n      },\n      debugOutput = true,\n    )\n}","title":"Spec Base Classes"},{"location":"/distage/distage-testkit.html#test-cases","text":"In WordSpec, a test case is a sentence (a String) followed by in then the body. In distage-testkit the body of the test case is not limited to a function returning an assertion.\nFunctions that take arguments and functions using effect types are also supported. Function arguments and effect environments will be provided according to the distage object graph created from the modules defined in def config: TestConfig.","title":"Test Cases"},{"location":"/distage/distage-testkit.html#assertions","text":"All of the base classes support test cases that are:\nAssertions. Functions returning an assertion. Functions returning unit that fail on exception.\nThese are introduced using in from DistageAbstractScalatestSpec.LowPriorityIdentityOverloads\nThe assertion methods are the same as ScalaTest as the base classes extend ScalaTest Assertions.\nLet’s now create a simple test for our demonstration application:\npackage app\n\nclass ScoreSimpleTest extends Test {\n\n  \"Score\" should {\n\n    \"increase by config star value\" in {\n      val starValue = util.Random.nextInt()\n      val mangoValue = util.Random.nextInt()\n      val defaultBonus = util.Random.nextInt()\n      val config = Config(starValue, mangoValue, defaultBonus)\n      val expected = Score(starValue)\n      val actual = Score.addStar(config, Score.zero)\n      assert(actual == expected)\n    }\n\n    // Use `Config` from the module in the `Test` class above\n    \"increase by config star value from DI\" in {\n      config: Config =>\n        val expected = Score(defaultConfig.starValue)\n        val actual = Score.addStar(config, Score.zero)\n        assert(actual == expected)\n    }\n\n  }\n}\nScoreSimpleTest:\n  - Score should increase by config star value from DI \n- Score should increase by config star value from DI\n- Score should increase by config star value","title":"Assertions"},{"location":"/distage/distage-testkit.html#assertions-with-effects","text":"All of the base classes support test cases that are effects with assertions. Functions returning effects will have arguments provided from the object graph. These test cases are supported by in from DSWordSpecStringWrapper.\nThe different effect types fix the F[_] argument for this syntax:\nSpec1: F[_] Spec2: F[Throwable, _] Spec3: F[Any, Throwable, _]\nWith our demonstration application we’ll use this to verify the Score.echoConfig method. The Config required is from the distage object graph defined in moduleOverrides. By using a function with a Config argument in in, the required argument will be injected by distage-testkit.\npackage app\n\nclass ScoreEffectsTest extends Test {\n  \"testkit operations with effects\" should {\n\n    \"support assertions in effects\" in {\n      (config: Config) =>\n        for {\n          actual <- Score.echoConfig(config)\n          _      <- assertIO(actual == config)\n        } yield ()\n    }\n\n    \"support assertions outside of effect\" in {\n      (config: Config) =>\n        for {\n          actual <- Score.echoConfig(config)\n        } yield {\n          assert(actual == config)\n        }\n    }\n  }\n}\nScoreEffectsTest:\nConfig(10,256,10)\nConfig(10,256,10)\n  - testkit operations with effects should support assertions in effects \n- testkit operations with effects should support assertions in effects\n  - testkit operations with effects should support assertions outside of effect \n- testkit operations with effects should support assertions outside of effect","title":"Assertions with Effects"},{"location":"/distage/distage-testkit.html#assertions-with-effects-with-environments","text":"The in method for F[_, _, _] effect types supports injection of environments from the object graph in addition to simple assertions and assertions with effects.\nA test that verifies the BonusService in our demonstration would be:\npackage app\n\nabstract class BonusServiceTest extends Test {\n  \"BonusService\" should {\n\n    \"initially use default bonus as current\" in {\n      for {\n        bonusService <- ZIO.service[BonusService]\n        currentBonus <- bonusService.queryCurrentBonus\n        _            <- putStrLn(s\"currentBonus = $currentBonus\")\n        _            <- assertIO(currentBonus == defaultConfig.defaultBonus)\n      } yield ()\n    }\n\n    \"increment by delta\" in {\n      for {\n        delta        <- zio.random.nextInt\n        bonusService <- ZIO.service[BonusService]\n        initialBonus <- bonusService.queryCurrentBonus\n        actualBonus  <- bonusService.increaseCurrentBonus(delta)\n        expectedBonus = initialBonus + delta\n        _            <- assertIO(actualBonus == expectedBonus)\n      } yield ()\n    }\n\n  }\n}\nThe ZIO Has injection support extends to the test cases, here we request two components implicitly using the ZIO environment:\nBonusService - is requested by ZIO.service[BonusService] zio.Random.Service - is requested by zio.random.nextInt\nWhile this compiles just fine, this test cannot be run without the object graph containing a BonusService component!\nOur demonstration application includes dummy and production implementations for BonusService. For each implementation, we define a ZManaged value describing how to create and finalize it. After adding implementations for BonusService component using these ZManaged’s as constructors, our test cases will be able to use the component BonusService.\npackage app\n\nobject DummyBonusService {\n\n  class Impl(\n     bonusState: Ref[Int]\n  ) extends BonusService {\n\n    override def queryCurrentBonus: UIO[Int] = {\n      bonusState.get\n    }\n\n    override def increaseCurrentBonus(delta: Int): UIO[Int] = {\n      bonusState.updateAndGet(_ + delta)\n    }\n  }\n\n  val acquire: Task[DummyBonusService.Impl] = for {\n    ref <- Ref.make(10)\n    impl = new Impl(ref)\n  } yield impl\n\n  val release: UIO[Unit] = UIO.unit\n\n  val managed: TaskManaged[DummyBonusService.Impl] =\n    acquire.toManaged(_ => release)\n}\nThis dummy implementation is useful for verification in both automated tests and functional prototypes.\nFor a real system we might build a production implementation like the following. This hypothetical implementation would perform an HTTP request to a REST service. We’ll introduce a production service, but this actual query will be unimplemented for our demonstration:\npackage app\n\nobject ProdBonusService {\n\n  class Impl(\n    console: Console.Service,\n    url: String,\n  ) extends BonusService {\n\n    override def queryCurrentBonus = for {\n      _ <- console.putStrLn(s\"querying $url\")\n    } yield ???\n\n    override def increaseCurrentBonus(delta: Int) = for {\n      _ <- console.putStrLn(s\"post to $url\")\n    } yield ???\n  }\n\n  val acquire: RIO[Has[Console.Service], ProdBonusService.Impl] = for {\n    console <- ZIO.service[Console.Service]\n    impl      = new Impl(console, \"https://my-bonus-server/current-bonus.json\")\n  } yield impl\n\n  val release: UIO[Unit] = UIO.unit\n\n  val managed: RManaged[Has[Console.Service], ProdBonusService.Impl] =\n    acquire.toManaged(_ => release)\n}","title":"Assertions with Effects with Environments"},{"location":"/distage/distage-testkit.html#pattern-dual-test-tactic","text":"The testing of BonusService in our demonstration application will follow the Dual Test Tactic. See our blog post Unit, Functional, Integration? You are doing it wrong for a discussion of test taxonomy and the value of this tactic.\nA binding for the implementation of BonusService must be passed to distage, to be able to build a Has[BonusService] to inject into the ZIO environment of the test.\nBut note that we have two implementations, to use both one option is to define separate modules for the dummy and production implementations. One module would be used by tests and the other only by production.\nHowever, this is not as declaring both implementations in our modules at the same time but with different activations.\nOur demonstration application will use the StandardAxis.Repo Dummy and Prod axis tags:\npackage app\n\nimport distage.plugins.PluginDef\nimport distage.Activation\nimport distage.StandardAxis.Repo\n\nobject BonusServicePlugin extends PluginDef {\n  make[BonusService]\n    .fromHas(DummyBonusService.managed)\n    .tagged(Repo.Dummy)\n\n  make[BonusService]\n    .fromHas(ProdBonusService.managed)\n    .tagged(Repo.Prod)\n}\nHere we used ZIO Has injection .fromHas to supply the environment dependencies for ProdBonusService.managed, namely Has[Console.Service]. (Implementation for Console.Service is provided by default from ZIOSupportModule) .fromHas can be used with ZLayer, ZManaged ZIO or any F[-_, +_, +_]: Local3 (from BIO typeclasses).\nNote that the BonusServicePlugin is not explicitly added to the Test.config: But, this PluginDef class is defined in the same package as the test, namely in app. By default the pluginConfig for the test will include the test’s package, which will be scanned by distage for PluginDef instances.\nContinuing with the pattern, a trait will control which implementation is activated:\npackage app\n\ntrait DummyTest extends Test {\n  override def config = super\n    .config.copy(\n      activation = Activation(Repo -> Repo.Dummy)\n    )\n}\n\ntrait ProdTest extends Test {\n  override def config = super\n    .config.copy(\n      activation = Activation(Repo -> Repo.Prod)\n    )\n}\nWith these, a production test and a dummy test can be introduced for the demonstration game score application. Note how these share the same test code, in BonusServiceTest and differ only in activations.\nWhen extended beyond this small example, this pattern simplifies system level tests, sanity checks, and even a pragmatic form of N-Version Programming:\npackage app\n\nclass ProdBonusServiceTest extends BonusServiceTest with ProdTest\n\nclass DummyBonusServiceTest extends BonusServiceTest with DummyTest\nDummyBonusServiceTest:\ncurrentBonus = 10\n  - BonusService should initially use default bonus as current \n- BonusService should initially use default bonus as current\n  - BonusService should increment by delta \n- BonusService should increment by delta","title":"Pattern: Dual Test Tactic"},{"location":"/distage/distage-testkit.html#test-case-context","text":"The testkit ScalaTest base classes include the following verbs for establishing test context:\nshould must can","title":"Test Case Context"},{"location":"/distage/distage-testkit.html#configuration","text":"The test suite class for your application should override the def config: TestConfig attribute.\nconfig defines plugin configuration, memoization, module overrides and other options.\nSee also:\nTestConfig API docs. Memoization Execution Order","title":"Configuration"},{"location":"/distage/distage-testkit.html#syntax-reference","text":"For F[_], including Identity:\nin { assert(???) }: The test case is a function returning an assertion. in { (a: A, b: B) => assert(???) }: The test case is a function returning an assertion. The a and b will be injected from the object graph. in { (a: A, b: B) => ???: F[Unit] }: The test case is a function returning an effect to be executed. The a and b will be injected from the object graph. The test case will fail if the effect fails. in { (a: A, b: B) => ???: F[Assertion] }: The test case is a function returning an effect to be executed. The a and b will be injected from the object graph. The test case will fail if the effect fails or produces a failure assertion.\nFor F[-_, +_, +_], it’s same with F[Any, _, _]:\nin { ???: F[zio.Has[C] with zio.Has[D], _, Unit] }: The test case is an effect requiring an environment. The test case will fail if the effect fails. The environment will be injected from the object graph. in { ???: F[zio.Has[C] with zio.Has[D], _, Assertion] }: The test case is an effect requiring an environment. The test case will fail if the effect fails or produces a failure assertion. The environment will be injected from the object graph. in { (a: A, b: B) => ???: F[zio.Has[C] with zio.Has[D], _, Assertion] }: The test case is a function producing an effect requiring an environment. All of a: A, b: B, Has[C] and Has[D] will be injected from the object graph.\nProvided by trait AssertZIO:\nassertIO(_: Boolean): zio.ZIO[Any, Nothing, Assertion]\nProvided by trait AssertMonix:\nassertIO(_: Boolean): monix.eval.Task[Assertion]\nProvided by trait AssertCIO:\nassertIO(_: Boolean): cats.effect.IO[Assertion]\nProvided by trait AssertIO2:\nassertBIO[F[+_, +_]: IO2](_: Boolean): F[Nothing, Assertion]\nProvided by trait AssertSync:\nassertIO[F[_]: Sync](_: Boolean): F[Assertion]","title":"Syntax Reference"},{"location":"/distage/distage-testkit.html#execution-order","text":"By default, tests are executed in parallel. This includes tests using ZIO, monix, cats.effect.IO, or any effect type with BIO or cats-effect typeclass instances. Identity is treated as an effect type for imperative code.\nInteroperability with all existing Scala effect types is provided by implicit instances of QuasiIO, QuasiAsync , and QuasiIORunner. These components will be provided to the application automatically via DefaultModule, but may be overridden by user bindings if different behavior or support for custom effect types is required.\nThe execution of tests is grouped into:\nmemoization levels. test suite test cases\nThe default is to run all of these in parallel.\nThe TestConfig has options to change the behavior for each of these groups. The default is ParallelLevel.Unlimited which does not constrain the number of parallel tests. ParallelLevel.Fixed(n: Int) limits the execution to at most n test cases. While ParallelLevel.Sequential executes the test cases one at a time.\nparallelEnvs - Parallelism level for distinct memoization environments. parallelSuites - Parallelism level for test suites. parallelTests - Parallelism level for test cases.\nIf a group is configured to execute sequentially this will execute after the parallel tests.\nFor example, the BonusServiceTest above consists of two test cases and one test suite. Both test cases will be executed in parallel using the capabilities of the effect type.\nThe NotUsingMemoTest and UsingMemoTest test suites below demonstrate executing the test cases sequentially for each test suite. However, the two suites themselves will execute in parallel as they are in the same memoization environment.","title":"Execution Order"},{"location":"/distage/distage-testkit.html#resource-reuse-memoization","text":"For each test, a new object graph with injected values is created. Without using memoization, all components will be created, acquired and released anew for each test case. This may be unwanted. For example, you may wish to reuse a single PostgreSQL container for a sequence of test cases. In which case the PostgreSQL component should be memoized for the duration of those test cases.\nConfiguring memoization determines whether summoning a component results in a fresh component or reuses an existing, memoized, instance.\nFurther, the memoization environment determines how the test cases are scheduled for execution. See the execution order section for further information.","title":"Resource Reuse - Memoization"},{"location":"/distage/distage-testkit.html#memoization-environments","text":"Memoization strategy applied when a component is summoned is defined by the memoization environment. Each distinct memoization environment uses a distinct memoization store. When a component instance is memoized that instance is shared across all tests that use the same memoization environment. TestConfig contains the options that define the memoization environment:\nmemoizationRoots - These components will be acquired once and shared across all tests that used the same memoization environment. activation - Chosen activation axis. Differences in Activation that affect the memoized part of the graph (that alter implementations of components in memoizationRoots or their transitive dependencies) will cause the test to execute in a new memoization environment. pluginConfig - Defines the plugins to source module definitions. forcedRoots - Components treated as a dependency of every test. A component added both to forcedRoots and memoizationRoots will be acquired at the start of all tests and released at the end of all tests in the memoization environment. moduleOverrides - Overrides the modules from pluginConfig.\nThe module environment depends on instantiation of the memoizationRoots components. Changes to the config that alter implementations of these components or their dependencies will change the memoization environment used. This includes, but is not limited to, changes to activation, pluginConfig and moduleOverrides.\nWhen the TestConfig option debugOutput is true the debug output will include memoization environment diagnostics. This can also be controlled using the izumi.distage.testkit.debug system property.","title":"Memoization Environments"},{"location":"/distage/distage-testkit.html#memoization-levels","text":"Since version 1.0 the above memoization environments scheme has been generalized to support unlimited nesting of memoization environments.\nNested memoization levels allow more and better sharing of heavy components among test suites. With previous strategy of single-level memoization environments, any change in TestConfig that forces a new memoization environment would cause every single memoized component to be recreated in a new environment.\nWith new strategy, the memoization environment may be manually partitioned into levels and if a change in TestConfig does not cause a divergence at one of the levels, the nested levels may then fully reuse the object sub-graph of all parent levels that do not diverge.\nFor clarity, the memoization tree structure is printed before test runs. For example, a memoization tree of a project with the following test suites:\nclass SameLevel_1_WithActivationsOverride extends Spec3[ZIO] {\n  override protected def config: TestConfig = {\n    super.config.copy(\n        memoizationRoots = Map(\n          1 -> Set(DIKey[MemoizedInstance], DIKey[MemoizedLevel1]),\n          2 -> Set(DIKey[MemoizedLevel2]),\n        ),\n    )\n  }\n}\n\nclass SameLevel_1_2_WithAdditionalLevel3 extends SameLevel_1_WithActivationsOverride {\n  override protected def config: TestConfig = {\n    super.config.copy(\n      memoizationRoots =\n        super.config.memoizationRoots ++\n        Set(DIKey[MemoizedLevel3]),\n    )\n  }\n}\nMay be visualized as follows:\nTechnical note: divergence of memoization levels is calculated based on equality of recipes of future object graphs, not equality of allocated/existing object graphs.\nNote: original github ticket","title":"Memoization Levels"},{"location":"/distage/distage-testkit.html#examples","text":"The first example will acquire the BonusService for each test case. This will not use memoization.\npackage app\n\nimport izumi.distage.testkit.TestConfig\n\nclass NotUsingMemoTest extends DummyTest {\n  override def config = super\n    .config.copy(\n      // this demo requires the tests to run sequentially\n      parallelTests = TestConfig.ParallelLevel.Sequential\n    )\n\n  \"Not memoizing BonusService\" should {\n    \"use a new instance in the first case\" in {\n      val delta = util.Random.nextInt()\n\n      for {\n        bonusService <- ZIO.service[BonusService]\n        _            <- console.putStrLn(s\"\\n bonusService = ${bonusService} \\n\")\n\n        // change the bonus service state\n        currentBonus <- bonusService.increaseCurrentBonus(delta)\n        expectedBonus = defaultConfig.defaultBonus + delta\n\n        _            <- assertIO(currentBonus == expectedBonus)\n      } yield ()\n    }\n\n    \"use a new instance in the second case\" in {\n      for {\n        bonusService <- ZIO.service[BonusService]\n        _            <- console.putStrLn(s\"\\n bonusService = ${bonusService} \\n\")\n\n        currentBonus <- bonusService.queryCurrentBonus\n\n        // verify the state is unchanged from default\n        _            <- assertIO(currentBonus == defaultConfig.defaultBonus)\n      } yield ()\n    }\n  }\n}\nThese two tests will run sequentially. There is no memoization configured for the dependencies. Each test case will acquire a fresh instance from the object graph. For our demonstration this results in a new BonusService instance for each test case.\nNotUsingMemoTest:\n\n bonusService = repl.MdocSession$App$DummyBonusService$Impl@12405c5d \n\n  - Not memoizing BonusService should use a new instance in the first case \n- Not memoizing BonusService should use a new instance in the first case\n\n bonusService = repl.MdocSession$App$DummyBonusService$Impl@112f30e9 \n\n  - Not memoizing BonusService should use a new instance in the second case \n- Not memoizing BonusService should use a new instance in the second case\nConfiguring the test to memoize BonusService will result in the same instance being used for both test cases:\npackage app\n\nimport distage.DIKey\n\nclass UsingMemoTest extends DummyTest {\n  override def config = super\n    .config.copy(\n      memoizationRoots = super.config.memoizationRoots ++ Set(DIKey[BonusService]),\n      // this demo requires the test cases to run sequentially\n      parallelTests = TestConfig.ParallelLevel.Sequential\n    )\n\n  val delta = util.Random.nextInt()\n\n  \"Memoizing BonusService\" should {\n    \"use a new instance in the first case\" in {\n      for {\n        bonusService <- ZIO.service[BonusService]\n        _            <- console.putStrLn(s\"\\n bonusService = ${bonusService} \\n\")\n\n        // change the bonus service state\n        currentBonus <- bonusService.increaseCurrentBonus(delta)\n        expectedBonus = defaultConfig.defaultBonus + delta\n\n        _            <- assertIO(currentBonus == expectedBonus)\n      } yield ()\n    }\n\n    \"use the same instance in the second case\" in {\n      for {\n        bonusService <- ZIO.service[BonusService]\n        _            <- console.putStrLn(s\"\\n bonusService = ${bonusService} \\n\")\n\n        currentBonus <- bonusService.queryCurrentBonus\n        expectedBonus = defaultConfig.defaultBonus + delta\n\n        // verify the change in the first case modified this bonusService\n        _            <- assertIO(currentBonus == expectedBonus)\n      } yield ()\n    }\n  }\n}\nThe memoization roots include BonusService. This results in the same BonusService instance for each test case.\nThis test requires the effect of the first test case to occur prior to the second test case. As discussed Execution Order section: Without configuring test cases for sequential execution this order would not be guaranteed.\nNote that this test will not use the same BonusService instance as NotUsingMemoTest. The configs for these test have different memoization roots. This results in different memoization environments.\nIf the memoization environments are equal then the components will be shared.\nFor our example, any other test suite with the same memoization environment will share the same BonusService instance:\npackage app\n\nclass AnotherUsingMemoTest extends DummyTest {\n  // This is the same memoization environment even tho the config is declared separately\n  override def config = super\n    .config.copy(\n      memoizationRoots = super.config.memoizationRoots ++ Set(DIKey[BonusService]),\n      // this demo requires the test cases to run sequentially\n      parallelTests = TestConfig.ParallelLevel.Sequential\n    )\n\n  \"Another test using BonusService\" should {\n    \"use the same instance\" in {\n      for {\n        bonusService <- ZIO.service[BonusService]\n        _            <- console.putStrLn(s\"\\n bonusService = ${bonusService} \\n\")\n        currentBonus <- bonusService.queryCurrentBonus\n        _            <- console.putStrLn(s\"currentBonus = ${currentBonus}\")\n      } yield ()\n    }\n  }\n}\nBoth tests suites, all three test cases, will use same memoization environment and the same bonusService instance:\nUsingMemoTest:\n\n bonusService = repl.MdocSession$App$DummyBonusService$Impl@176ab4e2 \n\n  - Memoizing BonusService should use a new instance in the first case \n- Memoizing BonusService should use a new instance in the first case\n\n bonusService = repl.MdocSession$App$DummyBonusService$Impl@176ab4e2 \n\ncurrentBonus = 2069835272\n\n bonusService = repl.MdocSession$App$DummyBonusService$Impl@176ab4e2 \n\n  - Memoizing BonusService should use the same instance in the second case \n- Memoizing BonusService should use the same instance in the second case\n\n\nAnotherUsingMemoTest:\n  - Another test using BonusService should use the same instance \n- Another test using BonusService should use the same instance","title":"Examples"},{"location":"/distage/distage-testkit.html#pseudocode","text":"Suppose that the lookup of an instance for a component uses a hypothetical function lookup(graph, type and tag). This function is memoized using storage specific to the current memoization environment. This memoization environment is uniquely defined by the test config options above. This would have pseudocode like:\nrootComponents = planRoots(memoizationRoots, activation, forcedRoots, ...)\nmemoizationEnvironment = getOrCreate(rootComponents)\nmemoizationStore = memoizationEnvironment.store\n...\nfor each test case\n  add forcedRoots to component dependencies\n  for each component dependency:\n    if memoizationStore contains component\n    then\n      instance = memoizationStore.lookup(component)\n    else\n      instance = acquireComponent(component)\n      if (component is in memoizationRoot paths)\n        memoizationStore.add(component, instance)\n    ...","title":"Pseudocode"},{"location":"/distage/distage-testkit.html#forced-roots","text":"forcedRoots field of TestConfig specifies components to synthetically add to the dependencies of every test within this test suite / memoization environment.\nIf forced root components are not memoized, they will be acquired and released for each test case.\nIf memoized, they will be acquired and released once, before all and after all the tests within this memoization environment.\nThey provide an alternative to ScalaTest’s native beforeEach/beforeAll that can use functional effects instead of mutability (However, All here includes the entire memoization environment, not the enclosing test suite)\nForced roots may be configured per-activation / combination of activations, e.g. you may force postgres table setup to happen only in test environments with Repo -> Repo.Prod activation.","title":"Forced Roots"},{"location":"/distage/distage-testkit.html#test-selection","text":"","title":"Test Selection"},{"location":"/distage/distage-testkit.html#using-integrationcheck","text":"Implementation classes that inherit from izumi.distage.framework.model.IntegrationCheck will have their resourceCheck() method called before the test instantiation to check if external test dependencies — such as Docker containers in distage-framework-docker — are available for the test (or for the role when in main scope).\nIf not, the test will be canceled/ignored.\nThis feature therefore allows you to selectively run only the fast in-memory tests that have no external dependencies by shutting down the docker daemon (or another source of external dependencies).\nIntegration checks are executed only in distage-testkit tests and distage-framework roles.","title":"Using IntegrationCheck"},{"location":"/distage/distage-testkit.html#references","text":"distage Example Project project shows how to use distage, distage-testkit & distage-framework-docker Video for Hyper-pragmatic Pure FP Testing with distage-testkit – is an overview of the concepts, design and usage. Slides for Hyper-pragmatic Pure FP testing with distage-testkit Slides for Scala, Functional Programming and Team Productivity 7mind blog Constructive Test Taxonomy N-Version Programming","title":"References"},{"location":"/distage/distage-testkit.html#extended-example","text":"This is an excerpt from distage-example, specifically the tests source. Techniques in that example to look for:\nPlacing the Profiles component in the memoizationRoots. The axis Repo.Prod uses a PostgreSQL docker container. This is shared across test cases since the Profiles[IO] depends on the PostgreSQL connection which then depends on the container instance. Use of Scene.Managed to use Repo.Prod components in a managed environment.\nYou may also take other projects’ test suites written with distage-testkit as reference:\ntests in d4s library tests in distage-testkit library tests in distage-framework-docker library\nimport distage.{Activation, DIKey, ModuleDef}\nimport distage.StandardAxis.{Scene, Repo}\nimport distage.plugins.PluginConfig\nimport izumi.distage.testkit.TestConfig\nimport izumi.distage.testkit.scalatest.{AssertZIO, Spec3}\nimport leaderboard.model.{Score, UserId}\nimport leaderboard.repo.{Ladder, Profiles}\nimport leaderboard.zioenv.{ladder, rnd}\nimport zio.{ZIO, IO}\n\nabstract class LeaderboardTest extends Spec3[ZIO] with AssertZIO {\n  override def config = TestConfig(\n    pluginConfig = PluginConfig.cached(packagesEnabled = Seq(\"leaderboard.plugins\")),\n    moduleOverrides = new ModuleDef {\n      make[Rnd[IO]].from[Rnd.Impl[IO]]\n    },\n    // For testing, setup a docker container with postgres,\n    // instead of trying to connect to an external database\n    activation = Activation(Scene -> Scene.Managed),\n    // Instantiate Ladder & Profiles only once per test-run and\n    // share them and all their dependencies across all tests.\n    // this includes the Postgres Docker container above and table DDLs\n    memoizationRoots = Set(\n      DIKey[Ladder[IO]],\n      DIKey[Profiles[IO]],\n    ),\n    configBaseName = \"leaderboard-test\",\n  )\n}\n\ntrait DummyTest extends LeaderboardTest {\n  override final def config = super.config.copy(\n    activation = super.config.activation ++ Activation(Repo -> Repo.Dummy)\n  )\n}\n\ntrait ProdTest extends LeaderboardTest {\n  override final def config = super.config.copy(\n    activation = super.config.activation ++ Activation(Repo -> Repo.Prod)\n  )\n}\n\nfinal class LadderTestDummy extends LadderTest with DummyTest\nfinal class LadderTestPostgres extends LadderTest with ProdTest\n\nabstract class LadderTest extends LeaderboardTest {\n\n  \"Ladder\" should {\n    // this test gets dependencies through arguments\n    \"submit & get\" in {\n      (rnd: Rnd[IO], ladder: Ladder[IO]) =>\n        for {\n          user  <- rnd[UserId]\n          score <- rnd[Score]\n          _     <- ladder.submitScore(user, score)\n          res   <- ladder.getScores.map(_.find(_._1 == user).map(_._2))\n          _     <- assertIO(res contains score)\n        } yield ()\n    }\n\n    // other tests get dependencies via ZIO Env:\n    \"assign a higher position in the list to a higher score\" in {\n      for {\n        user1  <- rnd[UserId]\n        score1 <- rnd[Score]\n        user2  <- rnd[UserId]\n        score2 <- rnd[Score]\n\n        _      <- ladder.submitScore(user1, score1)\n        _      <- ladder.submitScore(user2, score2)\n        scores <- ladder.getScores\n\n        user1Rank = scores.indexWhere(_._1 == user1)\n        user2Rank = scores.indexWhere(_._1 == user2)\n\n        _ <- if (score1 > score2) {\n          assertIO(user1Rank < user2Rank)\n        } else if (score2 > score1) {\n          assertIO(user2Rank < user1Rank)\n        } else IO.unit\n      } yield ()\n    }\n\n    // you can also mix arguments and env at the same time\n    \"assign a higher position in the list to a higher score 2\" in {\n      ladder: Ladder[IO] =>\n          for {\n            user1  <- rnd[UserId]\n            score1 <- rnd[Score]\n            user2  <- rnd[UserId]\n            score2 <- rnd[Score]\n\n            _      <- ladder.submitScore(user1, score1)\n            _      <- ladder.submitScore(user2, score2)\n            scores <- ladder.getScores\n\n            user1Rank = scores.indexWhere(_._1 == user1)\n            user2Rank = scores.indexWhere(_._1 == user2)\n\n            _ <- if (score1 > score2) {\n              assertIO(user1Rank < user2Rank)\n            } else if (score2 > score1) {\n              assertIO(user2Rank < user1Rank)\n            } else IO.unit\n          } yield ()\n    }\n  }\n\n}","title":"Extended Example"},{"location":"/distage/reference.html","text":"","title":"Syntax Reference"},{"location":"/distage/reference.html#syntax-reference","text":"ModuleDefDSL syntax:\nSingleton bindings:\n  - `make[X]` = create X using its constructor\n  - `make[X].from[XImpl]` = bind X to its subtype XImpl using XImpl's constructor\n  - `make[X].from(myX)` = bind X to an already existing instance `myX`\n  - `make[X].from { y: Y => new X(y) }` = bind X to an instance of X constructed by a given [[izumi.distage.model.providers.Functoid Functoid]] requesting an Y parameter\n  - `make[X].from { y: Y @Id(\"special\") => new X(y) }` = bind X to an instance of X constructed by a given [[izumi.distage.model.providers.Functoid Functoid]], requesting a named \"special\" Y parameter\n  - `make[X].from { y: Y => new X(y) }`.annotateParameter[Y](\"special\") = bind X to an instance of X constructed by a given [[izumi.distage.model.providers.Functoid Functoid]], requesting a named \"special\" Y parameter\n  - `make[X].named(\"special\")` = bind a named instance of X. It can then be summoned using [[Id]] annotation.\n  - `make[X].using[X](\"special\")` = bind X to refer to another already bound named instance at key `[X].named(\"special\")`\n  - `make[X].fromEffect(X.create[F]: F[X])` = create X using a purely-functional effect `X.create` in `F` monad\n  - `make[X].fromResource(X.resource[F]: Lifecycle[F, X])` = create X using a `Lifecycle` value specifying its creation and destruction lifecycle\n  - `make[X].from[XImpl].modify(fun(_))` = Create X using XImpl's constructor and apply `fun` to the result\n  - `make[X].from[XImpl].modifyBy(_.flatAp { (c: C, d: D) => (x: X) => c.method(x, d) })` = Create X using XImpl's constructor and modify its `Functoid` using the provided lambda - in this case by summoning additional `C` & `D` dependencies and applying `C.method` to `X`\n\nSet bindings:\n  - `many[X].add[X1].add[X2]` = bind a `Set` of X, and add subtypes X1 and X2 created via their constructors to it.\n                                Sets can be bound in multiple different modules. All the elements of the same set in different modules will be joined together.\n  - `many[X].add(x1).add(x2)` = add *instances* x1 and x2 to a `Set[X]`\n  - `many[X].add { y: Y => new X1(y).add { y: Y => X2(y) }` = add instances of X1 and X2 constructed by a given [[izumi.distage.model.providers.Functoid Provider]] function\n  - `many[X].named(\"special\").add[X1]` = create a named set of X, all the elements of it are added to this named set.\n  - `many[X].ref[XImpl]` = add a reference to an already **existing** binding of XImpl to a set of X's\n  - `many[X].ref[X](\"special\")` = add a reference to an **existing** named binding of X to a set of X's\n\nMutators:\n  - `modify[X](fun(_))` = add a modifier applying `fun` to the value bound at `X` (mutator application order is unspecified)\n  - `modify[X].by(_.flatAp { (c: C, d: D) => (x: X) => c.method(x, d) })` = add a modifier, applying the provided lambda to a `Functoid` retrieving `X` - in this case by summoning additional `C` & `D` dependencies and applying `C.method` to `X`\n\nTags:\n  - `make[X].tagged(\"t1\", \"t2)` = attach tags to X's binding.\n  - `many[X].add[X1].tagged(\"x1tag\")` = Tag a specific element of X. The tags of sets and their elements are separate.\n  - `many[X].tagged(\"xsettag\")` = Tag the binding of empty Set of X with a tag. The tags of sets and their elements are separate.\n\nIncludes:\n  - `include(that: ModuleDef)` = add all bindings in `that` module into `this` module","title":"Syntax Reference"},{"location":"/logstage/index.html","text":"Dependencies Overview Syntax Reference Basic setup Log algebras Adding Custom Context to Loggers ZIO environment support Adding FiberId to log messages Tagless trifunctor support Custom JSON rendering with LogstageCodec SLF4J Router","title":"LogStage"},{"location":"/logstage/index.html#logstage","text":"LogStage is a zero-cost structural logging framework for Scala & Scala.js\nKey features:\nLogStage extracts structure from ordinary string interpolations in your log messages with zero changes to code. LogStage uses macros to extract log structure, its faster at runtime than a typical reflective structural logging frameworks, Log contexts Console, File and SLF4J sinks included, File sink supports log rotation, Human-readable output and JSON output included, Method-level logging granularity. Can configure methods com.example.Service.start and com.example.Service.doSomething independently, Slf4J adapters: route legacy Slf4J logs into LogStage router","title":"LogStage"},{"location":"/logstage/index.html#dependencies","text":"libraryDependencies ++= Seq(\n  // LogStage core library\n  \"io.7mind.izumi\" %% \"logstage-core\" % \"1.0.2\",\n  // Json output\n  \"io.7mind.izumi\" %% \"logstage-rendering-circe\" % \"1.0.2\",\n  // Router from Slf4j to LogStage\n  \"io.7mind.izumi\" %% \"logstage-adapter-slf4j\" % \"1.0.2\",\n  // LogStage integration with DIStage\n  \"io.7mind.izumi\" %% \"distage-extension-logstage\" % \"1.0.2\",\n  // Router from LogStage to Slf4J\n  \"io.7mind.izumi\" %% \"logstage-sink-slf4j \" % \"1.0.2\",\n)","title":"Dependencies"},{"location":"/logstage/index.html#overview","text":"The following snippet:\nimport logstage.IzLogger\nimport scala.util.Random\n\nval logger = IzLogger()\n// logger: IzLogger = izumi.logstage.api.IzLogger@662e4df3\n\nval justAnArg = \"example\"\n// justAnArg: String = example\nval justAList = List[Any](10, \"green\", \"bottles\")\n// justAList: List[Any] = List(10, green, bottles)\n\nlogger.trace(s\"Argument: $justAnArg, another arg: $justAList\")\n\n// custom name, not based on `val` name\n\nlogger.info(s\"Named expression: ${Random.nextInt() -> \"random number\"}\")\n\n// print result without a name\n\nlogger.warn(s\"Invisible argument: ${Random.nextInt() -> \"random number\" -> null}\")\n\n// add following fields to all messages printed by a new logger value\n\nval ctxLogger = logger(\"userId\" -> \"user@google.com\", \"company\" -> \"acme\")\n// ctxLogger: IzLogger = izumi.logstage.api.IzLogger@2e69be61\nval delta = Random.nextInt(1000)\n// delta: Int = 107\n\nctxLogger.info(s\"Processing time: $delta\")\nWill look like this in string form:\nAnd like this in JSON:\nNote:\nJSON formatter is type aware! Each JSON message contains @class field with holds a unique event class identifier. All events produced by the same source code line will share the same event class.","title":"Overview"},{"location":"/logstage/index.html#syntax-reference","text":"1) Simple variable:\nlogger.info(s\"My message: $argument\")\n2) Chain:\nlogger.info(s\"My message: ${call.method} ${access.value}\")\n3) Named expression:\nlogger.info(s\"My message: ${Some.expression -> \"argname\"}\")\n4) Invisible named expression:\nlogger.info(s\"My message: ${Some.expression -> \"argname\" -> null}\")\n5) De-camelcased name:\nlogger.info(${camelCaseName -> ' '})","title":"Syntax Reference"},{"location":"/logstage/index.html#basic-setup","text":"import logstage.{ConsoleSink, IzLogger, Trace}\nimport logstage.circe.LogstageCirceRenderingPolicy\n\nval textSink = ConsoleSink.text(colored = true)\n// textSink: ConsoleSink = izumi.logstage.sink.ConsoleSink$ColoredConsoleSink$@2f724c3a\nval jsonSink = ConsoleSink(LogstageCirceRenderingPolicy(prettyPrint = true))\n// jsonSink: ConsoleSink = izumi.logstage.sink.ConsoleSink@286dbe10\n\nval sinks = List(jsonSink, textSink)\n// sinks: List[ConsoleSink] = List(izumi.logstage.sink.ConsoleSink@286dbe10, izumi.logstage.sink.ConsoleSink$ColoredConsoleSink$@2f724c3a)\n\nval logger: IzLogger = IzLogger(Trace, sinks)\n// logger: IzLogger = izumi.logstage.api.IzLogger@3c383f3b\nval contextLogger: IzLogger = logger(\"key\" -> \"value\")\n// contextLogger: IzLogger = izumi.logstage.api.IzLogger@5fc1046b\n\nlogger.info(\"Hey\")\n\ncontextLogger.info(\"Hey\")","title":"Basic setup"},{"location":"/logstage/index.html#log-algebras","text":"LogIO, LogIO2 & LogIO3 algebras provide a purely-functional API for one-, two-, and three-parameter effect types respectively:\nimport logstage.{IzLogger, LogIO}\nimport cats.effect.IO\n\nval logger = IzLogger()\n// logger: IzLogger = izumi.logstage.api.IzLogger@626f9035\n\nval log = LogIO.fromLogger[IO](logger)\n// log: LogIO[IO] = logstage.LogIO$$anon$1@46e3ce68\n\nlog.info(s\"Hey! I'm logging with ${log}stage!\").unsafeRunSync()\nI 2019-03-29T23:21:48.693Z[Europe/Dublin] r.S.App7.res8 ...main-12:5384  (00_logstage.md:92) Hey! I'm logging with log=logstage.LogIO$$anon$1@72736f25stage!\nLogIO.log/LogIO2.log/LogIO3.log/IzLogger.log let you refer to an implicit logger’s methods without having to name a logger variable\nimport logstage.LogIO\nimport logstage.LogIO.log\n\ndef logfun[F[_]: LogIO]: F[Unit] = {\n  log.info(s\"I'm logging with ${log}stage!\")\n}","title":"Log algebras"},{"location":"/logstage/index.html#adding-custom-context-to-loggers","text":"LogIO* algebras can be extended with custom context using their .withCustomContext method, same as IzLogger:\nimport cats.effect.IO\nimport cats.syntax.all._\nimport logstage.LogIO\nimport io.circe.Printer\nimport io.circe.syntax._\n\ndef importEntity(entity: Entity)(implicit log: LogIO[IO]): IO[Unit] = {\n  val logWithContext: LogIO[IO] = {\n    log.withCustomContext(\n      \"ID\" -> entity.id,\n      \"entityAsJSON\" -> entity.asJson.printWith(Printer.spaces2),\n    )\n  }\n\n  load(entity).handleErrorWith {\n    case error =>\n      logWithContext.error(s\"Failed to import entity: $error.\").void\n      // JSON message includes `ID` and `entityAsJSON` fields\n  }\n}","title":"Adding Custom Context to Loggers"},{"location":"/logstage/index.html#zio-environment-support","text":"LogZIO.log lets you carry LogZIO capability in environment.\nExample:\nimport logstage.{IzLogger, LogIO3, LogZIO}\nimport logstage.LogZIO.log\nimport zio.{Has, URIO}\n\nval fn: URIO[LogZIO, Unit] = {\n  log.info(s\"I'm logging with ${log}stage!\")\n}\n// fn: URIO[LogZIO, Unit] = zio.ZIO$Read@27373f56\n\nval logger: LogZIO.Service = LogIO3.fromLogger(IzLogger())\n// logger: LogZIO.Service = logstage.LogIO$$anon$1@5a8b0d6c\n\nzio.Runtime.default.unsafeRun {\n  fn.provide(Has(logger))\n}","title":"ZIO environment support"},{"location":"/logstage/index.html#adding-fiberid-to-log-messages","text":"LogZIO.withFiberId provides a LogIO instance that logs the current ZIO FiberId in addition to the JVM thread id:\nval logger: LogZIO.Service = LogZIO.withFiberId(IzLogger())\n// logger: LogZIO.Service = logstage.LogZIO$$anon$1@dbea80a\n\nzio.Runtime.default.unsafeRun {\n   fn.provide(Has(logger))\n}\nI 2019-03-29T23:21:48.760Z[Europe/Dublin] r.S.App9.res10 ...main-12:5384  (00_logstage.md:123) {fiberId=0} Hey! I'm logging with log=logstage.LogZIO$$anon$1@c39104astage!","title":"Adding FiberId to log messages"},{"location":"/logstage/index.html#tagless-trifunctor-support","text":"LogIO3Ask.log adds environment support for all trifunctor effect types with an instance of MonadAsk3[F] typeclass from BIO hierarchy.\nExample:\nimport logstage.{LogIO3, LogIO3Ask, IzLogger}\nimport logstage.LogIO3Ask.log\nimport zio.{Has, ZIO}\n\ndef fn[F[-_, +_, +_]: LogIO3Ask]: F[Has[LogIO3[F]], Nothing, Unit] = {\n log.info(s\"I'm logging with ${log}stage!\")\n}\n\nval logger = LogIO3.fromLogger(IzLogger())\n// logger: LogIO3[ZIO] = logstage.LogIO$$anon$1@134e7fb0\n\nzio.Runtime.default.unsafeRun {\n  fn[ZIO].provide(Has(logger))\n}","title":"Tagless trifunctor support"},{"location":"/logstage/index.html#custom-json-rendering-with-logstagecodec","text":"If you define an instance of LogstageCodec for your type, it will be used when rendering your logs to JSON instead of the default renderer.\nYou can derive instances of LogstageCodec from Circe codecs with logstage-rendering-circe or write them manually.\nExample:\nimport io.circe.Codec\nimport io.circe.derivation\nimport logstage.LogstageCodec\nimport logstage.circe.LogstageCirceCodec\n\nfinal case class KV(key: String, value: Int)\n\nobject KV {\n  implicit val circeCodec: Codec[KV] = derivation.deriveCodec[KV]\n  implicit val logstageCodec: LogstageCodec[KV] = LogstageCirceCodec.derived[KV]\n}\nIf you want to make sure that all values in your interpolations are rendered using LogstageCodec instead of default renderer, use IzStrictLogger/LogIOStrict types from logstage.strict package:\nimport logstage.strict.IzStrictLogger\nimport logstage.ConsoleSink\nimport logstage.circe.LogstageCirceRenderingPolicy\n\nval logger = IzStrictLogger(sink = ConsoleSink(LogstageCirceRenderingPolicy()))\n// logger: IzStrictLogger = izumi.logstage.api.strict.IzStrictLogger@d9d3f00\n\nlogger.info(s\"Got ${KV(\"key\", 7) -> \"KeyValue\"}\")","title":"Custom JSON rendering with LogstageCodec"},{"location":"/logstage/index.html#slf4j-router","text":"When not configured, logstage-adapter-slf4j will log messages with level >= Info to stdout.\nDue to the global mutable nature of slf4j, to configure slf4j logging you’ll have to mutate a global singleton StaticLogRouter. Replace its LogRouter with the same one you use elsewhere in your application to use the same configuration for Slf4j.\nimport logstage.IzLogger\nimport izumi.logstage.api.routing.StaticLogRouter\n\nval myLogger = IzLogger()\n// myLogger: IzLogger = izumi.logstage.api.IzLogger@fffb3b2\n\n// configure SLF4j to use the same router that `myLogger` uses\nStaticLogRouter.instance.setup(myLogger.router)","title":"SLF4J Router"},{"location":"/bio/index.html","text":"","title":"BIO Hierarchy"},{"location":"/bio/index.html#bio-hierarchy","text":"BIO is a set of typeclasses and algebras for programming in tagless final style using bifunctor or trifunctor effect types with variance.\nKey syntactic features:\nErgonomic F summoner that is a single point of entry to all methods in the hierarchy Import-less syntax. Syntax is automatically available whenever any typeclass from the hierarchy is imported, e.g. immediately after IDE auto-import.\nThese syntactic features allow you to write in a low ceremony, IDE-friendly and newcomer-friendly style:\nimport izumi.functional.bio.{F, Monad2, MonadAsk3, Primitives2, Ref3}\n\ndef adder[F[+_, +_]: Monad2: Primitives2](i: Int): F[Nothing, Int] =\n  F.mkRef(0)\n   .flatMap(ref => ref.update(_ + i) *> ref.get)\n\n// update ref from the environment and return result\ndef adderEnv[F[-_, +_, +_]: MonadAsk3](i: Int): F[Ref3[F, Int], Nothing, Int] =\n  F.access {\n    ref =>\n      for {\n        _   <- ref.update(_ + i)\n        res <- ref.get\n      } yield res\n  }\nKey semantic features:\nTyped error handling with bifunctor effect types Automatic conversions to equivalent cats.effect instances using import izumi.functional.bio.catz._ Automatic adaptation of trifunctor typeclasses to bifunctor typeclasses when required No ambiguous implicit errors. It’s legal to have both Monad3 and MonadAsk3 as constraints, despite the fact that MonadAsk3 provides a Monad3: scala import izumi.functional.bio.{Monad3, MonadAsk3} def adderEnv[F[-_, +_, +_]: Monad3: MonadAsk3] // would still work Primitive concurrent data structures: Ref, Promise, Semaphore\nTo use it, add fundamentals-bio library:\nlibraryDependencies += \"io.7mind.izumi\" %% \"fundamentals-bio\" % \"1.0.2\"\nIf you’re using Scala 2.12 you must enable -Ypartial-unification and -Xsource:2.13 for this library to work correctly:\n// REQUIRED options for Scala 2.12\nscalacOptions += \"-Ypartial-unification\"\nscalacOptions += \"-Xsource:2.13\"\nMost likely you’ll also need to add Kind Projector plugin:\naddCompilerPlugin(\"org.typelevel\" % \"kind-projector\" % \"0.11.0\" cross CrossVersion.full)","title":"BIO Hierarchy"},{"location":"/bio/index.html#overview","text":"The following graphic shows the current BIO hierarchy. Note that all the trifunctor typeclasses ending in *3 typeclasses have bifunctor counterparts ending in *2.\n(image)\nAuxiliary algebras:\n(image)\nRaw inheritance hierarchy:\n(image)","title":"Overview"},{"location":"/bio/index.html#syntax-implicit-punning","text":"All implicit syntax in BIO is available automatically without wildcard imports with the help of so-called “implicit punning”, as in the following example:\nimport izumi.functional.bio.Monad2\n\ndef loop[F[+_, +_]: Monad2]: F[Nothing, Nothing] = {\n  val unitEffect: F[Nothing, Unit] = Monad2[F].unit\n  unitEffect.flatMap(_ => loop)\n}\nNote: a .flatMap method is available on the unitEffect value of an abstract type parameter F, even though we did not import any syntax implicits using a wildcard import.\nThe flatMap method was added by the implicit punning on the Monad2 name. In short, implicit punning just means that instead of creating a companion object for a type with the same name as the type, we create “companion” implicit conversions with the same name. So that whenever you import the type, you are also always importing the syntax-providing implicit conversions.\nThis happens to be a great fit for Tagless Final Style, since nearly all TF code will import the names of the used typeclasses.\nImplicit Punning for typeclass syntax relieves the programmer from having to manually import syntax implicits in every file in their codebase.","title":"Syntax, Implicit Punning"},{"location":"/bio/index.html#cats-effect-compatibilty","text":"Import izumi.functional.bio.catz._ for shim compatibilty with cats-effect. You can run http4s and all the other cats-effect libraries with just BIO typeclasses, without requiring any cats-effect typeclasses.","title":"cats-effect compatibilty"},{"location":"/bio/index.html#data-types","text":"Ref2/3, Promise2/3 and Semaphore2/3 provide basic concurrent mutable state primitives. They require a Primitives2/3 capability to create. With Primitiives*[F] in implicit scope, use F.mkRef/F.mkPromise/F.mkSemaphore respectively. (See also example at top of the page)\nFree monad, as well as FreeError and FreePanic provide building blocks for DSLs when combined with a DSL describing functor.\nMorphism1/2/3 provide unboxed natural transformations for functors with 1,2,3-arity respectively, with Isomorphism1/2/3 modeling two-way transformations.","title":"Data Types"},{"location":"/bio/index.html#misc-capabilities","text":"Clock1/2/3 gives access to current time.\nEntropy1/2/3 models random numbers.\nUnsafeRun2/3 allows executing effects (it is required for conversion to cats’ ConcurrentEffect which also allows unsafe running)","title":"Misc Capabilities"},{"location":"/idealingua/index.html","text":"","title":"IdeaLingua RPC/DML"},{"location":"/idealingua/index.html#idealingua-rpc-dml","text":"IdeaLingua is an RPC framework & Domain Modeling Language, it’s purpose is to:\nShare & publish APIs and data models in a common concise format Allow remote calls to services given their public API definitions. Create idiomatic API clients and servers for all programming languages – currently Scala, TypeScript, C# & Go. Support frontend-to-backend and backend-to-frontend calls (ala push notifications, via buzzer definitions) Abstract away details such as the network protocol or the serialization format. Save developers from untyped and brittle REST.","title":"IdeaLingua RPC/DML"},{"location":"/idealingua/index.html#user-service-example","text":"package user.api\n\nenum Gender = Male | Female\n\nid EntityID {\n  uuid: uuid\n}\n\nmixin Entity {\n  id: EntityID\n}\n\nmixin Person {\n  name: str\n  surname: str\n  gender: Gender\n}\n\ndata User {\n  & Entity\n  + Person\n  password: str\n}\n\ndata PublicUser {\n  + User\n  - password: str\n}\n\nadt Result = Success | Failure\n\ndata Success {\n  message: str\n}\n\ndata Failure {\n  code: int8\n}\n\nservice UserService {\n  def saveUser(user: User): Result\n  def findUserByName(name: str): list[PublicUser] | Failure\n}","title":"User Service Example"},{"location":"/idealingua/index.html#quick-start","text":"You may use our preconfigured Docker environment to experiment with Izumi IDL compiler:\ndocker run -ti --rm septimalmind/izumi-env\nThen try this snippet:\nexport COMPILER=\"io.7mind.izumi:idealingua-v1-compiler_2.12:$izumi.version$\"\nexport S_REPOSITORY=https://oss.sonatype.org/content/repositories/snapshots\nexport R_REPOSITORY=https://oss.sonatype.org/content/repositories/releases\n\n# create sample project in `testproject` directory\ncoursier launch -r $S_REPOSITORY -r $R_REPOSITORY $COMPILER -- :init testproject\n\ncd testproject\n\n# compile Scala and Typescript projects using all the defaults\ncoursier launch -r $S_REPOSITORY -r $R_REPOSITORY $COMPILER -- :scala :typescript\n\n# Run SBT on generated Scala project\npushd .\ncd target/scala\nsbt package\npopd\n\n# Run tsc on generated Typescript project\npushd .\ncd target/typescript\nyarn install\ntsc\npopd\n\napt install -y mc\nmc","title":"Quick start"},{"location":"/idealingua/index.html#example-project","text":"See idealingua-example for examples for Scala, TypeScript, Go, C# and other languages.","title":"Example Project"},{"location":"/idealingua/index.html#installation","text":"","title":"Installation"},{"location":"/idealingua/index.html#using-sbt-plugin","text":"Add the following to your project/plugins.sbt file:\nval izumi_version = \"1.0.2\"\naddSbtPlugin(\"io.7mind.izumi\" % \"sbt-idealingua\" % izumi_version)\nPlace your domain definitions into /src/main/izumi directory, then enable the plugin for that project. For the generated code to compile, you will also need to add dependencies on the Idealingua RTS modules:\nval izumi = prop\n\nizumiProject\n  .enablePlugins(IdealinguaPlugin)\n  .settings(\n    libraryDependencies ++= Seq(\n        Izumi.R.idealingua_model\n      , Izumi.R.idealingua_runtime_rpc\n      , Izumi.R.idealingua_runtime_rpc_http4s\n      , Izumi.R.idealingua_runtime_rpc_circe\n    )\n  )\nYou can depend on the code generated by Idealinguain in your other Scala projects:\nproject.dependsOn(izumiProject)","title":"Using SBT Plugin"},{"location":"/idealingua/index.html#using-the-standalone-compiler","text":"The compiler is built as an uberjar and published to Maven Central.\nThe preferred way to install the compiler is via coursier\nTo install current release version:\n# install release executable\ncoursier bootstrap izumi.r2:idealingua-compiler_2.12:1.0.2 -o idlc\n\n./idlc --help\nTo install development snapshot:\n# install snapshot\ncoursier bootstrap -r https://oss.sonatype.org/content/repositories/snapshots/ izumi.r2:idealingua-compiler_2.12:0.7.0-SNAPSHOT -o idlc\n\n./idlc --help\nCommandline examples:\n# compile sources in ./src and output generated code to ./target/scala and ./target/typescript\n# all compiler plugins for Scala and TypeScript are enabled by * pattern\n\n./idlc -s src -t target -L scala=* -L typescript=*\n# compile with `AnyValExtension` compiler plugin for Scala disabled\n\n./idlc -s src -t target -L scala=-AnyvalExtension -L typescript=*","title":"Using the standalone compiler"},{"location":"/idealingua/index.html#scala-http4s-transport","text":"Most likely you’ll need to use Kind Projector and enable partial unification:\naddCompilerPlugin(\"org.typelevel\" % \"kind-projector\" % \"0.11.0\" cross CrossVersion.full)\n\n// Only for Scala 2.12, not required on 2.13+\nscalacOptions += \"-Ypartial-unification\"\nYou may find the test suite for the http4s backend here.","title":"Scala http4s Transport"},{"location":"/idealingua/language-reference.html","text":"","title":"Idealingua Language Reference"},{"location":"/idealingua/language-reference.html#idealingua-language-reference","text":"","title":"Idealingua Language Reference"},{"location":"/idealingua/language-reference.html#keywords-and-aliases","text":"Keyword Aliases Explanation domain package, namespace Namespace containing collection of entities import References a domain by id include Includes *.model file by name alias type, using Type alias enum Enumeration mixin interface Mixin, named collection of fields data dto, struct Data adt choice Algebraic Data Type id Identifier, named collection of scalars service Service interface def fn, func, fun Method","title":"Keywords and aliases"},{"location":"/idealingua/language-reference.html#inheritance-operators","text":"Keyword Aliases Explanation Example + +++, ... Inherit structure (copy fields) + Mixin & &&& Inherit interface & Mixin - --- Drop structure or field (doesn’t work for interfaces) - Mixin, - field: str","title":"Inheritance operators"},{"location":"/idealingua/language-reference.html#built-in-types","text":"","title":"Built-in types"},{"location":"/idealingua/language-reference.html#scalars","text":"Type name Aliases Explanation Scala type str string String String bool boolean, bit Boolean Boolean i08 byte, int8 8-bit integer Byte i16 short, int16 16-bit integer Short i32 int, int32 32-bit integer Int i64 long, int64 64-bit integer Long f32 float, flt Single precision floating point Float f64 double, dbl Double precision floating point Double uid uuid UUID java.util.UUID tsz dtl, datetimel Timestamp with timezone java.time.ZonedDateTime tsl dtz, datetimez Local timestamp java.time.LocalDateTime time time Time java.time.LocalTime date date Date java.time.LocalDate\nNotes:\nWhen the target language lacks a corresponding numeric type, we use the smallest type available that includes the required type. e.g. in TypeScript i08 is number When the target language lacks types for time","title":"Scalars"},{"location":"/idealingua/language-reference.html#collections","text":"Type name Explanation Scala mapping list[T] List List map[K, V] Map (only scalar and id keys are supported) Map opt[T] Optional value Option set[T] Set (unordered) Set","title":"Collections"},{"location":"/idealingua/json.html","text":"","title":"JSON Wire Format"},{"location":"/idealingua/json.html#json-wire-format","text":"IdeaLingua employs a simple JSON-based wire format. To interoperate, all the language translators should implement this spec.","title":"JSON Wire Format"},{"location":"/idealingua/json.html#data-data-class","text":"data defined as:\npackage example\n\ndata User {\n  name: str\n  surname: str\n  id: uuid\n}\nShould be rendered as:\n{\n  \"name\": \"Lorem\",\n  \"surname\": \"Ipsum\",\n  \"id\": \"13bee602-521b-47c2-ad81-30527f8b2398\"\n}","title":"data: Data Class"},{"location":"/idealingua/json.html#mixin-mixin","text":"When sent over the wire, mixins include a fully qualified name of their implementation.\nmixins defined as:\npackage example\n\nmixin IntPair {\n  x: i32\n  y: i32\n}\n\ndata NamedIntPair {\n  & IntPair\n  name: str\n}\nShould be rendered as:\n{\n  \"example.IntPair#Struct\": {\n    \"x\": 256,\n    \"y\": 512\n  }\n}\nfor the default implementation, and:\n{\n  \"example#NamedIntPair\": {\n    \"x\": 256,\n    \"y\": 512,\n    \"name\": \"Vertex\"\n  }\n}\nfor the NamedIntPair implementation.","title":"mixin: Mixin"},{"location":"/idealingua/json.html#adt-algebraic-data-type","text":"adt’s include an unqualified name of their variant.\nadt defined as:\npackage example\n\nadt AB = A | Z as B\n\ndata A {\n  value: i32\n}\n\ndata Z {\n  value: str\n}\nShould be rendered as:\n{\n  \"A\": {\n    \"value\": 1\n  }\n}\nfor the A variant, and:\n{\n  \"B\": {\n    \"value\": \"abc\"\n  }\n}\nfor the Z as B variant","title":"adt: Algebraic Data Type"},{"location":"/idealingua/json.html#id-identifier","text":"Ids are rendered as strings prefixed by type name and separated by : symbol. Field order is preserved.\nid defined as:\npackage example\n\nid UserId {\n  userId: uuid\n  companyName: str\n}\nShould be rendered as:\n\"UserId#837006c8-d070-4cde-a2dd-8999c186ef02:Lightbend\"","title":"id: Identifier"},{"location":"/idealingua/json.html#alias-type-alias","text":"Type Aliases should be rendered directly as their aliased types and should never impact serialization.","title":"alias: Type Alias"},{"location":"/idealingua/json.html#enum-enumeration","text":"Enums are rendered as strings.\nenum defined as:\npackage example\n\nenum Gender = MALE | FEMALE\nShould be rendered as:\n\"FEMALE\"","title":"enum: Enumeration"},{"location":"/idealingua/json.html#service","text":"Service outputs are always wrapped into a JSON object with one field \"value\".\nFor service defined as:\npackage example\n\nservice SayHello {\n  def sayHello(): str\n}\nsayHello method will return a result rendered as:\n{ \"value\": \"hello\" }","title":"Service"},{"location":"/idealingua/cogen.html","text":"","title":"Code generator reference"},{"location":"/idealingua/cogen.html#code-generator-reference","text":"We support the following concepts:\nEnumerations Algebraic Data Types Type aliases Mixins Data Classes Identifiers Services","title":"Code generator reference"},{"location":"/idealingua/cogen.html#inheritance","text":"We support two forms of inheritance: interface inheritance (& modifier) and structural mixins (* modifier) The only difference between structural inheritance and interface inheritance is presence/absence of the base interface in the list of supertypes Both Data Classes and Mixins support both forms of inheritance Services, ADTs, Type Aliases, Identifiers and Enumerations does not support inheritance We provide widening narrowing implicit functions as well as copy constructors for all the generated entities","title":"Inheritance"},{"location":"/idealingua/cogen.html#example","text":"mixin IntPair {\n  x: i32\n  y: i32\n}\n\nmixin Metadata {\n  id: str\n  name: str\n}\n\nmixin PointLike {\n  + Metadata\n  * IntPair\n}\n\ndata Point {\n  + Metadata\n  * IntPair\n}","title":"Example"},{"location":"/idealingua/cogen.html#scala-output","text":"trait IntPair {\n  def y: Int\n  def x: Int\n}\n\ntrait Metadata {\n  def name: String\n  def id: String\n}\n\nfinal case class Point(y: Int, name: String, x: Int, id: String) extends Metadata\n\ntrait PointLike extends Metadata {\n  def y: Int\n  def x: Int\n  def name: String\n  def id: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#constructs","text":"Notes:\nAll the examples of generated code are given in minimal form Generated code for codecs, implicit conversions and type info is omitted","title":"Constructs"},{"location":"/idealingua/cogen.html#mixin-mixin","text":"mixin Person {\n   name: str\n   surname: str\n }","title":"mixin: Mixin"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Person {\n  def name: String\n  def surname: String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#data-data-class","text":"Differences between Mixins and Data Classes:\nData classes cannot be subclassed Data classes are always rendered as case classes, Mixins are always rendered as pair of Interface and Implementation\ndata HumanUser {\n   + IdentifiedUser\n   * Person\n }","title":"data: Data Class"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class HumanUser(name: String, surname: String, id: UserId) extends IdentifiedUser with Person","title":"Scala output"},{"location":"/idealingua/cogen.html#adt-algebraic-data-type","text":"mixin Success {\n   values: map[str, str]\n }\n\n mixin Failure {\n   message: str\n }\n\n adt Result {\n   Success\n   Failure\n }","title":"adt: Algebraic Data Type"},{"location":"/idealingua/cogen.html#scala-output","text":"trait Failure extends Any { def message: String }\n\ntrait Success extends Any { def values: scala.collection.immutable.Map[String, String] }\n\nsealed trait Result\n\nobject Result {\n  type Element = Result\n\n  case class Success(value: Success) extends Result\n  case class Failure(value: Failure) extends Result\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#alias-type-alias","text":"alias UserId = str","title":"alias: Type Alias"},{"location":"/idealingua/cogen.html#scala-output","text":"package object domain01 {\ntype UserId = String\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#enum-enumeration","text":"enum Gender {\n  MALE\n  FEMALE\n}","title":"enum: Enumeration"},{"location":"/idealingua/cogen.html#scala-output","text":"sealed trait Gender\n\nobject Gender {\n  type Element = Gender\n  def all: Seq[Gender] = Seq(MALE, FEMALE)\n  def parse(value: String) = value match {\n    case \"MALE\" => MALE\n    case \"FEMALE\" => FEMALE\n  }\n  case object MALE extends Gender { override def toString: String = \"MALE\" }\n  case object FEMALE extends Gender { override def toString: String = \"FEMALE\" }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#id-identifier","text":"Notes:\nYou can use only scalar builtin types for identifier fields We provide both parser and sane .toString implementation .toString uses the following format: Name#urlencoded(part1):urlencoded(part2):... Fields are sorted by name before using in parser and .toString\nid UserId {\n  value: uid\n  company: uid\n}","title":"id: Identifier"},{"location":"/idealingua/cogen.html#scala-output","text":"final case class UserId(value: java.util.UUID, company: java.util.UUID) {\n  override def toString: String = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.company, this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"UserId#$suffix\"\n  }\n}\n\nobject UserId {\n  def parse(s: String): UserId = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    UserId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]), parsePart[java.util.UUID](parts(1), classOf[java.util.UUID]))\n  }\n}","title":"Scala output"},{"location":"/idealingua/cogen.html#service-service","text":"id RecordId {\n  value: uid\n}\n\nmixin WithRecordId {\n  id: RecordId\n}\n\nmixin WithResult {\n  result: shared.rpc#Result\n}\n\nmixin UserData {\n  email: str\n}\n\nmixin PrivateUserData {\n  balance: f64\n}\n\nservice UserService {\n  def deleteUser(WithRecordId): (WithResult)\n  def createUser(UserData, PrivateUserData): (WithRecordId, WithResult)\n}\nNotes:\nService signature cannot accept anything except of Mixins (improvements planned) ServerDispatcher allows you to route wrapped result type to an appropriate method of an abstract implementation ClientDispatcher just passes input to an abstract receiver ClientWrapper allows you to transform unwrapped method signatures into wrapping instances ServerWrapped provides you an unwrapping service implementation ServiceUnwrapped provides you a way to implement services with signatures unwrapped","title":"service: Service"},{"location":"/idealingua/cogen.html#scala-output","text":"import _root_.izumi.idealingua.model._\nimport _root_.izumi.idealingua.runtime._\n\nclass UserServiceServerDispatcher[R[+_], S <: UserService[R]](val service: S) extends transport.AbstractServerDispatcher[R, S] {\n  import UserService._\n  override def dispatch(input: UserService.InUserService): R[UserService.OutUserService] = input match {\n    case value: UserService.InDeleteUser =>\n      service.deleteUser(value)\n    case value: UserService.InCreateUser =>\n      service.createUser(value)\n  }\n}\n\nclass UserServiceClientDispatcher[R[+_], S <: UserService[R]](dispatcher: transport.AbstractClientDispatcher[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = dispatcher.dispatch(input, classOf[UserService.OutDeleteUser])\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = dispatcher.dispatch(input, classOf[UserService.OutCreateUser])\n}\n\nclass UserServiceClientWrapper[R[+_], S <: UserService[R]](val service: S) extends model.IDLClientWrapper[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser] = {\n    service.deleteUser(UserService.InDeleteUser(id = id))\n  }\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser] = {\n    service.createUser(UserService.InCreateUser(balance = balance, email = email))\n  }\n}\n\ntrait UserServiceUnwrapped[R[+_], S <: UserService[R]] extends model.IDLServiceExploded[R, S] {\n  import UserService._\n  def deleteUser(id: RecordId): Result[UserService.OutDeleteUser]\n  def createUser(balance: Double, email: String): Result[UserService.OutCreateUser]\n}\n\nclass UserServiceServerWrapper[R[+_], S <: UserService[R]](val service: UserServiceUnwrapped[R, S]) extends UserService[R] {\n  import UserService._\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser] = service.deleteUser(id = input.id)\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser] = service.createUser(balance = input.balance, email = input.email)\n}\n\ntrait UserService[R[_]] extends izumi.idealingua.runtime.model.IDLService[R] {\n  import UserService._\n  override type InputType = UserService.InUserService\n  override type OutputType = UserService.OutUserService\n\n  override def inputClass: Class[UserService.InUserService] = classOf[UserService.InUserService]\n  override def outputClass: Class[UserService.OutUserService] = classOf[UserService.OutUserService]\n\n  def deleteUser(input: UserService.InDeleteUser): Result[UserService.OutDeleteUser]\n  def createUser(input: UserService.InCreateUser): Result[UserService.OutCreateUser]\n}\n\nobject UserService {\n  sealed trait InUserService extends Any\n  sealed trait OutUserService extends Any\n\n  case class InDeleteUser(id: RecordId) extends UserService.InUserService with WithRecordId\n  case class OutDeleteUser(result: shared.rpc.Result) extends AnyVal with UserService.OutUserService with WithResult\n  case class InCreateUser(balance: Double, email: String) extends UserService.InUserService with UserData with PrivateUserData\n  case class OutCreateUser(result: shared.rpc.Result, id: RecordId) extends UserService.OutUserService with WithRecordId with WithResult\n}","title":"Scala output"},{"location":"/idealingua/cogen-circe.html","text":"","title":"Circe serialization reference"},{"location":"/idealingua/cogen-circe.html#circe-serialization-reference","text":"","title":"Circe serialization reference"},{"location":"/idealingua/cogen-circe.html#polymorphism-and-time","text":"Notes:\nData classes cannot be polymorphic\nThe following example demonstrates how polymorphism and time values are handled:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\ntrait Polymorphic\n\nfinal case class TestPayload(\n                        zonedDateTime: ZonedDateTime = ZonedDateTime.now()\n                        , utcZonedDateTime: ZonedDateTime = ZonedDateTime.now(ZoneId.of(\"UTC\"))\n                        , localDateTime: LocalDateTime = LocalDateTime.now()\n                        , localTime: LocalTime = LocalTime.now()\n                        , localDate: LocalDate = LocalDate.now()\n                      ) extends Polymorphic\n\nobject TestPayload {\n  implicit val encodeTestPayload: Encoder[TestPayload] = deriveEncoder[TestPayload]\n  implicit val decodeTestPayload: Decoder[TestPayload] = deriveDecoder[TestPayload]\n}\n\nfinal case class AnotherPayload(message: String) extends Polymorphic\n\nobject AnotherPayload {\n  implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n  implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n}\n\nobject Polymorphic {\n    implicit val encodePolymorphic: Encoder[Polymorphic] = Encoder.instance { c =>\n    c match {\n      case v: TestPayload =>\n        Map(\"com.test#TestPayload\" -> v).asJson\n      case v: AnotherPayload =>\n        Map(\"com.test#RealPayload\" -> v).asJson\n    }\n  }\n  implicit val decodePolymorphic: Decoder[Polymorphic] = Decoder.instance(c => {\n    val fname = c.keys.flatMap(_.headOption).toSeq.head\n    val value = c.downField(fname)\n    fname match {\n      case \"com.test#TestPayload\" =>\n        value.as[TestPayload]\n      case \"com.test#RealPayload\" =>\n        value.as[AnotherPayload]\n    }\n  })\n}\n\ndef test(t: Polymorphic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Polymorphic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(TestPayload())\ntest(AnotherPayload(\"hi\"))\nThis example produces the following output:\nTestPayload:\nEncoded:\n{\"TestPayload\":{\"zonedDateTime\":\"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\"utcZonedDateTime\":\"2018-04-02T21:34:31.367744Z[UTC]\",\"localDateTime\":\"2018-04-02T22:34:31.36778\",\"localTime\":\"22:34:31.367813\",\"localDate\":\"2018-04-02\"}}\n\nParsed:\nRight({\n  \"TestPayload\" : {\n    \"zonedDateTime\" : \"2018-04-02T22:34:31.367649+01:00[Europe/Dublin]\",\n    \"utcZonedDateTime\" : \"2018-04-02T21:34:31.367744Z[UTC]\",\n    \"localDateTime\" : \"2018-04-02T22:34:31.36778\",\n    \"localTime\" : \"22:34:31.367813\",\n    \"localDate\" : \"2018-04-02\"\n  }\n})\n\nRestored:\nRight(Right(TestPayload(2018-04-02T22:34:31.367649+01:00[Europe/Dublin],2018-04-02T21:34:31.367744Z[UTC],2018-04-02T22:34:31.367780,22:34:31.367813,2018-04-02)))\n\n\nAnotherPayload:\nEncoded:\n{\"RealPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"RealPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Polymorphism and time"},{"location":"/idealingua/cogen-circe.html#algebraic-types","text":"Notes:\nWorks same way as polymorphic types Use short names instead of fully qualified names You may introduce a local alias for an algebraic type member: adt MyAdt { domain1.A as A1 | A}. This allows you to resolve name conflicts\nCogen example for ADTs:\nimport java.time._\n\nimport io.circe._\nimport io.circe.parser._\nimport io.circe.syntax._\nimport io.circe.generic.semiauto._\nimport io.circe.generic.decoding._\nimport io.circe.generic.encoding._\nimport io.circe.java8.time._\n\nsealed trait Algebraic\n\nobject NS1 {\n\n  case class Payload(localTime: LocalTime = LocalTime.now()) extends Algebraic\n\n  object Payload {\n    implicit val encodeTestPayload: Encoder[Payload] = deriveEncoder[Payload]\n    implicit val decodeTestPayload: Decoder[Payload] = deriveDecoder[Payload]\n  }\n\n}\n\nobject NS2 {\n\n  case class AnotherPayload(message: String) extends Algebraic\n\n  object AnotherPayload {\n    implicit val encodeAnotherPayload: Encoder[AnotherPayload] = deriveEncoder[AnotherPayload]\n    implicit val decodeAnotherPayload: Decoder[AnotherPayload] = deriveDecoder[AnotherPayload]\n  }\n\n}\nobject Algebraic {\n  implicit val encodePolymorphic: Encoder[Algebraic] = deriveEncoder[Algebraic]\n  implicit val decodePolymorphic: Decoder[Algebraic] = deriveDecoder[Algebraic]\n}\n\ndef test(t: Algebraic): Unit = {\n  val encoded = t.asJson.noSpaces\n  println(s\"Encoded:\\n$encoded\\n\")\n  val parsed = parse(encoded)\n  println(s\"Parsed:\\n$parsed\\n\")\n  val restored = parsed.map(_.as[Algebraic])\n  println(s\"Restored:\\n$restored\\n\")\n}\n\ntest(NS1.Payload())\ntest(NS2.AnotherPayload(\"hi\"))\nOutput:\nEncoded:\n{\"Payload\":{\"localTime\":\"18:13:31.942072\"}}\n\nParsed:\nRight({\n  \"Payload\" : {\n    \"localTime\" : \"18:13:31.942072\"\n  }\n})\n\nRestored:\nRight(Right(Payload(18:13:31.942072)))\n\nEncoded:\n{\"AnotherPayload\":{\"message\":\"hi\"}}\n\nParsed:\nRight({\n  \"AnotherPayload\" : {\n    \"message\" : \"hi\"\n  }\n})\n\nRestored:\nRight(Right(AnotherPayload(hi)))","title":"Algebraic types"},{"location":"/idealingua/cogen-circe.html#identifiers","text":"Identifiers codec just invokes .toString and .parse to serialize/deserialize Identifiers.\nPlease check identifier codegen example for additional details.\nFull example:\nfinal case class CompanyId(value: java.util.UUID) {\n  override def toString: String = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val suffix = Seq(this.value).map(part => escape(part.toString)).mkString(\":\")\n    s\"CompanyId#$suffix\"\n  }\n}\n\ntrait CompanyIdCirce {\n  import _root_.io.circe.{ Encoder, Decoder }\n  implicit val encodeCompanyId: Encoder[CompanyId] = Encoder.encodeString.contramap(_.toString)\n  implicit val decodeCompanyId: Decoder[CompanyId] = Decoder.decodeString.map(CompanyId.parse)\n}\n\nobject CompanyId extends CompanyIdCirce {\n  def parse(s: String): CompanyId = {\n    import izumi.idealingua.runtime.model.IDLIdentifier._\n    val withoutPrefix = s.substring(s.indexOf(\"#\") + 1)\n    val parts = withoutPrefix.split(\":\").map(part => unescape(part))\n    CompanyId(parsePart[java.util.UUID](parts(0), classOf[java.util.UUID]))\n  }\n  implicit class CompanyIdExtensions(_value: CompanyId)\n}","title":"Identifiers"},{"location":"/idealingua/cogen-circe.html#enumerations","text":"Identifiers codec just invokes .toString and .parse same way as it implemented for Identifiers.","title":"Enumerations"},{"location":"/sbt/index.html","text":"","title":"SBT Toolkit"},{"location":"/sbt/index.html#sbt-toolkit","text":"MOVED Moved to https://github.com/7mind/sbtgen/\nIzumi provides you a bunch of sbt plugins allowing you to significantly reduce size and increase clarity of huge multi-module builds.\nTo start using Izumi plugins add the following into your project/plugins.sbt:\n// This is Izumi Bill of Materials, see below\naddSbtPlugin(\"io.7mind.izumi\" % \"sbt-izumi-deps\" % \"1.0.2\")\n\n// Izumi SBT plugins\naddSbtPlugin(\"io.7mind.izumi.sbt\" % \"sbt-izumi\" % \"0.0.57\")\nWe provide you the following kinds of plugins:\nGlobal plugins: they add some helper sbt tasks, enabled automatically, Environmental plugins: they change some aspects of sbt behavior in an opinionated way, intended to be enabled in the root project, Presets - opinionated sets of environmental plugins, Optional plugins: they provide some convenience sbt tasks, intended to be enabled manually, per-project.\nImportant notes:\nPlease keep in mind no plugins are being enabled automatically, The rest of Izumi plugins are optional. You may use a preset to activate them or combine them manually as you wish (using settings groups), Some plugins can’t be enabled globally due to sbt limitations – they have to be enabled per-project. You should use Settings Groups in order to enable them.","title":"SBT Toolkit"},{"location":"/sbt/index.html#global-plugins","text":"Plugin Description IzumiImportsPlugin Makes all the Izumi imports visible by default","title":"Global plugins"},{"location":"/sbt/index.html#environmental-plugins","text":"Plugin Description IzumiBuildManifestPlugin Adds build info into jar manifests IzumiConvenienceTasksPlugin Devops/workflow helpers IzumiDslPlugin Compact build definitions IzumiGitStampPlugin Adds GIT status into jar manifests IzumiPropertiesPlugin Convenience helpers for sys.props IzumiResolverPlugin Better defaults for artifact resolution IzumiInheritedTestScopesPlugin Convenience helpers for test scope inheritance","title":"Environmental plugins"},{"location":"/sbt/index.html#presets","text":"Plugin Description IzumiEnvironment All the environmental plugins except of GIT one IzumiGitEnvironment All the environmental plugins with GIT one","title":"Presets"},{"location":"/sbt/index.html#optional-plugins","text":"Plugin Description IzumiExposedTestScopesPlugin Maintains test scope separation IzumiCompilerOptionsPlugin Some linting/optimization presets for scalac/javac IzumiFetchPlugin Allows you to transitively download artifacts from remote repositories IzumiPublishingPlugin Some convenience helpers and improvements for artifact publishing IzumiBuildInfoPlugin Generates sbt-compatible BOMs – Bills of Materials","title":"Optional plugins"},{"location":"/sbt/index.html#installation","text":"To activate all the plugins add the following statements into your root project:\nenablePlugins(IzumiGitEnvironmentPlugin)\nIf you don’t use git in your project, use this preset instead:\nenablePlugins(IzumiEnvironmentPlugin)\nTo activate Comp\nval GlobalSettings = new DefaultGlobalSettingsGroup {\n  override val plugins = Set(IzumiCompilerOptionsPlugin, IzumiExposedTestScopesPlugin)\n}","title":"Installation"},{"location":"/sbt/index.html#inherited-test-scopes","text":"","title":"Inherited Test Scopes"},{"location":"/sbt/index.html#test-scope-inheritance","text":"IzumiScopesPlugin extends SBT Project with several implicit methods:\ntestOnlyRef - provides you a project reference which is equivalent to % \"test\" dependency, dependsSeq and depends - allow you to add dependencies to your project the way test scopes of your dependencies are visible within test scopes of your project. So, essentially when you use these methods your dependencies are added into your projects with the following qualifier: \"test->compile,test;it->compile,test,it\"\nYou need to activate DefaultItSettingsGroup on your projects (see “Setting Groups” below) in order to make this working on it scope.\nExample:\nlazy val myLibrary = ...\n\nlazy val myProject = (...).depends(myLibrary)\nSo, now you may use classes from the test scope of myLibrary within test scope of myProject","title":"Test Scope Inheritance"},{"location":"/sbt/index.html#test-scope-separation","text":"InheritedTestScopesPlugin works in pair with IzumiScopesPlugin and provides you an unique feature: only the classes you marked with @ExposedTestScope are being exposed to dependant artifacts.\nSo, let’s assume that:\nyou have two artifacts, Library and App, App depends on Library, In the test scope of Library you have a class named TestSuite, In the test scope of Library you have another class named TestUtil, TestUtil is annotated with @ExposedTestScope,\nin that case TestUtil will be visible in App’s test scope, but TestSuite will not be visible.\nA diagram:\n+-----------------------------------------+     +-----------------------------------------+\n| Library                                 |     | App                                     |\n|-----------------------------------------|     |-----------------------------------------|\n| Main scope                              |     | Main scope                              |\n|                                     <---+-----+--                                       |\n| UtilityClass                            |     | AppMain                                 |\n|-----------------------------------------|     |-----------------------------------------+\n| Private Test Scope | Exposed test scope |     | Test scope                              |\n|                    |                <---+-----+--                                       |\n| TestSuite          | TestUtil           |     | Private Test Scope | Exposed test scope |\n+-----------------------------------------+     +-----------------------------------------+\nNotes:\nIntellij IDEA doesn’t support overriden classpaths so when you run your tests under IDEA the whole test scopes are visible in dependencies, At the moment the implementation of @ExposedTestScope (substring presence check) is imperfect and has to be improved, Transitive dependencies are not checked, so in case you expose a class but do not expose it’s dependencies your build will work under IDEA, but you will a classloading exception under sbt. This is going to be improved in the future.","title":"Test Scope Separation"},{"location":"/sbt/index.html#test-scope-publishing","text":"The whole content of test scopes is being published by default with test qualifier. Test scope separation has no effect on test scope publishing.","title":"Test Scope Publishing"},{"location":"/sbt/index.html#settings-dsl","text":"IzumiDslPlugin comes with a DSL intended to simplify definition of complex project layouts.\nTo activate the plugin add the following statement into your root project:\nenablePlugins(IzumiDslPlugin)","title":"Settings DSL"},{"location":"/sbt/index.html#simplified-identifiers","text":"DSL provides syntax to simplify project definitions. A definition such as this:\nlazy val petstoreApp = In(\"app\").as.module\nexpands to\nlazy val petstoreApp = project.in(\"app/petstore-app\")\nYou can attach settings and dependencies to the In part, that way you can apply common settings to all the projects in a directory:\nval ApiSettings = new SettingsGroup {\n  override val plugins = Set(IdealinguaPlugin)\n}\n\nlazy val inApi = In(\"api\").settings(ApiSettings)\n\nlazy val petstoreApi = inApi.as.module\nlazy val todomvcApi = inApi.as.module","title":"Simplified Identifiers"},{"location":"/sbt/index.html#setting-groups","text":"","title":"Setting Groups"},{"location":"/sbt/index.html#global-setting-group","text":"","title":"Global Setting Group"},{"location":"/sbt/index.html#automatic-aggregation","text":"When you use .as.project or .as.module syntax to define a project, that project is stored in a global singleton.\nYou may use transitiveAggregate or transitiveAggregateSeq methods instead of standard aggregate, in that case all the transitive dependencies of the projects provided will be also added into aggregation list. This allows you to simplify your definitions by avoiding specifing all the modules in .aggregate.\nIn case you don’t want your project to be recorded, you shoud use .as.just syntax.\nImportant note: sbt is lazy! We just store project reference in a singleton list, we don’t analyze dependency graph. Though sbt relies on lazy val declarations. So, in fact the singleton initializes at the moment you invoke aggregation. In case you don’t add a project into aggregation list such a project still will be initialized by sbt and added into the singleton, but it would happen later than evaluation of aggregation list so the project will not be aggregated.","title":"Automatic Aggregation"},{"location":"/sbt/index.html#aggregation-safety-check","text":"When you invoke transitiveAggregate or transitiveAggregateSeq on your root project it checks if the accumulated set of known project is the same as the set of all projects loaded by sbt.\nIn case module is missing you’ll get a warning. This makes it unlikely for you to accidentally forget to aggregate a module in multi-module project.","title":"Aggregation Safety Check"},{"location":"/sbt/index.html#build-descriptors","text":"","title":"Build Descriptors"},{"location":"/sbt/index.html#bills-of-materials","text":"Izumi brings Bill of Materials concept to SBT.","title":"Bills of Materials"},{"location":"/sbt/index.html#izumi-bom","text":"You can import Izumi libraries and transitive dependencies without specifying their version or even artifact names. To do that add sbt-izumi-deps SBT plugin:\nval izumi_version = \"1.0.2\"\naddSbtPlugin(\"io.7mind.izumi\" % \"sbt-izumi-deps\" % izumi_version)\nYou can use it like this:\nlibraryDependencies += Izumi.R.distage_core // Import an izumi library\nlibraryDependencies += IzumiDeps.R.cats_effect // Import a dependency of izumi\nlibraryDependencies += IzumiDeps.T.scalatest // Import a dependency of izumi in test scope\nR is for Runtime artifacts and T is for Test scope artifacts","title":"Izumi BOM"},{"location":"/sbt/index.html#create-a-bom-for-your-projects","text":"sbt-izumi-deps allows you to a create BOMs for your own projects. Just add the following snippet into your project settings:\nlazy val myProject = (project in file(\"my-project-bom\"))\n  .settings(withBuildInfo(\"com.mycompany.myproject\", \"MyProjectBOM\"))\nIf you use Izumi SBT DSL, you can use the following syntax:\nlazy val inRoot = In(\".\")\nlazy val myProjectBom = inRoot.as.module\n  .settings(withBuildInfo(\"com.mycompany.myproject\", \"MyProjectBOM\"))\nIf you want to include BOMs of you project, you can use the following syntax:\nimport com.mycompany.myproject.MyProjectBOM\n\nlazy val myLib = In(\"lib\").as.module\n  .settings(\n    libraryDependencies ++= Seq(\n      MyProjectBOM.R.my_project_bom,     // Runtime artifact\n      MyProjectBOM.T.my_project_bom,     // Runtime artifacts for test scope*\n      MyProjectBOM.TSR.my_project_bom,   // Test artifacts\n      MyProjectBOM.TST.my_project_bom,   // Test artifacts for test scope\n    )\n  )","title":"Create a BOM for your projects"},{"location":"/sbt/index.html#build-manifest-entries","text":"","title":"Build Manifest entries"},{"location":"/sbt/index.html#git-manifest-entries","text":"GitStampPlugin adds the following values into MANIFEST.MF of each jar artifact produced:\nManifest Key Description X-Git-Branch The name of branch sbt was invoked on X-Git-Repo-Is-Clean true or false, indicates if GIT repo was in clean state when the build was invoked X-Git-Head-Rev GIT revision on which sbt was invoked\nTo activate the plugin add the following statement into your root project:\nenablePlugins(GitStampPlugin)","title":"Git Manifest entries"},{"location":"/sbt/index.html#convenience-helpers","text":"","title":"Convenience Helpers"},{"location":"/sbt/index.html#stub-generators","text":"ConvenienceTasksPlugin provides you the following commands:\nnewModule <module_path/module_name> [package.suffix]: creates empty project layout at /module_path/module_name. Optional package.suffix may be specified. newStub <module_path/module_name> [stub_name:default]: copies /stubs/${stub_name} into /module_path/module_name. stub_name may be omitted, default value is default\nSetting Description ConvenienceTasksPlugin.Keys.mkJavaDirs Also adds src/*/java directories into generated stubs ConvenienceTasksPlugin.Keys.defaultStubPackage Default stub package. By default same as project’s organization","title":"Stub Generators"},{"location":"/sbt/index.html#version-suffixes","text":"ConvenienceTasksPlugin provides you command\naddVersionSuffix SUFFIX\nThis command updates project version defined in version.sbt with qualifier SUFFIX-SNAPSHOT\nExisting qualifiers will be removed. 1.0.0 would become 1.0.0-SUFFIX-SNAPSHOT 1.0.0-SNAPSHOT would become 1.0.0-SUFFIX-SNAPSHOT\nYou may need this command while setting up a build for feature branches and wish to avoid situation when different branches publishes artifacts with the same names.","title":"Version Suffixes"},{"location":"/sbt/index.html#target-preservation","text":"ConvenienceTasksPlugin provides you command\npreserveTargets SUFFIX\nThis command recursively enumerates all the directories named target and recursively copies them using name target.SUFFIX.\nYou may need this command while setting up a build where you wish to perform clean several times but want to preserve intermediate build artifacts stored in target directories. The most frequent case is coverage build followed by tests and then by production build. In this case you would like to use a command sequence like\n;clean;coverage;test;coverageOff;coverageReport;preserveTargets coverage;clean;publish","title":"target preservation"},{"location":"/sbt/index.html#directory-cleanups","text":"ConvenienceTasksPlugin provides you command\nrmDirs target.coverage\nThis command recursively removes all the directories named target.coverage across the project.\nYou may need this command to cleanup preserved target directories, or destroy some build artifacts, like rmDirs scala-2.11","title":"Directory cleanups"},{"location":"/sbt/index.html#property-readers","text":"IzumiPropertiesPlugin provides you implicit classes allowing you to convert Strings into Integers or Booleans exceptions-safe and do the same for system properties:\n\"true\".asBoolean(default = false) // true\n\"junk\".asBoolean(default = false) // false\n\"123\".asInt(default = 265) // 123\n\"junk\".asInt(default = 265) // 265\nsys.props.asBoolean(\"my.property\", default = false)\nsys.props.asInt(\"my.property\", default = 123)\nYou may activate this plugin with the following statement in root project:","title":"Property Readers"},{"location":"/sbt/index.html#transitive-artifact-downloader","text":"TODO","title":"Transitive Artifact Downloader"},{"location":"/sbt/index.html#optional-settings","text":"","title":"Optional settings"},{"location":"/sbt/index.html#publishing","text":"TODO","title":"Publishing"},{"location":"/sbt/index.html#publishing-settings","text":"TODO","title":"Publishing settings"},{"location":"/sbt/index.html#publishing-credentials-and-targets","text":"TODO","title":"Publishing credentials and targets"},{"location":"/sbt/index.html#compiler-options","text":"CompilerOptionsPlugin provides you some sane compiler option presets (linting, optimizations).\nYou should explicitly enable this plugin in each project you want to use it. When you want to enable it globally, use a settings group:\nval GlobalSettings = new SettingsGroup {\n  override val plugins = Set(\n      IzumiCompilerOptionsPlugin,\n      // ...\n  )\n  // ...\n}","title":"Compiler options"},{"location":"/sbt/index.html#resolvers","text":"ResolverPlugin turns on the following settings which should speedup your dependency resolution:\nupdateOptions := updateOptions\n      .value\n      .withCachedResolution(true)\n      .withGigahorse(true)","title":"Resolvers"},{"location":"/manifesto/index.html","text":"","title":"Productivity and challenges"},{"location":"/manifesto/index.html#productivity-and-challenges","text":"TODO Sorry, this page is not ready yet","title":"Productivity and challenges"},{"location":"/pper/index.html","text":"","title":"PPER Pattern"},{"location":"/pper/index.html#pper-pattern","text":"“Project Networks and Percept-Plan-Execute-Repeat loop to the rescue” slides\nTODO Sorry, this page is not ready yet","title":"PPER Pattern"},{"location":"/distage/binding-types.html","text":"","title":"Binding Types"},{"location":"/distage/binding-types.html#binding-types","text":"","title":"Binding Types"},{"location":"/distage/binding-types.html#singleton-bindings","text":"","title":"Singleton Bindings"},{"location":"/distage/binding-types.html#named-bindings","text":"","title":"Named bindings"},{"location":"/distage/binding-types.html#set-bindings","text":"","title":"Set bindings"},{"location":"/distage/binding-types.html#weak-set-bindings","text":"","title":"# Weak Set bindings"},{"location":"/distage/binding-types.html#lifecycle-resource-bindings","text":"","title":"Lifecycle / Resource bindings"},{"location":"/distage/binding-types.html#effect-bindings","text":"","title":"Effect bindings"},{"location":"/distage/binding-types.html#zio-environment-reader-bindings","text":"","title":"ZIO Environment / Reader bindings"},{"location":"/distage/binding-types.html#config-bindings","text":"","title":"Config bindings"},{"location":"/distage/binding-types.html#role-bindings","text":"See Overview#Roles","title":"Role bindings"},{"location":"/distage/binding-types.html#docker-bindings","text":"","title":"Docker bindings"}]}