<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="microsite">
<meta name="generator" content="Paradox, paradox-material-theme=1.0.0-M1, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="microsite">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>Overview · Izumi Project</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="Izumi Project" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Izumi Project
</span>
<span class="md-header-nav__topic">
Overview
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/7mind/izumi"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
7mind/izumi
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="Izumi Project" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="../index.html" title="Izumi Project">
Izumi Project
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/7mind/izumi"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
7mind/izumi
</div>
</a>

</div>
<ul>
  <li><a href="../distage/index.html" class="page">distage: Staged Dependency Injection</a>
  <ul>
    <li><a href="../distage/basics.html" class="active page">Overview</a></li>
    <li><a href="../distage/debugging.html" class="page">Debugging</a></li>
    <li><a href="../distage/advanced-features.html" class="page">Advanced Features</a></li>
    <li><a href="../distage/distage-framework.html" class="page">distage-framework</a></li>
    <li><a href="../distage/distage-framework-docker.html" class="page">distage-framework-docker</a></li>
    <li><a href="../distage/distage-testkit.html" class="page">distage-testkit</a></li>
    <li><a href="../distage/reference.html" class="page">Syntax Summary</a></li>
  </ul></li>
  <li><a href="../logstage/index.html" class="page">LogStage</a></li>
  <li><a href="../bio/index.html" class="page">BIO Hierarchy</a></li>
  <li><a href="../idealingua/index.html" class="page">IdeaLingua RPC/DML</a>
  <ul>
    <li><a href="../idealingua/language-reference.html" class="page">Idealingua Language Reference</a></li>
    <li><a href="../idealingua/json.html" class="page">JSON Wire Format</a></li>
    <li><a href="../idealingua/cogen.html" class="page">Code generator reference</a></li>
    <li><a href="../idealingua/cogen-circe.html" class="page">Circe serialization reference</a></li>
  </ul></li>
  <li><a href="../sbt/index.html" class="page">SBT Toolkit</a></li>
  <li><a href="../manifesto/index.html" class="page">Productivity and challenges</a></li>
  <li><a href="../pper/index.html" class="page">PPER Pattern</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../distage/basics.html#overview" class="header">Overview</a>
  <ul>
    <li><a href="../distage/basics.html#quick-start" class="header">Quick Start</a></li>
    <li><a href="../distage/basics.html#activation-axis" class="header">Activation Axis</a></li>
    <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings, Lifecycle</a></li>
    <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
    <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
    <li><a href="../distage/basics.html#zio-has-bindings" class="header">ZIO Has Bindings</a></li>
    <li><a href="../distage/basics.html#auto-traits" class="header">Auto-Traits</a></li>
    <li><a href="../distage/basics.html#auto-factories" class="header">Auto-Factories</a></li>
    <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a></li>
    <li><a href="../distage/basics.html#cats-zio-integration" class="header">Cats &amp; ZIO Integration</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 1.0.0-M1
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../distage/basics.html#overview" class="header">Overview</a>
  <ul>
    <li><a href="../distage/basics.html#quick-start" class="header">Quick Start</a></li>
    <li><a href="../distage/basics.html#activation-axis" class="header">Activation Axis</a></li>
    <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings, Lifecycle</a></li>
    <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
    <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
    <li><a href="../distage/basics.html#zio-has-bindings" class="header">ZIO Has Bindings</a></li>
    <li><a href="../distage/basics.html#auto-traits" class="header">Auto-Traits</a></li>
    <li><a href="../distage/basics.html#auto-factories" class="header">Auto-Factories</a></li>
    <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a></li>
    <li><a href="../distage/basics.html#cats-zio-integration" class="header">Cats &amp; ZIO Integration</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#overview" name="overview" class="anchor"><span class="anchor-link"></span></a>Overview</h1>
<div class="toc ">
<ul>
  <li><a href="../distage/basics.html#quick-start" class="header">Quick Start</a>
  <ul>
    <li><a href="../distage/basics.html#dependencies" class="header">Dependencies</a></li>
    <li><a href="../distage/basics.html#hello-world-example" class="header">Hello World example</a></li>
    <li><a href="../distage/basics.html#named-instances" class="header">Named instances</a></li>
    <li><a href="../distage/basics.html#non-singleton-components" class="header">Non-singleton components</a></li>
    <li><a href="../distage/basics.html#real-world-example" class="header">Real-world example</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#activation-axis" class="header">Activation Axis</a>
  <ul>
    <li><a href="../distage/basics.html#multi-dimensionality" class="header">Multi-dimensionality</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#resource-bindings-lifecycle" class="header">Resource Bindings, Lifecycle</a>
  <ul>
    <li><a href="../distage/basics.html#inheritance-helpers" class="header">Inheritance helpers</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#set-bindings" class="header">Set Bindings</a></li>
  <li><a href="../distage/basics.html#effect-bindings" class="header">Effect Bindings</a></li>
  <li><a href="../distage/basics.html#zio-has-bindings" class="header">ZIO Has Bindings</a>
  <ul>
    <li><a href="../distage/basics.html#converting-zio-environment-dependencies-to-parameters" class="header">Converting ZIO environment dependencies to parameters</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#auto-traits" class="header">Auto-Traits</a>
  <ul>
    <li><a href="../distage/basics.html#impl-annotation" class="header">@impl annotation</a></li>
    <li><a href="../distage/basics.html#avoiding-constructors-even-further" class="header">Avoiding constructors even further</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#auto-factories" class="header">Auto-Factories</a>
  <ul>
    <li><a href="../distage/basics.html#with-annotation" class="header">@With annotation</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#tagless-final-style" class="header">Tagless Final Style</a>
  <ul>
    <li><a href="../distage/basics.html#out-of-the-box-typeclass-instances" class="header">Out-of-the-box typeclass instances</a></li>
    <li><a href="../distage/basics.html#effect-type-polymorphism" class="header">Effect-type polymorphism</a></li>
    <li><a href="../distage/basics.html#kind-polymorphism" class="header">Kind polymorphism</a></li>
  </ul></li>
  <li><a href="../distage/basics.html#cats-zio-integration" class="header">Cats &amp; ZIO Integration</a></li>
</ul>
</div>
<h3><a href="#quick-start" name="quick-start" class="anchor"><span class="anchor-link"></span></a>Quick Start</h3>
<h4><a href="#dependencies" name="dependencies" class="anchor"><span class="anchor-link"></span></a>Dependencies</h4>
<p>Add the <code>distage-core</code> library:</p><dl class="dependency"><dt>sbt</dt><dd><pre class="prettyprint"><code class="language-scala">libraryDependencies += "io.7mind.izumi" %% "distage-framework-docker" % "1.0.0-M1"</code></pre></dd><dt>Maven</dt><dd><pre class="prettyprint"><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;io.7mind.izumi&lt;/groupId&gt;
  &lt;artifactId&gt;distage-framework-docker_2.13&lt;/artifactId&gt;
  &lt;version&gt;1.0.0-M1&lt;/version&gt;
&lt;/dependency&gt;</code></pre></dd><dt>Gradle</dt><dd><pre class="prettyprint"><code class="language-gradle">dependencies {
  compile group: 'io.7mind.izumi', name: 'distage-framework-docker_2.13', version: '1.0.0-M1'
}</code></pre></dd></dl>
<h4><a href="#hello-world-example" name="hello-world-example" class="anchor"><span class="anchor-link"></span></a>Hello World example</h4>
<p>Suppose we have an abstract <code>Greeter</code> component, and some other components that depend on it:</p>
<pre class="prettyprint"><code class="language-scala">import zio.RIO
import zio.console.{Console, getStrLn, putStrLn}

trait Greeter {
  def hello(name: String): RIO[Console, Unit]
}

final class PrintGreeter extends Greeter {
  override def hello(name: String) = 
    putStrLn(s&quot;Hello $name!&quot;) 
}

trait Byer {
  def bye(name: String): RIO[Console, Unit]
}

final class PrintByer extends Byer {  
  override def bye(name: String) = 
    putStrLn(s&quot;Bye $name!&quot;)
}

final class HelloByeApp(
  greeter: Greeter, 
  byer: Byer,
) {
  def run: RIO[Console, Unit] = {
    for {
      _    &lt;- putStrLn(&quot;What&#39;s your name?&quot;) 
      name &lt;- getStrLn
      _    &lt;- greeter.hello(name)
      _    &lt;- byer.bye(name) 
    } yield ()
  }
}
</code></pre>
<p>To actually run the <code>HelloByeApp</code>, we have to wire implementations of <code>Greeter</code> and <code>Byer</code> into it. We will not do it directly. First we&rsquo;ll only declare the component interfaces we have, and the implementations we want for them:</p>
<pre class="prettyprint"><code class="language-scala">import distage.ModuleDef

val HelloByeModule = new ModuleDef {
  make[Greeter].from[PrintGreeter]
  make[Byer].from[PrintByer]
  make[HelloByeApp] // `.from` is not required for concrete classes 
}
// HelloByeModule: AnyRef with ModuleDef = 
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.HelloByeApp}].from(call(π:Class(repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter, repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.HelloByeApp)) ((basics.md:80))
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(π:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintGreeter)) ((basics.md:78))
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Byer}].from(call(π:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintByer)) ((basics.md:79))
</code></pre>
<p><code>ModuleDef</code> merely contains a description of the desired object graph, let&rsquo;s transform that high-level description into an actionable series of steps - an <a href="/api/izumi/distage/model/plan/OrderedPlan.html">OrderedPlan</a>, a datatype we can <a href="debugging.html#pretty-printing-plans">inspect</a>, <a href="debugging.html#testing-plans">test</a> or <a href="distage-framework.html#compile-time-checks">verify at compile-time</a> – without having to actually create objects or execute effects.</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Activation, Injector, Roots}

val injector = Injector[RIO[Console, *]]()
// injector: Injector[zio.ZIO[zio.Has[Console.Service], Throwable, β$0$]] = izumi.distage.InjectorDefaultImpl@256b4af0

val plan = injector.plan(HelloByeModule, Activation.empty, Roots.target[HelloByeApp])
// plan: izumi.distage.model.plan.OrderedPlan = 
// {type.MdocSession::App0::Greeter} (basics.md:78) := call(π:Class(): MdocSession::App0::PrintGreeter) {}
// {type.MdocSession::App0::Byer} (basics.md:79) := call(π:Class(): MdocSession::App0::PrintByer) {}
// {type.MdocSession::App0::HelloByeApp} (basics.md:80) := call(π:Class(MdocSession::App0::Greeter, MdocSession::App0::Byer): MdocSession::App0::HelloByeApp) {
//   arg greeter: MdocSession::App0::Greeter = lookup({type.MdocSession::App0::Greeter})
//   arg byer: MdocSession::App0::Byer = lookup({type.MdocSession::App0::Byer})
// }
</code></pre>
<p>The series of steps must be executed to produce the object graph.</p>
<p><code>Injector.produce</code> will interpret the steps into a <a href="basics.html#resource-bindings-lifecycle"><code>Lifecycle</code></a> value holding the lifecycle of the object graph:</p>
<pre class="prettyprint"><code class="language-scala">import zio.Runtime.default.unsafeRun

// Interpret into a Lifecycle value

val resource = injector.produce(plan)
// resource: izumi.distage.model.definition.Lifecycle[zio.ZIO[zio.Has[Console.Service], Throwable, β$0$], izumi.distage.model.Locator] = izumi.distage.model.definition.Lifecycle$$anon$10@8ae5e0b

// Use the object graph:
// After `.use` exits, all objects will be deallocated,
// and all allocated resources will be freed.

val effect = resource.use {
  objects =&gt;
    objects.get[HelloByeApp].run
}
// effect: zio.ZIO[zio.Has[Console.Service], Throwable, Unit] = zio.ZIO$CheckInterrupt@2da68fe9

// Run the resulting program

unsafeRun(effect)
// What&#39;s your name?
// &gt; izumi
// Hello izumi!
// Bye izumi!
</code></pre>
<p><code>distage</code> always creates components exactly once, even if multiple other objects depend on them. Coming from other DI frameworks, you may think of it as if there&rsquo;s only a &ldquo;Singleton&rdquo; scope. It&rsquo;s impossible to create non-singletons in <code>distage</code>.</p>
<h4><a href="#named-instances" name="named-instances" class="anchor"><span class="anchor-link"></span></a>Named instances</h4>
<p>If you need multiple singleton instances of the same type, you may create &ldquo;named&rdquo; instances and disambiguate between them using <a href="/api/izumi/distage/model/definition/Id.html"><code>@distage.Id</code></a> annotation. (<code>javax.inject.Named</code> is also supported)</p>
<pre class="prettyprint"><code class="language-scala">import distage.Id

def negateByer(otherByer: Byer): Byer = {
  new Byer {
    def bye(name: String) =   
     otherByer.bye(s&quot;NOT-$name&quot;)
  }
}

new ModuleDef {
  make[Byer].named(&quot;byer-1&quot;).from[PrintByer]
  make[Byer].named(&quot;byer-2&quot;).from {
    otherByer: Byer @Id(&quot;byer-1&quot;) =&gt;
      negateByer(otherByer)
  }
}
</code></pre>
<p>You can use <code>make[_].annotateParameter</code> method instead of an annotation, to attach a name component to an existing constructor:</p>
<pre class="prettyprint"><code class="language-scala">new ModuleDef {
  // same binding as above
  make[Byer].named(&quot;byer-2&quot;)
    .from(negateByer(_))
    .annotateParameter[Byer](&quot;byer-1&quot;)
}
</code></pre>
<p>You can also abstract over annotations using type aliases or string constants:</p>
<pre class="prettyprint"><code class="language-scala">object Ids {
  final val byer1Id = &quot;byer-1&quot;
  type Byer1 = Byer @Id(byer1Id)
}
</code></pre>
<h4><a href="#non-singleton-components" name="non-singleton-components" class="anchor"><span class="anchor-link"></span></a>Non-singleton components</h4>
<p>To create new non-singleton instances you must use explicit factories. <code>distage</code>&rsquo;s <a href="basics.html#auto-factories">Auto-Factories</a> can generate implementations for your factories, removing the associated boilerplate.</p>
<p>While Auto-Factories may remove the boilerplate of passing the singleton parts of the graph to your new non-singleton components along with dynamic arguments, if you absolutely must wire a new non-trivial subgraph in a dynamic scope you&rsquo;ll need to run <code>Injector</code> again in your scope. </p>
<p>You may use <code>Injector.inherit</code> to obtain access to your outer object graph in your new sub-graph. It&rsquo;s safe to run <code>Injector</code> multiple times in nested scopes, as it&rsquo;s extremely fast, not least due to total absence of runtime reflection. See <a href="advanced-features.html#injector-inheritance">Injector Inheritance</a></p>
<h4><a href="#real-world-example" name="real-world-example" class="anchor"><span class="anchor-link"></span></a>Real-world example</h4>
<p>Check out <a href="https://github.com/7mind/distage-example"><code>distage-example</code></a> sample project for a complete example built using <code>distage</code>, <a href="../bio/index.html">bifunctor tagless final</a>, <code>http4s</code>, <code>doobie</code> and <code>zio</code> libraries.</p>
<p>It shows how to write an idiomatic <code>distage</code>-style from scratch and how to:</p>
<ul>
  <li>write tests using <a href="distage-testkit.html"><code>distage-testkit</code></a></li>
  <li>setup portable test environments using <a href="distage-framework-docker.html"><code>distage-framework-docker</code></a></li>
  <li>create <a href="distage-framework.html#roles">role-based applications</a></li>
  <li>enable <a href="distage-framework.html">compile-time checks</a> for fast-feedback on wiring errors</li>
</ul>
<h3><a href="#activation-axis" name="activation-axis" class="anchor"><span class="anchor-link"></span></a>Activation Axis</h3>
<p>You can choose between different implementations of a component using &ldquo;Activation axis&rdquo;:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Axis, Activation, ModuleDef, Injector}

class AllCapsGreeter extends Greeter {
  def hello(name: String) = 
    putStrLn(s&quot;HELLO ${name.toUpperCase}&quot;)
}

// declare a configuration axis for our components

object Style extends Axis {
  case object AllCaps extends AxisValueDef
  case object Normal extends AxisValueDef
}

// Declare a module with several implementations of Greeter
// but in different environments

def TwoImplsModule = new ModuleDef {
  make[Greeter].tagged(Style.Normal)
    .from[PrintGreeter]
  
  make[Greeter].tagged(Style.AllCaps)
    .from[AllCapsGreeter]
}

// Combine previous `HelloByeModule` with our new module
// While overriding `make[Greeter]` bindings from the first module 

def CombinedModule = HelloByeModule overriddenBy TwoImplsModule

// Choose component configuration when making an Injector:

unsafeRun {
  Injector()
    .produceGet[HelloByeApp](CombinedModule, Activation(Style -&gt; Style.AllCaps))
    .use(_.run)
}
// What&#39;s your name?
// &gt; kai
// HELLO KAI
// Bye kai!

// Check that result changes with a different configuration:

unsafeRun {
  Injector()
    .produceGet[HelloByeApp](CombinedModule, Activation(Style -&gt; Style.Normal))
    .use(_.run)
}
// What&#39;s your name?
// &gt; Pavel
// Hello Pavel!
// Bye Pavel!
</code></pre>
<p><a href="/api/izumi/distage/model/definition/StandardAxis$.html">distage.StandardAxis</a> contains bundled Axes for back-end development: </p>
<ul>
  <li>
  <p><a href="/api/izumi/distage/model/definition/StandardAxis$$Repo$.html">Repo</a> axis, with <code>Prod</code>/<code>Dummy</code> choices, describes any entities which may store and persist state or &ldquo;repositories&rdquo;. e.g. databases, message queues, KV storages, file systems, etc. Those may typically have both in-memory <code>Dummy</code> implementations and heavyweight <code>Prod</code> implementations using external databases.</p></li>
  <li>
  <p><a href="/api/izumi/distage/model/definition/StandardAxis$$Mode$.html">Mode</a> axis, with <code>Prod</code>/<code>Test</code> choices, describes a generic choice between production and test implementations of a component.</p></li>
  <li>
  <p><a href="/api/izumi/distage/model/definition/StandardAxis$$World$.html">World</a> axis, with <code>Real</code>/<code>Mock</code> choices, describes third-party integrations which are not controlled by the application and provided &ldquo;as is&rdquo;. e.g. Facebook API, Google API, etc. those may contact a <code>Real</code> external integration or a <code>Mock</code> one with predefined responses.</p></li>
  <li>
  <p><a href="/api/izumi/distage/model/definition/StandardAxis$$Scene$.html">Scene</a> axis with <code>Managed</code>/<code>Provided</code> choices, describes whether external services required by the application should be set-up on the fly by an orchestrator library such as <a href="distage-framework-docker.html"><code>distage-framework-docker</code></a> (<code>Scene.Managed</code>), or whether the application should try to connect to external services as if they already exist in the environment (<code>Scene.Provided</code>).  We call a set of external services required by the application a <code>Scene</code>, etymology being that the running external services required by the application are like a &ldquo;scene&rdquo; that the &ldquo;theatre staff&rdquo; (the orchestrator) must prepare for the &ldquo;actor&rdquo; (the application) to enter.</p></li>
</ul>
<p>In <code>distage-framework</code>&rsquo;s <a href="/api/izumi/distage/roles/RoleAppMain.html">RoleAppMain</a>, you can choose axes using the <code>-u</code> command-line parameter:</p>
<pre><code>./launcher -u repo:dummy -u env:prod app1
</code></pre>
<p>In <code>distage-testkit</code>, choose axes using <a href="/api/izumi/distage/testkit/TestConfig.html">TestConfig</a>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.StandardAxis.Repo
import izumi.distage.testkit.TestConfig
import izumi.distage.testkit.scalatest.DistageBIOSpecScalatest

class AxisTest extends DistageBIOSpecScalatest[zio.IO] {

  // choose implementations `.tagged` as `Repo.Dummy` over those tagged `Repo.Prod`
  override def config: TestConfig = super.config.copy(
    activation = Activation(Repo -&gt; Repo.Dummy)
  )
  
}
</code></pre>
<h4><a href="#multi-dimensionality" name="multi-dimensionality" class="anchor"><span class="anchor-link"></span></a>Multi-dimensionality</h4>
<p>There may be many configuration axes in an application and components can specify multiple axis choices at once:</p>
<pre class="prettyprint"><code class="language-scala">import distage.StandardAxis.Mode

class TestPrintGreeter extends Greeter {
  def hello(name: String) = 
    putStrLn(s&quot;Test 1 2, hello $name&quot;)
}

// declare 3 possible implementations

val TestModule = new ModuleDef {
  make[Greeter].tagged(Style.Normal, Mode.Prod).from[PrintGreeter]
  make[Greeter].tagged(Style.Normal, Mode.Test).from[TestPrintGreeter]
  make[Greeter].tagged(Style.AllCaps).from[AllCapsGreeter]
}
// TestModule: AnyRef with ModuleDef = 
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(π:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.TestPrintGreeter)).tagged(Set(AxisTag(style:normal), AxisTag(mode:test))) ((basics.md:240))
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(π:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.AllCapsGreeter)).tagged(Set(AxisTag(style:allcaps))) ((basics.md:241))
// make[{type.repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.Greeter}].from(call(π:Class(): repl.MdocSession::repl.MdocSession.App0::repl.MdocSession.App0.PrintGreeter)).tagged(Set(AxisTag(style:normal), AxisTag(mode:prod))) ((basics.md:239))

def runWith(activation: Activation) = unsafeRun {
  Injector().produceRun(TestModule, activation) {
    greeter: Greeter =&gt; greeter.hello(&quot;$USERNAME&quot;)
  }
}

// Production Normal Greeter

runWith(Activation(Style -&gt; Style.Normal, Mode -&gt; Mode.Prod))
// Hello $USERNAME!

// Test Normal Greeter

runWith(Activation(Style -&gt; Style.Normal, Mode -&gt; Mode.Test))
// Test 1 2, hello $USERNAME

// Both Production and Test Caps Greeters are the same:

runWith(Activation(Style -&gt; Style.AllCaps, Mode -&gt; Mode.Prod))
// HELLO $USERNAME

runWith(Activation(Style -&gt; Style.AllCaps, Mode -&gt; Mode.Test))
// HELLO $USERNAME
</code></pre>
<h3><a href="#resource-bindings-lifecycle" name="resource-bindings-lifecycle" class="anchor"><span class="anchor-link"></span></a>Resource Bindings, Lifecycle</h3>
<p>You can specify object lifecycle by injecting <a href="https://typelevel.org/cats-effect/datatypes/resource.html">cats.effect.Resource</a>, <a href="https://zio.dev/docs/datatypes/datatypes_managed">zio.ZManaged</a> or <a href="/api/izumi/distage/model/definition/Lifecycle.html">distage.Lifecycle</a> values that specify the allocation and finalization actions for an object.</p>
<p>Injector itself only returns a <code>Lifecycle</code> value that can be used to create and finalize the object graph, this value is pure and can be reused multiple times. A <code>Lifecycle</code> is consumed using its <code>.use</code> method, the function passed to <code>use</code> will receive an allocated resource and when the function exits the resource will be deallocated. </p>
<p>Example with <code>cats.effect.Resource</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Roots, ModuleDef, Injector}
import cats.effect.{Resource, IO}

class DBConnection
class MessageQueueConnection

val dbResource = Resource.make(
  acquire = IO { 
    println(&quot;Connecting to DB!&quot;)
    new DBConnection 
})(release = _ =&gt; IO(println(&quot;Disconnecting DB&quot;)))
// dbResource: Resource[IO, DBConnection] = Allocate(&lt;function1&gt;)

val mqResource = Resource.make(
  acquire = IO {
   println(&quot;Connecting to Message Queue!&quot;)
   new MessageQueueConnection 
})(release = _ =&gt; IO(println(&quot;Disconnecting Message Queue&quot;)))
// mqResource: Resource[IO, MessageQueueConnection] = Allocate(&lt;function1&gt;)

class MyApp(db: DBConnection, mq: MessageQueueConnection) {
  val run = IO(println(&quot;Hello World!&quot;))
}

val module = new ModuleDef {
  make[DBConnection].fromResource(dbResource)
  make[MessageQueueConnection].fromResource(mqResource)
  make[MyApp]
}
// module: AnyRef with ModuleDef = 
// make[{type.repl.MdocSession::repl.MdocSession.App10::repl.MdocSession.App10.DBConnection}].from(allocate[λ %0 → cats.effect.IO[+0]](call(ƒ:izumi.distage.model.definition.Lifecycle$$$Lambda$21109/1947121972@41a62489(cats.effect.Sync[=λ %0 → IO[+0]]): izumi.distage.model.definition.Lifecycle::izumi.distage.model.definition.Lifecycle.FromCats[=λ %1:0 → IO[+1:0],=MdocSession::App10::DBConnection]))) ((basics.md:302))
// make[{type.repl.MdocSession::repl.MdocSession.App10::repl.MdocSession.App10.MessageQueueConnection}].from(allocate[λ %0 → cats.effect.IO[+0]](call(ƒ:izumi.distage.model.definition.Lifecycle$$$Lambda$21109/1947121972@36d508eb(cats.effect.Sync[=λ %0 → IO[+0]]): izumi.distage.model.definition.Lifecycle::izumi.distage.model.definition.Lifecycle.FromCats[=λ %1:0 → IO[+1:0],=MdocSession::App10::MessageQueueConnection]))) ((basics.md:303))
// make[{type.repl.MdocSession::repl.MdocSession.App10::repl.MdocSession.App10.MyApp}].from(call(π:Class(repl.MdocSession::repl.MdocSession.App10::repl.MdocSession.App10.DBConnection, repl.MdocSession::repl.MdocSession.App10::repl.MdocSession.App10.MessageQueueConnection): repl.MdocSession::repl.MdocSession.App10::repl.MdocSession.App10.MyApp)) ((basics.md:304))
</code></pre>
<p>Will produce the following output:</p>
<pre class="prettyprint"><code class="language-scala">import distage.DIKey

val objectGraphResource = Injector[IO]().produce(module, Roots(root = DIKey[MyApp]))
// objectGraphResource: izumi.distage.model.definition.Lifecycle[IO, izumi.distage.model.Locator] = izumi.distage.model.definition.Lifecycle$$anon$10@64f9d45c

objectGraphResource
  .use(_.get[MyApp].run)
  .unsafeRunSync()
// Connecting to Message Queue!
// Connecting to DB!
// Hello World!
// Disconnecting DB
// Disconnecting Message Queue
</code></pre>
<p>Lifecycle management with <code>Lifecycle</code> is also available without an effect type, via <code>Lifecycle.Simple</code> and <code>Lifecycle.Mutable</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{Lifecycle, ModuleDef, Injector}

class Init {
  var initialized = false
}

class InitResource extends Lifecycle.Simple[Init] {
  override def acquire = {
    val init = new Init
    init.initialized = true
    init
  }
  override def release(init: Init) = {
    init.initialized = false
  }
}

val module = new ModuleDef {
  make[Init].fromResource[InitResource]
}
// module: AnyRef with ModuleDef = 
// make[{type.repl.MdocSession::repl.MdocSession.App12::repl.MdocSession.App12.Init}].from(allocate[λ %0 → 0](call(π:Class(): repl.MdocSession::repl.MdocSession.App12::repl.MdocSession.App12.InitResource))) ((basics.md:349))

val closedInit = Injector()
  .produceGet[Init](module)
  .use {
    init =&gt;
      println(init.initialized)
      init
}
// true
// closedInit: izumi.fundamentals.platform.functional.package.Identity[Init] = repl.MdocSession$App12$Init@287cd857

println(closedInit.initialized)
// false
</code></pre>
<p><code>Lifecycle</code> forms a monad and has the expected <code>.map</code>, <code>.flatMap</code>, <code>.evalMap</code>, <code>.mapK</code> methods.</p>
<p>You can convert between a <code>Lifecycle</code> and <code>cats.effect.Resource</code> via <code>Lifecycle#toCats</code>/<code>Lifecycle.fromCats</code> methods, and between a <code>Lifecycle</code> and <code>zio.ZManaged</code> via <code>Lifecycle#toZIO</code>/<code>Lifecycle.fromZIO</code> methods.</p>
<h4><a href="#inheritance-helpers" name="inheritance-helpers" class="anchor"><span class="anchor-link"></span></a>Inheritance helpers</h4>
<p>The following helpers allow defining <code>Lifecycle</code> sub-classes using expression-like syntax:</p>
<ul>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$Of.html">Lifecycle.Of</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$OfInner.html">Lifecycle.OfInner</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$OfCats.html">Lifecycle.OfCats</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$OfZIO.html">Lifecycle.OfZIO</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$LiftF.html">Lifecycle.LiftF</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$Make.html">Lifecycle.Make</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$Make_.html">Lifecycle.Make_</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$MakePair.html">Lifecycle.MakePair</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$FromAutoCloseable.html">Lifecycle.FromAutoCloseable</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$SelfOf.html">Lifecycle.SelfOf</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$MutableOf.html">Lifecycle.MutableOf</a></li>
</ul>
<p>The main reason to employ them is to workaround a limitation in Scala 2&rsquo;s eta-expansion whereby when converting a method to a function value, Scala would always try to fulfill implicit parameters eagerly instead of making them parameters in the function value, this limitation makes it harder to inject implicits using <code>distage</code>. However, if instead of eta-expanding manually as in <code>make[A].fromResource(A.resource[F] _)</code>, you use <code>distage</code>&rsquo;s type-based constructor syntax: <code>make[A].fromResource[A.Resource[F]]</code>, this limitation is lifted, injecting the implicit parameters of class <code>A.Resource</code> from the object graph instead of summoning them in-place. Therefore, you can convert an expression based resource-constructor such as:</p>
<pre class="prettyprint"><code class="language-scala">import distage.Lifecycle, cats.Monad

class A

object A {

  def resource[F[_]: Monad]: Lifecycle[F, A] =
    Lifecycle.pure[F, A](new A)
    
}
</code></pre>
<p>Into class-based form:</p>
<pre class="prettyprint"><code class="language-scala">import distage.Lifecycle, cats.Monad

class A

object A {

  final class Resource[F[_]: Monad]
    extends Lifecycle.Of(
      Lifecycle.pure[F, A](new A)
    )
    
}
</code></pre>
<p>And inject successfully using <code>make[A].fromResource[A.Resource[F]]</code> syntax of <a href="/api/izumi/distage/model/definition/dsl/ModuleDefDSL.html">ModuleDefDSL</a>.</p>
<p>The following helpers ease defining <code>Lifecycle</code> sub-classes using traditional inheritance where <code>acquire</code>/<code>release</code> parts are defined as methods:</p>
<ul>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$Basic.html">Lifecycle.Basic</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$Simple.html">Lifecycle.Simple</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$Mutable.html">Lifecycle.Mutable</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$MutableNoClose.html">Lifecycle.MutableNoClose</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$Self.html">Lifecycle.Self</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$SelfNoClose.html">Lifecycle.SelfNoClose</a></li>
  <li><a href="/api/izumi/distage/model/definition/Lifecycle$$NoClose.html">Lifecycle.NoClose</a></li>
</ul>
<h3><a href="#set-bindings" name="set-bindings" class="anchor"><span class="anchor-link"></span></a>Set Bindings</h3>
<p>Set bindings are useful for implementing listeners, plugins, hooks, http routes, healthchecks, migrations, etc. Everywhere where a collection of components is required, a Set Binding is appropriate.</p>
<p>To define a Set binding use <code>.many</code> and <code>.add</code> methods of the <a href="/api/izumi/distage/model/definition/ModuleDef.html">ModuleDef</a> DSL.</p>
<p>As an example, we may declare multiple command handlers and use them to interpret user input in a REPL</p>
<pre class="prettyprint"><code class="language-scala">import distage.ModuleDef

final case class CommandHandler(
  handle: PartialFunction[String, String]
)

val additionHandler = CommandHandler {
  case s&quot;$x + $y&quot; =&gt; s&quot;${x.toInt + y.toInt}&quot;
}
// additionHandler: CommandHandler = CommandHandler(&lt;function1&gt;)

object AdditionModule extends ModuleDef {
  many[CommandHandler]
    .add(additionHandler)
}
</code></pre>
<p>We&rsquo;ve used <code>many</code> method to declare an open <code>Set</code> of command handlers and then added one handler to it.</p>
<p>When module definitions are combined, elements for the same type of <code>Set</code> will be merged together into a larger set.</p>
<p>You can summon a Set binding by summoning a scala <code>Set</code>, as in <code>Set[CommandHandler]</code>.</p>
<p>Let&rsquo;s define a new module with another handler:</p>
<pre class="prettyprint"><code class="language-scala">val subtractionHandler = CommandHandler { 
  case s&quot;$x - $y&quot; =&gt; s&quot;${x.toInt - y.toInt}&quot; 
}
// subtractionHandler: CommandHandler = CommandHandler(&lt;function1&gt;)

object SubtractionModule extends ModuleDef {  
  many[CommandHandler]
    .add(subtractionHandler)
}
</code></pre>
<p>Let&rsquo;s create a command-line application using our command handlers:</p>
<pre class="prettyprint"><code class="language-scala">import distage.Injector

trait App {
  def interpret(input: String): String
}
object App {
  final class Impl(
    handlers: Set[CommandHandler]
  ) extends App {
    override def interpret(input: String): String = {
      handlers.map(_.handle).reduce(_ orElse _).lift(input) match {
        case Some(answer) =&gt; s&quot;ANSWER: $answer&quot;
        case None         =&gt; &quot;?&quot;
      }
    }
  }
}

object AppModule extends ModuleDef {
  // include all the previous module definitions
  include(AdditionModule)
  include(SubtractionModule)
  
  // add a help handler
  many[CommandHandler].add(CommandHandler {
    case &quot;help&quot; =&gt; &quot;Please input an arithmetic expression!&quot; 
  })

  // bind App
  make[App].from[App.Impl]
}

// wire the graph and get the app

val app = Injector().produceGet[App](AppModule).unsafeGet()
// app: App = repl.MdocSession$App16$App$Impl@207ca7c6

// check how it works

app.interpret(&quot;1 + 5&quot;)
// res17: String = &quot;ANSWER: 6&quot;

app.interpret(&quot;7 - 11&quot;)
// res18: String = &quot;ANSWER: -4&quot;

app.interpret(&quot;1 / 3&quot;)
// res19: String = &quot;?&quot;

app.interpret(&quot;help&quot;)
// res20: String = &quot;ANSWER: Please input an arithmetic expression!&quot;
</code></pre>
<p>If we rewire the app without <code>SubtractionModule</code>, it will expectedly lose the ability to subtract:</p>
<pre class="prettyprint"><code class="language-scala">Injector().produceRun(AppModule -- SubtractionModule.keys) {
  app: App =&gt;
    app.interpret(&quot;10 - 1&quot;)
}
// res21: String = &quot;?&quot;
</code></pre>
<p>Further reading:</p>
<ul>
  <li>Guice calls the same concept <a href="https://github.com/google/guice/wiki/Multibindings">&ldquo;Multibindings&rdquo;</a>.</li>
</ul>
<h3><a href="#effect-bindings" name="effect-bindings" class="anchor"><span class="anchor-link"></span></a>Effect Bindings</h3>
<p>Sometimes we want to effectfully create a component, but the resulting component or data does not need to be deallocated. An example might be a global <code>Semaphore</code> to limit the parallelism of the entire application based on configuration, or a test implementation of some service made with <code>Ref</code>s.</p>
<p>In these cases we can use <code>.fromEffect</code> to create a value using an effectful constructor.</p>
<p>Example with a <code>Ref</code>-based Tagless Final <code>KVStore</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{ModuleDef, Injector}
import izumi.functional.bio.{BIOError, Primitives2, F}
import zio.{Task, IO}

trait KVStore[F[_, _]] {
  def get(key: String): F[NoSuchElementException, String]
  def put(key: String, value: String): F[Nothing, Unit]
}

def dummyKVStore[F[+_, +_]: BIOError: Primitives2]: F[Nothing, KVStore[F]] = {
  for {
    ref &lt;- F.mkRef(Map.empty[String, String])
  } yield new KVStore[F] {
    def put(key: String, value: String): F[Nothing, Unit] = {
      ref.update_(_ + (key -&gt; value))
    }
  
    def get(key: String): F[NoSuchElementException, String] = {
      for {
        map &lt;- ref.get
        res &lt;- map.get(key) match {
          case Some(value) =&gt; F.pure(value)
          case None        =&gt; F.fail(new NoSuchElementException(key))
        }
      } yield res
    }
  }
}

def kvStoreModule = new ModuleDef {
  make[KVStore[IO]].fromEffect(dummyKVStore[IO])
}

val io = Injector[Task]()
  .produceRun[String](kvStoreModule) {
    kv: KVStore[IO] =&gt;
      for {
        _    &lt;- kv.put(&quot;apple&quot;, &quot;pie&quot;)
        res1 &lt;- kv.get(&quot;apple&quot;)
        _    &lt;- kv.put(&quot;apple&quot;, &quot;ipad&quot;)
        res2 &lt;- kv.get(&quot;apple&quot;)
      } yield res1 + res2
  }
// io: Task[String] = zio.ZIO$CheckInterrupt@75c63b96

zio.Runtime.default.unsafeRun(io)
// res23: String = pieipad
</code></pre>
<p>You need to specify your effect type when constructing <code>Injector</code>, as in <code>Injector[F]()</code>, to use effect bindings in chosen <code>F[_]</code>.</p>
<h3><a href="#zio-has-bindings" name="zio-has-bindings" class="anchor"><span class="anchor-link"></span></a>ZIO Has Bindings</h3>
<p>You can inject into ZIO Environment using <code>make[_].fromHas</code> syntax for <code>ZLayer</code>, <code>ZManaged</code>, <code>ZIO</code> or any <code>F[_, _, _]: Local3</code>:</p>
<pre class="prettyprint"><code class="language-scala">import zio._
import distage._

def zioEnvCtor: URIO[Has[Dep1] with Has[Dep2], X] = ZIO.succeed(X)
def zmanagedEnvCtor: URManaged[Has[Dep1] with Has[Dep2], X] = ZManaged.succeed(X)
def zlayerEnvCtor: URLayer[Has[Dep1] with Has[Dep2], Has[X]] = ZLayer.succeed(X)

def module1 = new ModuleDef {
  make[X].fromHas(zioEnvCtor)
  // or
  make[X].fromHas(zmanagedEnvCtor)
  // or
  make[X].fromHas(zlayerEnvCtor)
}
</code></pre>
<p>You can also mix environment and parameter dependencies at the same time in one constructor:</p>
<pre class="prettyprint"><code class="language-scala">def zioArgEnvCtor(a: Arg1, b: Arg2): URLayer[Has[Dep1], Has[X]] = ZLayer.fromService(dep1 =&gt; X(a, b, dep1))

def module2 = new ModuleDef {
  make[X].fromHas(zioArgEnvCtor _)
}
</code></pre>
<p><code>zio.Has</code> values are derived at compile-time by <a href="/api/izumi/distage/constructors/HasConstructor.html">HasConstructor</a> macro and can be summoned at need. </p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{ModuleDef, Injector}
import zio.console.{putStrLn, Console}
import zio.{UIO, URIO, Ref, Task, Has}

trait Hello {
  def hello: UIO[String]
}
trait World {
  def world: UIO[String]
}

// Environment forwarders that allow
// using service functions from everywhere

val hello: URIO[Has[Hello], String] = URIO.accessM(_.get.hello)
// hello: URIO[Has[Hello], String] = zio.ZIO$Read@7c21cdf5

val world: URIO[Has[World], String] = URIO.accessM(_.get.world)
// world: URIO[Has[World], String] = zio.ZIO$Read@3dfeb9d8

// service implementations

val makeHello = {
  (for {
    _     &lt;- putStrLn(&quot;Creating Enterprise Hellower...&quot;)
    hello = new Hello { val hello = UIO(&quot;Hello&quot;) }
  } yield hello).toManaged { _ =&gt;
    putStrLn(&quot;Shutting down Enterprise Hellower&quot;)
  }
}
// makeHello: zio.ZManaged[Console, Nothing, AnyRef with Hello{val hello: zio.UIO[String]}] = zio.ZManaged$$anon$2@d46fdea

val makeWorld = {
  for {
    counter &lt;- Ref.make(0)
  } yield new World {
    val world = counter.get.map(c =&gt; if (c &lt; 1) &quot;World&quot; else &quot;THE World&quot;)
  }
}
// makeWorld: zio.ZIO[Any, Nothing, AnyRef with World{val world: zio.ZIO[Any,Nothing,String]}] = zio.ZIO$FlatMap@49987d5f

// the main function

val turboFunctionalHelloWorld: URIO[Has[Hello] with Has[World] with Has[Console.Service], Unit] = {
  for {
    hello &lt;- hello
    world &lt;- world
    _     &lt;- putStrLn(s&quot;$hello $world&quot;)
  } yield ()
}
// turboFunctionalHelloWorld: URIO[Has[Hello] with Has[World] with Has[Console.Service], Unit] = zio.ZIO$FlatMap@3b245ffc

def module = new ModuleDef {
  make[Hello].fromHas(makeHello)
  make[World].fromHas(makeWorld)
  make[Console.Service].fromHas(Console.live)
  make[Unit].fromHas(turboFunctionalHelloWorld)
}

val main = Injector[Task]()
  .produceRun[Unit](module)((_: Unit) =&gt; Task.unit)
// main: Task[Unit] = zio.ZIO$CheckInterrupt@735c0139

zio.Runtime.default.unsafeRun(main)
// Creating Enterprise Hellower...
// Hello World
// Shutting down Enterprise Hellower
</code></pre>
<h4><a href="#converting-zio-environment-dependencies-to-parameters" name="converting-zio-environment-dependencies-to-parameters" class="anchor"><span class="anchor-link"></span></a>Converting ZIO environment dependencies to parameters</h4>
<p>Any ZIO Service that requires an environment can be turned into a service without an environment dependency by providing the dependency in each method using <code>.provide</code>.</p>
<p>This pattern can be generalized by implementing an instance of <code>cats.Contravariant</code> (or <code>cats.tagless.FunctorK</code>) for your services and using it to turn environment dependencies into constructor parameters.</p>
<p>In that way ZIO Environment can be used uniformly for declaration of dependencies, but the dependencies used inside the service do not leak to other services calling it. See: <a href="https://gitter.im/ZIO/Core?at=5dbb06a86570b076740f6db2">https://gitter.im/ZIO/Core?at=5dbb06a86570b076740f6db2</a></p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import cats.Contravariant
import distage.{Injector, ModuleDef, Functoid, Tag, TagK, HasConstructor}
import zio.{Task, UIO, URIO, Has}

trait Dependee[-R] {
  def x(y: String): URIO[R, Int]
}
trait Depender[-R] {
  def y: URIO[R, String]
}
implicit val contra1: Contravariant[Dependee] = new Contravariant[Dependee] {
  def contramap[A, B](fa: Dependee[A])(f: B =&gt; A): Dependee[B] = new Dependee[B] { def x(y: String) = fa.x(y).provideSome(f) }
}
// contra1: Contravariant[Dependee] = repl.MdocSession$App27$$anon$16@494f1b15
implicit val contra2: Contravariant[Depender] = new Contravariant[Depender] {
  def contramap[A, B](fa: Depender[A])(f: B =&gt; A): Depender[B] = new Depender[B] { def y = fa.y.provideSome(f) }
}
// contra2: Contravariant[Depender] = repl.MdocSession$App27$$anon$18@43b7e5e6

type DependeeR = Has[Dependee[Any]]
type DependerR = Has[Depender[Any]]
object dependee extends Dependee[DependeeR] { 
  def x(y: String) = URIO.accessM(_.get.x(y))
}
object depender extends Depender[DependerR] { 
  def y = URIO.accessM(_.get.y) 
}

// cycle
object dependerImpl extends Depender[DependeeR] {
  def y: URIO[DependeeR, String] = dependee.x(&quot;hello&quot;).map(_.toString)
}
object dependeeImpl extends Dependee[DependerR] {
  def x(y: String): URIO[DependerR, Int] = {
    if (y == &quot;hello&quot;) UIO(5) 
    else depender.y.map(y.length + _.length)
  }
}

/** Fulfill the environment dependencies of a service from the object graph */
def fullfill[R: Tag: HasConstructor, M[_]: TagK: Contravariant](service: M[R]): Functoid[M[Any]] = {
  HasConstructor[R]
    .map(depsCakeR =&gt; Contravariant[M].contramap(service)(_ =&gt; depsCakeR))
}

def module = new ModuleDef {
  make[Depender[Any]].from(fullfill(dependerImpl))
  make[Dependee[Any]].from(fullfill(dependeeImpl))
}

Injector()
  .produceRun(module) {
    HasConstructor[DependeeR].map {
      (for {
        r &lt;- dependee.x(&quot;zxc&quot;)
        _ &lt;- Task(println(s&quot;result: $r&quot;))
      } yield ()).provide(_)
    }
  }.fold(_ =&gt; 1, _ =&gt; 0)
// res28: URIO[Any, Int] = &lt;function1&gt;
</code></pre>
<h3><a href="#auto-traits" name="auto-traits" class="anchor"><span class="anchor-link"></span></a>Auto-Traits</h3>
<p>distage can instantiate traits and structural types. All unimplemented fields in a trait, or a refinement are filled in from the object graph.</p>
<p>Trait implementations are derived at compile-time by <a href="/api/izumi/distage/constructors/TraitConstructor.html">TraitConstructor</a> macro and can be summoned at need. </p>
<p>If a suitable trait is specified as an implementation class for a binding, <code>TraitConstructor</code> will be used automatically:</p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{ModuleDef, Id, Injector}

trait Trait1 {
  def a: Int @Id(&quot;a&quot;)
}
trait Trait2 {
  def b: Int @Id(&quot;b&quot;)
}

/** All methods in this trait are implemented,
  * so a constructor for it will be generated
  * even though it&#39;s not a class */
trait Pluser {
  def plus(a: Int, b: Int) = a + b
}

trait PlusedInt {
  def result(): Int
}
object PlusedInt {

  /**
    * Besides the dependency on `Pluser`,
    * this class defines 2 more dependencies
    * to be injected from the object graph:
    *
    * `def a: Int @Id(&quot;a&quot;)` and
    * `def b: Int @Id(&quot;b&quot;)`
    * 
    * When an abstract type is declared as an implementation,
    * its no-argument abstract defs &amp; vals are considered as
    * dependency parameters by TraitConstructor. (empty-parens and
    * parameterized methods are not considered parameters)
    *
    * Here, using an abstract class directly as an implementation
    * lets us avoid writing a lengthier constructor, like this one:
    * 
    * {{{
    *   final class Impl(
    *     pluser: Pluser,
    *     override val a: Int @Id(&quot;a&quot;),
    *     override val b: Int @Id(&quot;b&quot;),
    *   ) extends PlusedInt with Trait1 with Trait2
    * }}}
    */
  abstract class Impl(
    pluser: Pluser
  ) extends PlusedInt
    with Trait1
    with Trait2 {
    override def result(): Int = {
      pluser.plus(a, b)
    }
  }

}

def module = new ModuleDef {
  make[Int].named(&quot;a&quot;).from(1)
  make[Int].named(&quot;b&quot;).from(2)
  make[Pluser]
  make[PlusedInt].from[PlusedInt.Impl]
}

Injector().produceRun(module) {
  plusedInt: PlusedInt =&gt; 
    plusedInt.result()
}
// res30: izumi.fundamentals.platform.functional.package.Identity[Int] = 3
</code></pre>
<h4><a href="#impl-annotation" name="impl-annotation" class="anchor"><span class="anchor-link"></span></a>@impl annotation</h4>
<p>Abstract classes or traits without obvious concrete subclasses may hinder the readability of a codebase, to mitigate that you may use an optional <a href="/api/izumi/distage/model/definition/impl.html">@impl</a> documenting annotation to aid the reader in understanding your intention.</p>
<pre class="prettyprint"><code class="language-scala">import distage.impl

@impl abstract class Impl(
  pluser: Pluser
) extends PlusedInt with Trait1 with Trait2 {
  override def result(): Int = {
    pluser.plus(a, b)
  }
}
</code></pre>
<h4><a href="#avoiding-constructors-even-further" name="avoiding-constructors-even-further" class="anchor"><span class="anchor-link"></span></a>Avoiding constructors even further</h4>
<p>When overriding behavior of a class, you may avoid writing a repeat of its constructor in your sub-class by inheriting it with a trait instead. Example:</p>
<pre class="prettyprint"><code class="language-scala">/**
  * Note how we avoid writing a call to the super-constructor 
  * of `PlusedInt.Impl`, such as:
  *
  * {{{
  *   abstract class OverridenPlusedIntImpl(
  *     pluser: Pluser
  *   ) extends PlusedInt.Impl(pluser)
  * }}}
  *
  * Which would be unavoidable with class-to-class inheritance.
  * Using trait-to-class inheritance we avoid writing any boilerplate
  * besides the overrides we want to apply to the class. 
  */
@impl trait OverridenPlusedIntImpl extends PlusedInt.Impl {
 override def result(): Int = {
   super.result() * 10
 }
}

Injector().produceRun(module overriddenBy new ModuleDef {
  make[PlusedInt].from[OverridenPlusedIntImpl]
}) {
  plusedInt: PlusedInt =&gt; 
    plusedInt.result()
}
// res31: izumi.fundamentals.platform.functional.package.Identity[Int] = 30
</code></pre>
<h3><a href="#auto-factories" name="auto-factories" class="anchor"><span class="anchor-link"></span></a>Auto-Factories</h3>
<p><code>distage</code> can instantiate &lsquo;factory&rsquo; classes from suitable traits. This feature is especially useful with <code>Akka</code>. All unimplemented methods <em>with parameters</em> in a trait will be filled by factory methods:</p>
<p>Given a class <code>ActorFactory</code>:</p>
<pre class="prettyprint"><code class="language-scala">import distage.ModuleDef
import java.util.UUID

class SessionStorage

class UserActor(sessionId: UUID, sessionStorage: SessionStorage)

trait ActorFactory {
  // UserActor will be created as follows:
  //   sessionId argument is provided by the user
  //   sessionStorage argument is wired from the object graph
  def createActor(sessionId: UUID): UserActor
}
</code></pre>
<p>And a binding of <code>ActorFactory</code> <em>without</em> an implementation</p>
<pre class="prettyprint"><code class="language-scala">class ActorModule extends ModuleDef {
  make[ActorFactory]
}
</code></pre>
<p><code>distage</code> will derive and bind the following implementation for <code>ActorFactory</code>:</p>
<pre class="prettyprint"><code class="language-scala">class ActorFactoryImpl(sessionStorage: SessionStorage) extends ActorFactory {
  override def createActor(sessionId: UUID): UserActor = {
    new UserActor(sessionId, sessionStorage)
  }
}
</code></pre>
<h4><a href="#with-annotation" name="with-annotation" class="anchor"><span class="anchor-link"></span></a>@With annotation</h4>
<p><code>@With</code> annotation can be used to specify the implementation class, to avoid leaking the implementation type in factory method result:</p>
<pre class="prettyprint"><code class="language-scala">import distage.{ModuleDef, Injector, With}

trait Actor { 
  def receive(msg: Any): Unit
}

object Actor {
  trait Factory {
    def newActor(id: String): Actor @With[Actor.Impl]
  }

  final class Impl(id: String, config: Actor.Configuration) extends Actor {
    def receive(msg: Any) = {
      val response = s&quot;Actor `$id` received a message: $msg&quot;
      println(if (config.allCaps) response.toUpperCase else response)
    }
  }

  final case class Configuration(allCaps: Boolean)
}

val factoryModule = new ModuleDef {
  make[Actor.Factory]
  make[Actor.Configuration].from(Actor.Configuration(allCaps = false))
}
// factoryModule: AnyRef with ModuleDef = 
// make[{type.repl.MdocSession::repl.MdocSession.App33::repl.MdocSession.App33.Actor::repl.MdocSession.App33.Actor.Configuration}].from(call(ƒ:&lt;function0&gt;(): repl.MdocSession::repl.MdocSession.App33::repl.MdocSession.App33.Actor::repl.MdocSession.App33.Actor.Configuration)) ((basics.md:1001))
// make[{type.repl.MdocSession::repl.MdocSession.App33::repl.MdocSession.App33.Actor::repl.MdocSession.App33.Actor.Factory}].from(call(π:Factory(repl.MdocSession::repl.MdocSession.App33::repl.MdocSession.App33.Actor::repl.MdocSession.App33.Actor.Configuration): repl.MdocSession::repl.MdocSession.App33::repl.MdocSession.App33.Actor::repl.MdocSession.App33.Actor.Factory)) ((basics.md:1000))

Injector()
  .produceGet[Actor.Factory](factoryModule)
  .use(_.newActor(&quot;Martin Odersky&quot;).receive(&quot;ping&quot;))
// Actor `Martin Odersky` received a message: ping
// res34: izumi.fundamentals.platform.functional.package.Identity[Unit] = ()
</code></pre>
<p>You can use this feature to concisely provide non-Singleton semantics for some of your components.</p>
<p>Factory implementations are derived at compile-time by <a href="/api/izumi/distage/constructors/FactoryConstructor.html">FactoryConstructor</a> macro and can be summoned at need.</p>
<h3><a href="#tagless-final-style" name="tagless-final-style" class="anchor"><span class="anchor-link"></span></a>Tagless Final Style</h3>
<p>Tagless Final is one of the popular patterns for structuring purely-functional applications.</p>
<p>Brief introduction to tagless final:</p>
<ul>
  <li><a href="https://medium.com/@calvin.l.fer/deferring-commitments-tagless-final-704d768f15cb">Deferring Commitments: Tagless Final</a></li>
  <li><a href="https://www.beyondthelines.net/programming/introduction-to-tagless-final/">Introduction to Tagless Final</a></li>
</ul>
<p>Advantages of <code>distage</code> as a driver for TF compared to implicits:</p>
<ul>
  <li>easy explicit overrides</li>
  <li>easy <a href="basics.html#effect-bindings">effectful instantiation</a> and <a href="basics.html#resource-bindings-lifecycle">resource management</a></li>
  <li>extremely easy &amp; scalable <a href="distage-testkit.html#testkit">test</a> context setup due to the above</li>
  <li>multiple different implementations for a type using disambiguation by <code>@Id</code></li>
</ul>
<p>For example, let&rsquo;s take <a href="http://frees.io/docs/core/handlers/#tagless-interpretation">freestyle&rsquo;s tagless example</a> and make it safer and more flexible by replacing dependencies on global <code>import</code>ed implementations from with explicit modules.</p>
<p>First, the program we want to write:</p>
<pre class="prettyprint"><code class="language-scala">import cats.Monad
import cats.effect.{Sync, IO}
import cats.syntax.all._
import distage.{Roots, Module, ModuleDef, Injector, Tag, TagK, TagKK}

trait Validation[F[_]] {
  def minSize(s: String, n: Int): F[Boolean]
  def hasNumber(s: String): F[Boolean]
}
object Validation {
  def apply[F[_]: Validation]: Validation[F] = implicitly
}

trait Interaction[F[_]] {
  def tell(msg: String): F[Unit]
  def ask(prompt: String): F[String]
}
object Interaction {
  def apply[F[_]: Interaction]: Interaction[F] = implicitly
}

class TaglessProgram[F[_]: Monad: Validation: Interaction] {
  def program: F[Unit] = for {
    userInput &lt;- Interaction[F].ask(&quot;Give me something with at least 3 chars and a number on it&quot;)
    valid     &lt;- (Validation[F].minSize(userInput, 3), Validation[F].hasNumber(userInput)).mapN(_ &amp;&amp; _)
    _         &lt;- if (valid) Interaction[F].tell(&quot;awesomesauce!&quot;)
                 else       Interaction[F].tell(s&quot;$userInput is not valid&quot;)
  } yield ()
}

def ProgramModule[F[_]: TagK: Monad] = new ModuleDef {
  make[TaglessProgram[F]]
}
</code></pre>
<p><a href="/api/izumi/reflect/TagK.html">TagK</a> is <code>distage</code>&rsquo;s analogue of <code>TypeTag</code> for higher-kinded types such as <code>F[_]</code>, it allows preserving type-information at runtime for type parameters. You&rsquo;ll need to add a <a href="/api/izumi/reflect/TagK.html">TagK</a> context bound to create a module parameterized by an abstract <code>F[_]</code>. To parameterize by non-higher-kinded types, use just <a href="/api/izumi/reflect/Tag.html">Tag</a>.</p>
<p>Now the interpreters for <code>Validation</code> and <code>Interaction</code>:</p>
<pre class="prettyprint"><code class="language-scala">final class SyncValidation[F[_]](implicit F: Sync[F]) extends Validation[F] {
  def minSize(s: String, n: Int): F[Boolean] = F.delay(s.size &gt;= n)
  def hasNumber(s: String): F[Boolean]       = F.delay(s.exists(c =&gt; &quot;0123456789&quot;.contains(c)))
}
  
final class SyncInteraction[F[_]](implicit F: Sync[F]) extends Interaction[F] {
  def tell(s: String): F[Unit]  = F.delay(println(s))
  def ask(s: String): F[String] = F.delay(&quot;This could have been user input 1&quot;)
}

def SyncInterpreters[F[_]: TagK: Sync] = {
  new ModuleDef {
    make[Validation[F]].from[SyncValidation[F]]
    make[Interaction[F]].from[SyncInteraction[F]]
  }
}

// combine all modules

def SyncProgram[F[_]: TagK: Sync] = ProgramModule[F] ++ SyncInterpreters[F]

// create object graph Resource

val objectsResource = Injector[IO]().produce(SyncProgram[IO], Roots.Everything)
// objectsResource: izumi.distage.model.definition.Lifecycle[IO, izumi.distage.model.Locator] = izumi.distage.model.definition.Lifecycle$$anon$10@5af599d3

// run

objectsResource.use(_.get[TaglessProgram[IO]].program).unsafeRunSync()
// awesomesauce!
</code></pre>
<h4><a href="#out-of-the-box-typeclass-instances" name="out-of-the-box-typeclass-instances" class="anchor"><span class="anchor-link"></span></a>Out-of-the-box typeclass instances</h4>
<p>Note: we did not have to include either <code>Monad[IO]</code> or <code>Sync[IO]</code> instances for our program to run, despite the fact that <code>SyncInteraction</code> depends on <code>Sync[F]</code>.</p>
<p>This is because <code>distage</code> includes all the relevant typeclass instances for the provided effect type by default, using implicits. In general whenever <code>cats-effect</code> is on the classpath and your effect type has <code>cats-effect</code> instances, they will be included, this is valid for <code>ZIO</code>, <code>cats.effect.IO</code>, <code>monix</code>, <code>monix-bio</code> and any other type with cats-effect instances. For ZIO, <code>monix-bio</code> and any other implementors of <a href="../bio/index.html">BIO</a>, instances of bifunctor <a href="../bio/index.html">BIO</a> effect hierarchy will also be included. See <a href="/api/izumi/distage/modules/DefaultModule.html"><code>DefaultModule</code></a> for more details.</p>
<h4><a href="#effect-type-polymorphism" name="effect-type-polymorphism" class="anchor"><span class="anchor-link"></span></a>Effect-type polymorphism</h4>
<p>The program module is polymorphic over effect type. It can be instantiated by a different effect:</p>
<pre class="prettyprint"><code class="language-scala">import zio.interop.catz._
import zio.Task

val ZIOProgram = ProgramModule[Task] ++ SyncInterpreters[Task]
// ZIOProgram: Module = 
// make[{type.repl.MdocSession::repl.MdocSession.App35::repl.MdocSession.App35.Interaction[=λ %0 → ZIO[-Any,+Throwable,+0]]}].from(call(π:Class(cats.effect.Sync[=λ %0 → ZIO[-Any,+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App35::repl.MdocSession.App35.SyncInteraction[=λ %0 → ZIO[-Any,+Throwable,+0]])) ((basics.md:1083))
// make[{type.repl.MdocSession::repl.MdocSession.App35::repl.MdocSession.App35.Validation[=λ %0 → ZIO[-Any,+Throwable,+0]]}].from(call(π:Class(cats.effect.Sync[=λ %0 → ZIO[-Any,+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App35::repl.MdocSession.App35.SyncValidation[=λ %0 → ZIO[-Any,+Throwable,+0]])) ((basics.md:1082))
// make[{type.repl.MdocSession::repl.MdocSession.App35::repl.MdocSession.App35.TaglessProgram[=λ %0 → ZIO[-Any,+Throwable,+0]]}].from(call(π:Class(cats.Monad[=λ %0 → ZIO[-Any,+Throwable,+0]], repl.MdocSession::repl.MdocSession.App35::repl.MdocSession.App35.Validation[=λ %0 → ZIO[-Any,+Throwable,+0]], repl.MdocSession::repl.MdocSession.App35::repl.MdocSession.App35.Interaction[=λ %0 → ZIO[-Any,+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App35::repl.MdocSession.App35.TaglessProgram[=λ %0 → ZIO[-Any,+Throwable,+0]])) ((basics.md:1061))
</code></pre>
<p>We may even choose different interpreters at runtime:</p>
<pre class="prettyprint"><code class="language-scala">import zio.RIO
import zio.console.{Console, getStrLn, putStrLn}
import distage.Activation

object RealInteractionZIO extends Interaction[RIO[Console, ?]] {
  def tell(s: String): RIO[Console, Unit]  = putStrLn(s)
  def ask(s: String): RIO[Console, String] = putStrLn(s) *&gt; getStrLn
}

val RealInterpretersZIO = {
  SyncInterpreters[RIO[Console, ?]] overriddenBy new ModuleDef {
    make[Interaction[RIO[Console, ?]]].from(RealInteractionZIO)
  }
}
// RealInterpretersZIO: Module = 
// make[{type.repl.MdocSession::repl.MdocSession.App35::repl.MdocSession.App35.Interaction[=λ %1:0 → ZIO[-Has[=package::Console::Service],+Throwable,+1:0]]}].from(call(ƒ:&lt;function0&gt;(): repl.MdocSession::repl.MdocSession.App35::repl.MdocSession.App35.RealInteractionZIO)) ((basics.md:1129))
// make[{type.repl.MdocSession::repl.MdocSession.App35::repl.MdocSession.App35.Validation[=λ %0 → ZIO[-Has[=package::Console::Service],+Throwable,+0]]}].from(call(π:Class(cats.effect.Sync[=λ %0 → ZIO[-Has[=package::Console::Service],+Throwable,+0]]): repl.MdocSession::repl.MdocSession.App35::repl.MdocSession.App35.SyncValidation[=λ %0 → ZIO[-Has[=package::Console::Service],+Throwable,+0]])) ((basics.md:1082))

def chooseInterpreters(isDummy: Boolean) = {
  val interpreters = if (isDummy) SyncInterpreters[RIO[Console, ?]]
                     else         RealInterpretersZIO
  val module = ProgramModule[RIO[Console, ?]] ++ interpreters
  
  Injector[RIO[Console, ?]]()
    .produceGet[TaglessProgram[RIO[Console, ?]]](module, Activation.empty)
}

// execute

chooseInterpreters(true)
// res37: izumi.distage.model.definition.Lifecycle[zio.ZIO[zio.Has[Console.Service], Throwable, β$6$], TaglessProgram[zio.ZIO[zio.Has[Console.Service], Throwable, β$7$]]] = izumi.distage.model.definition.Lifecycle$$anon$9@49b30e7d
</code></pre>
<h4><a href="#kind-polymorphism" name="kind-polymorphism" class="anchor"><span class="anchor-link"></span></a>Kind polymorphism</h4>
<p>Modules can be polymorphic over arbitrary kinds - use <code>TagKK</code> to abstract over bifunctors:</p>
<pre class="prettyprint"><code class="language-scala">class BifunctorIOModule[F[_, _]: TagKK] extends ModuleDef
</code></pre>
<p>Or use <code>Tag.auto.T</code> to abstract over any kind:</p>
<pre class="prettyprint"><code class="language-scala">class MonadTransModule[F[_[_], _]: Tag.auto.T] extends ModuleDef
</code></pre>
<pre class="prettyprint"><code class="language-scala">class TrifunctorModule[F[_, _, _]: Tag.auto.T] extends ModuleDef
</code></pre>
<pre class="prettyprint"><code class="language-scala">class EldritchModule[F[+_, -_[_, _], _[_[_, _], _], _]: Tag.auto.T] extends ModuleDef
</code></pre>
<p>consult <a href="https://javadoc.io/doc/dev.zio/izumi-reflect_2.13/latest/izumi/reflect/HKTag.html">izumi.reflect.HKTag</a> docs for more details.</p>
<h3><a href="#cats-zio-integration" name="cats-zio-integration" class="anchor"><span class="anchor-link"></span></a>Cats &amp; ZIO Integration</h3>
<p>Cats &amp; ZIO instances and syntax are available automatically in <code>distage-core</code>, without wildcard imports, if your project depends on <code>cats-core</code>, <code>cats-effect</code> or <code>zio</code>. However, distage <em>won&rsquo;t</em> bring in <code>cats</code> or <code>zio</code> as dependencies if you don&rsquo;t already depend on them. (see <a href="https://blog.7mind.io/no-more-orphans.html">No More Orphans</a> blog post for details on how that works)</p>
<p><a href="basics.html#resource-bindings-lifecycle">Cats Resource &amp; ZIO ZManaged Bindings</a> also work out of the box without any magic imports.</p>
<p>All relevant typeclass instances for chosen effect type, such as <code>ConcurrentEffect[F]</code>, are <a href="basics.html#out-of-the-box-typeclass-instances">included by default</a> (overridable by user bindings)</p>
<p>Example:</p>
<pre class="prettyprint"><code class="language-scala">import cats.syntax.semigroup._
import cats.effect.{ExitCode, IO, IOApp}
import distage.{DIKey, Roots, Injector}

trait AppEntrypoint {
  def run: IO[Unit]
}

object Main extends IOApp {
  override def run(args: List[String]): IO[ExitCode] = {
    
    // `distage.Module` has a Monoid instance

    val myModules = ProgramModule[IO] |+| SyncInterpreters[IO]

    val plan = Injector().plan(myModules, Roots.target[AppEntrypoint])

    for {
      // resolveImportsF can effectfully add missing instances to an existing plan
      // (You can also create instances effectfully inside `ModuleDef` via `make[_].fromEffect` bindings)

      newPlan &lt;- plan.resolveImportsF[IO] {
        case i if i.target == DIKey[DBConnection] =&gt;
           DBConnection.create[IO]
      }

      // Effects used in Resource and Effect Bindings 
      // should match the effect `F[_]` in `Injector[F]()`

      _ &lt;- Injector[IO]().produce(newPlan).use {
        classes =&gt;
          classes.get[AppEntrypoint].run
      }
    } yield ExitCode.Success
  }
}
</code></pre>
</div>
<div>
<a href="https://github.com/7mind/izumi/tree/v1.0.0-M1/doc/microsite/target/mdoc/distage/basics.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
1.0.0-M1
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../distage/index.html" title="distage: Staged Dependency Injection" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
distage: Staged Dependency Injection
</span>
</div>
</a>
<a href="../distage/debugging.html" title="Debugging" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Debugging
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
7mind.io
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
